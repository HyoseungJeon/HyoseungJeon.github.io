<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>HyoSeung IT blog</title>
    <link>https://HyoseungJeon.github.io/</link>
    <description>Recent content on HyoSeung IT blog</description>
    <image>
      <title>HyoSeung IT blog</title>
      <url>https://avatars.githubusercontent.com/u/39950673?s=400&u=729b17ca9c5632e754da66f17f45eb61aeea271e&v=4</url>
      <link>https://avatars.githubusercontent.com/u/39950673?s=400&u=729b17ca9c5632e754da66f17f45eb61aeea271e&v=4</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Thu, 27 Jul 2023 15:13:07 +0900</lastBuildDate><atom:link href="https://HyoseungJeon.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Nice 본인인증</title>
      <link>https://HyoseungJeon.github.io/posts/api/nice%EB%B3%B8%EC%9D%B8%EC%9D%B8%EC%A6%9D/</link>
      <pubDate>Thu, 27 Jul 2023 15:13:07 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/api/nice%EB%B3%B8%EC%9D%B8%EC%9D%B8%EC%A6%9D/</guid>
      <description>Nice 본인인증 이란? NICE 평가정보 회사에서 제공하는 본인 확인 서비스로 사용자의 주민등록번호 등과 같은 정보를 통해 실명 확인 과정을 거쳐 사용자의 명의를 확인할 수 있는 기능을 제공하는 API 이다.
아마 내 생각엔 국내에서 개인 인증을 해야 하는 모든 사이트들이 API를 사용하여 인증을 하고 있을 것이다! 나 또한 엄청 쓰는 것 같다..
해서 프로젝트 에서는 Nice 본인인증의 휴대폰 본인확인 방식을 넣게 되었다!
개발 개발 방향 해당 API 에 관련하여 Docs 에서 자료를 찾아본 결과, API 호출 방식과 jsp file로 구현하는 방식으로 2개의 가이드라인을 제공하고 있었다.</description>
    </item>
    
    <item>
      <title>Reflection</title>
      <link>https://HyoseungJeon.github.io/posts/java/reflection/</link>
      <pubDate>Fri, 21 Jul 2023 13:48:03 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/java/reflection/</guid>
      <description>Reflection이란? 정의 Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions. The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.</description>
    </item>
    
    <item>
      <title>Generic</title>
      <link>https://HyoseungJeon.github.io/posts/java/generic/</link>
      <pubDate>Fri, 21 Jul 2023 08:27:33 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/java/generic/</guid>
      <description>Generic이란? Oracle Java Docs에서는 A generic type is a generic class or interface that is parameterized over types. 라고 설명하고 있다.
Type을 매개 변수로 받는 class, interface 라고 해석이 되는 듯하다..? 😂
즉, class를 정의할 때에 바깥에서 class 내부 field의 type를 정의할 수 있는 방법이다.
하여 객체를 선언할 때 class는 같지만 field Type이 다른 형태로 만들 수 있다. 우리가 가장 익숙한 곳은 아마 Collection Lib 를 사용할 때 일거다.</description>
    </item>
    
    <item>
      <title>Async</title>
      <link>https://HyoseungJeon.github.io/posts/spring/async/</link>
      <pubDate>Thu, 20 Jul 2023 11:07:59 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/spring/async/</guid>
      <description>알게된 계기 이전 포스팅에서 Java의 Future 관련한 내용을 작성했었다. 그 내용을 요약하면 메일, 문자 발송 시스템의 처리 시간이 너무 불필요하게 길다는 것 이였다. 그 문제의 원인은 결국 blocking 발생 이였다. 하지만 Future 를 통하여 구현된 부분은 request 송신에 공통으로 사용된 부분 이였고 이와 별개로 내부 process Logic내에서 필요 없는 cost를 통해 지연이 발생하였고 하여 이를 병렬 처리하는 것이 필요했다. 하여 내용을 찾아보던 중 Spring에서 비동기 method 기능을 지원한다는 것을 발견하였다.</description>
    </item>
    
    <item>
      <title>23.07.18</title>
      <link>https://HyoseungJeon.github.io/posts/%EC%9D%BC%EA%B8%B0%EC%9E%A5/23-07-18/</link>
      <pubDate>Tue, 18 Jul 2023 14:47:51 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/%EC%9D%BC%EA%B8%B0%EC%9E%A5/23-07-18/</guid>
      <description>개발 블로그를 처음으로 개설했다..!
사실 이전부터 블로그를 만들어 보려고 했지만 그 필요성을 잘 느끼지 못하여.. 만들지 않았다..! 무언가 다른 개발자들에게 정확하지 않은 정보를 전달하게 되거나 혹은 그냥 포트폴리오를 보여주기 위한 도구 같다고만 느꼈다..
근데 실제 취업 후 여러 프로젝트를 진행해보며 여러 장애들을 겪고 또 야근을 하며 개발을 해보며 지내본 결과.. 내 경험을 모두 머리속에 기억하기는 정말로 어렵다.. 기존에는 노트나 메모지에 적어두고 기록해 왔었는데 실제로 해당 내용을 다시 찾을 때에는 너무 시간이 오래 걸리고 때때로 급한 마음에 마구마구 갈겨 쓴 글씨 때문에 나 조차도 못알아보는 기록들이 너무 많았다 ㅠ&amp;hellip;</description>
    </item>
    
    <item>
      <title>setDate</title>
      <link>https://HyoseungJeon.github.io/posts/javascript/date/setdate/</link>
      <pubDate>Tue, 18 Jul 2023 11:13:10 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/javascript/date/setdate/</guid>
      <description>dateObj.setDate(dayValue) var theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(24); // 1962-07-24 theBigDay.setDate(22); // 1962-08-22 해당 Date 객체의 날짜(day)를 설정하는 함수
입력된 dayValue 값으로 날짜를 변경 한다.
별로 특이해 보이지 않지만 변경 이라는 부분 때문에 보이지 않는 에러가 발생한 경우가 있다.
위 기능을 통하여 js 내에서 날짜를 변경 하게 되는데
var theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(32); // 1962-08-01 theBigDay.setDate(0); // 1962-07-31 예제와 같이 날짜 범위를 자동으로 계산해 Date를 set 한다.</description>
    </item>
    
    <item>
      <title>Thymeleaf</title>
      <link>https://HyoseungJeon.github.io/posts/intellij/thymeleaf/</link>
      <pubDate>Tue, 18 Jul 2023 11:13:10 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/intellij/thymeleaf/</guid>
      <description>프로젝트를 옮기고 Spring 프로젝트를 세팅 하는 중 build error가 발생하였다!
그 중 익숙하지 않은 build error가 있었는데
Thymeleaf 관련 Directory를 추적하지 못하여 file not found Error가 나왔다..!
알고 보니 따로 Template Engine을 설정하여 Project를 생성한 경우가 아닐 시 자동으로 추적 경로가 등록되지 않는 경우 같더라..
내용을 추가적으로 찾아보니 Maven의 경우 따로 실행 Configurations 내 Working Directory 잡아주어야 한다는 내용을 찾았다..!
Thymeleaf 프로젝트 build 시 Maven 관리 도구를 사용 중이고 따로 importing 한 프로젝트 라면 /WEB-INF/</description>
    </item>
    
    <item>
      <title>Future</title>
      <link>https://HyoseungJeon.github.io/posts/java/future/</link>
      <pubDate>Mon, 17 Jul 2023 13:03:35 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/java/future/</guid>
      <description>Future란? Java 1.5에 공개된 비동기 process 처리를 지원하는 interface Class 이다.
비동기 방식을 지원하기 위해 당연하게도 mulitThread 방식을 활용하여 해당 기능을 지원하고 있다. 기존의 Thread 직접 선언 및 관리 방식과 다르게 interface를 활용하여 비동기를 구현할 수 있어 안정적인 비동기 구현 방법이다.
해당 비동기 process를 호출 thread에서 사용 가능하다.
단, 해당 값 조회를 시도할 시 blocking 상태로 변화하여 지연이 발생할 수 있다.
Methods V get(), get(Long time, TimeUnit unit)
실행 결과 값을 조회하는 method</description>
    </item>
    
    <item>
      <title>Spring</title>
      <link>https://HyoseungJeon.github.io/spring/</link>
      <pubDate>Thu, 13 Jul 2023 11:26:21 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/spring/</guid>
      <description></description>
    </item>
    
    <item>
      <title>첫 포스트</title>
      <link>https://HyoseungJeon.github.io/ch/</link>
      <pubDate>Thu, 13 Jul 2023 09:44:22 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/ch/</guid>
      <description></description>
    </item>
    
    <item>
      <title>RequestContextHolder</title>
      <link>https://HyoseungJeon.github.io/posts/spring/requestcontextholder/</link>
      <pubDate>Fri, 07 Jul 2023 10:47:43 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/spring/requestcontextholder/</guid>
      <description>설명 Spring 2.0 부터 추가된 기능으로 Request 인입 후 thread 생성 된 시점부터 전 구간에서 HttpServletRequest에 접근을 가능하게 해주는 기능이다.
기존 Controller 단에 parameter 형식으로 선언 후 참고하던 방식과 다르게 위 객체를 통하여 request에 접근이 가능하다.
예제 소스 :
@GetMapping(&amp;#34;hello&amp;#34;) public void before(HttpServletRequest request) { sampleService.hello(request); } @GetMapping(&amp;#34;hello&amp;#34;) public void after() { HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest(); sampleService.hello(request); } 동작 원리 Request 인입 시 Spring 내 ThreadLocal 이라는 공간에 값을 저장하는 방식이다.</description>
    </item>
    
    <item>
      <title>My 1st post</title>
      <link>https://HyoseungJeon.github.io/test1/</link>
      <pubDate>Tue, 15 Sep 2020 11:30:03 +0000</pubDate>
      
      <guid>https://HyoseungJeon.github.io/test1/</guid>
      <description>Desc Text.</description>
    </item>
    
    
    
  </channel>
</rss>
