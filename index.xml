<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>HyoSeung IT blog</title>
    <link>https://HyoseungJeon.github.io/</link>
    <description>Recent content on HyoSeung IT blog</description>
    <image>
      <title>HyoSeung IT blog</title>
      <url>https://avatars.githubusercontent.com/u/39950673?s=400&u=729b17ca9c5632e754da66f17f45eb61aeea271e&v=4</url>
      <link>https://avatars.githubusercontent.com/u/39950673?s=400&u=729b17ca9c5632e754da66f17f45eb61aeea271e&v=4</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Thu, 20 Jul 2023 11:07:59 +0900</lastBuildDate><atom:link href="https://HyoseungJeon.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Async</title>
      <link>https://HyoseungJeon.github.io/posts/spring/async/</link>
      <pubDate>Thu, 20 Jul 2023 11:07:59 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/spring/async/</guid>
      <description>알게된 계기 이전 포스팅에서 Java의 Future 관련한 내용을 작성했었다. 그 내용을 요약하면 메일, 문자 발송 시스템의 처리 시간이 너무 불필요하게 길다는 것 이였다. 그 문제의 원인은 결국 blocking 발생 이였다. 하지만 Future 를 통하여 구현된 부분은 request 송신에 공통으로 사용된 부분 이였고 이와 별개로 내부 process Logic내에서 필요 없는 cost를 통해 지연이 발생하였고 하여 이를 병렬 처리하는 것이 필요했다. 하여 내용을 찾아보던 중 Spring에서 비동기 method 기능을 지원한다는 것을 발견하였다.</description>
    </item>
    
    <item>
      <title>23.07.18</title>
      <link>https://HyoseungJeon.github.io/posts/%EC%9D%BC%EA%B8%B0%EC%9E%A5/23-07-18/</link>
      <pubDate>Tue, 18 Jul 2023 14:47:51 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/%EC%9D%BC%EA%B8%B0%EC%9E%A5/23-07-18/</guid>
      <description>개발 블로그를 처음으로 개설했다..!
사실 이전부터 블로그를 만들어 보려고 했지만 그 필요성을 잘 느끼지 못하여.. 만들지 않았다..! 무언가 다른 개발자들에게 정확하지 않은 정보를 전달하게 되거나 혹은 그냥 포트폴리오를 보여주기 위한 도구 같다고만 느꼈다..
근데 실제 취업 후 여러 프로젝트를 진행해보며 여러 장애들을 겪고 또 야근을 하며 개발을 해보며 지내본 결과.. 내 경험을 모두 머리속에 기억하기는 정말로 어렵다.. 기존에는 노트나 메모지에 적어두고 기록해 왔었는데 실제로 해당 내용을 다시 찾을 때에는 너무 시간이 오래 걸리고 때때로 급한 마음에 마구마구 갈겨 쓴 글씨 때문에 나 조차도 못알아보는 기록들이 너무 많았다 ㅠ&amp;hellip;</description>
    </item>
    
    <item>
      <title>setDate</title>
      <link>https://HyoseungJeon.github.io/posts/javascript/date/setdate/</link>
      <pubDate>Tue, 18 Jul 2023 11:13:10 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/javascript/date/setdate/</guid>
      <description>dateObj.setDate(dayValue) var theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(24); // 1962-07-24 theBigDay.setDate(22); // 1962-08-22 해당 Date 객체의 날짜(day)를 설정하는 함수
입력된 dayValue 값으로 날짜를 변경 한다.
별로 특이해 보이지 않지만 변경 이라는 부분 때문에 보이지 않는 에러가 발생한 경우가 있다.
위 기능을 통하여 js 내에서 날짜를 변경 하게 되는데
var theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(32); // 1962-08-01 theBigDay.setDate(0); // 1962-07-31 예제와 같이 날짜 범위를 자동으로 계산해 Date를 set 한다.</description>
    </item>
    
    <item>
      <title>Thymeleaf</title>
      <link>https://HyoseungJeon.github.io/posts/intellij/thymeleaf/</link>
      <pubDate>Tue, 18 Jul 2023 11:13:10 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/intellij/thymeleaf/</guid>
      <description>프로젝트를 옮기고 Spring 프로젝트를 세팅 하는 중 build error가 발생하였다!
그 중 익숙하지 않은 build error가 있었는데
Thymeleaf 관련 Directory를 추적하지 못하여 file not found Error가 나왔다..!
알고 보니 따로 Template Engine을 설정하여 Project를 생성한 경우가 아닐 시 자동으로 추적 경로가 등록되지 않는 경우 같더라..
내용을 추가적으로 찾아보니 Maven의 경우 따로 실행 Configurations 내 Working Directory 잡아주어야 한다는 내용을 찾았다..!
Thymeleaf 프로젝트 build 시 Maven 관리 도구를 사용 중이고 따로 importing 한 프로젝트 라면 /WEB-INF/</description>
    </item>
    
    <item>
      <title>Future</title>
      <link>https://HyoseungJeon.github.io/posts/java/future/</link>
      <pubDate>Mon, 17 Jul 2023 13:03:35 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/java/future/</guid>
      <description>Future란? Java 1.5에 공개된 비동기 process 처리를 지원하는 interface Class 이다.
비동기 방식을 지원하기 위해 당연하게도 mulitThread 방식을 활용하여 해당 기능을 지원하고 있다. 기존의 Thread 직접 선언 및 관리 방식과 다르게 interface를 활용하여 비동기를 구현할 수 있어 안정적인 비동기 구현 방법이다.
해당 비동기 process를 호출 thread에서 사용 가능하다.
단, 해당 값 조회를 시도할 시 blocking 상태로 변화하여 지연이 발생할 수 있다.
Methods V get(), get(Long time, TimeUnit unit)
실행 결과 값을 조회하는 method</description>
    </item>
    
    <item>
      <title>Spring</title>
      <link>https://HyoseungJeon.github.io/spring/</link>
      <pubDate>Thu, 13 Jul 2023 11:26:21 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/spring/</guid>
      <description></description>
    </item>
    
    <item>
      <title>첫 포스트</title>
      <link>https://HyoseungJeon.github.io/ch/</link>
      <pubDate>Thu, 13 Jul 2023 09:44:22 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/ch/</guid>
      <description></description>
    </item>
    
    <item>
      <title>RequestContextHolder</title>
      <link>https://HyoseungJeon.github.io/posts/spring/requestcontextholder/</link>
      <pubDate>Fri, 07 Jul 2023 10:47:43 +0900</pubDate>
      
      <guid>https://HyoseungJeon.github.io/posts/spring/requestcontextholder/</guid>
      <description>설명 Spring 2.0 부터 추가된 기능으로 Request 인입 후 thread 생성 된 시점부터 전 구간에서 HttpServletRequest에 접근을 가능하게 해주는 기능이다.
기존 Controller 단에 parameter 형식으로 선언 후 참고하던 방식과 다르게 위 객체를 통하여 request에 접근이 가능하다.
예제 소스 :
@GetMapping(&amp;#34;hello&amp;#34;) public void before(HttpServletRequest request) { sampleService.hello(request); } @GetMapping(&amp;#34;hello&amp;#34;) public void after() { HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest(); sampleService.hello(request); } 동작 원리 Request 인입 시 Spring 내 ThreadLocal 이라는 공간에 값을 저장하는 방식이다.</description>
    </item>
    
    <item>
      <title>My 1st post</title>
      <link>https://HyoseungJeon.github.io/test1/</link>
      <pubDate>Tue, 15 Sep 2020 11:30:03 +0000</pubDate>
      
      <guid>https://HyoseungJeon.github.io/test1/</guid>
      <description>Desc Text.</description>
    </item>
    
    
    
  </channel>
</rss>
