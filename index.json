[{"content":" 💡 Back Office의 특정 페이지에서 click event 발생 시 페이지가 자꾸 reload 되는 문제가 발견되었다! 사용량이 낮아 발견되지 않았던 것 같다.. 한번 살펴보자!! 문제 현상 페이지 내의 특정 영역 내의 버튼을 누르면 페이지가 자꾸 reload 되었다! 하여 해당 페이지의 기능이 제 역할을 하지 못하고 있었다..\n원인 문제의 원인은 굉장히 간단했다! Back Ofiice의 개발 가이드가 명확히 나와있지 않아 각자 개발자가 개발하던 중 특정 개발자는 tag를 영역 전체에 씌워 두었다..! 하여 해당 영역 내의 버튼 중 따로 type을 정의하지 않은 것을 클릭 시 submit Event가 발생하여 페이지를 자기 자신으로 redirect하고 있었다.. (허무😂)\n느낀점 확실히 Html의 기본적인 동작에 대한 이해도가 떨어진 상태로 작업을 한다면 위와 같은 문제를 쉽게 만드는 것 같다.. 혹은 귀찮음? 과 같은 여러 원인들로 인하여 작업을 소홀히 하게 되고 결국 다른 개발자나 차후에 문제가 해결하기 어려워 진 후에 수정을 하게 된다..!\nHtml의 각 Tag는 그 역할이 분명하다! 때문에 그 이름이 다르고 기본적인 동작 방식과 속성값들도 다르다! 하여 그 역할에 맞게 그 상하위 관계를 고려하여 작업을 하고 그로 인한 side effect도 당연하게 고려를 하여 작업을 해야할 것 같다! 굉장히 사소한 작업자의 부주의로 화면은 제 역할을 아예 하지 못하는 상황 이였고, 나와 같은 다음 작업자가 이미 페이지의 내용이 꽉꽉 채워진 상황에서는 그 문제의 원인을 찾기도 어려워 진 상황이 만들어 진다.\n항상 작업을 할 때에는 그 목적을 명확히 하고 충분히 고려한 후 이유 있는 작업을 하자..!! 그러다 보면 고려하는 작업 없이도 내 몸에 적응하여 Rule에 따르는 코딩을 하게 될 것이다!! 신경 써서 작업하자!!!!\n","permalink":"https://HyoseungJeon.github.io/posts/javascript/pagereloadissue/","summary":"💡 Back Office의 특정 페이지에서 click event 발생 시 페이지가 자꾸 reload 되는 문제가 발견되었다! 사용량이 낮아 발견되지 않았던 것 같다.. 한번 살펴보자!! 문제 현상 페이지 내의 특정 영역 내의 버튼을 누르면 페이지가 자꾸 reload 되었다! 하여 해당 페이지의 기능이 제 역할을 하지 못하고 있었다..\n원인 문제의 원인은 굉장히 간단했다! Back Ofiice의 개발 가이드가 명확히 나와있지 않아 각자 개발자가 개발하던 중 특정 개발자는 tag를 영역 전체에 씌워 두었다..! 하여 해당 영역 내의 버튼 중 따로 type을 정의하지 않은 것을 클릭 시 submit Event가 발생하여 페이지를 자기 자신으로 redirect하고 있었다.","title":"Page Reload Issue"},{"content":" 💡 요즘 프로젝트를 가면 다 MSA 환경으로 개발하고 있다! 하여 APM을 통한 모니터링을 할 때 TraceId를 통해 flow를 확인하고 있는데.. 실제로 이게 어떻게 구현되는지 궁금했다..! 한번 그에 대해 내용을 알아보자~~~!😊😊 개요 MSA 환경의 Monitoring 대부분의 프로젝트는 요즘 분산 환경으로 구현되어 있다! 하여 복잡한 로직들은 N개의 프로젝트 흐름을 거쳐 실행된다! 하지만 실제로 해당 흐름을 추적하는 일은 조금 어렵다.. (Trace Id가 없었다면..!) 하여 위와 같은 애로사항을 해결하기 위한 방법이 필요했고 그 방식으로 TraceId를 부여하는 logging 방식이 등장했다!\nTraceId 채번을 통한 Logging 방식은 Spring Boot Project에선 주로 Zipkin, Spring Cloud Sleuth 로 구현한다!\nZipkin 분산 어플리케이션 환경에서 흐름에 대한 정보를 수집하는 역할을 하는 Lib 이다.\nSpring Cloud Sleuth Spring Boot 내에서 분산 추적을 위한 자동 구성을 지원하는 Lib 이다.\n각 Lib에 대한 자세한 내용은 밑에서 다루어 보자!\nZipkin 정의 Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures. Features include both the collection and lookup of this data.\nIf you have a trace ID in a log file, you can jump directly to it. Otherwise, you can query based on attributes such as service, operation name, tags and duration. Some interesting data will be summarized for you, such as the percentage of time spent in a service, and whether or not operations failed.\n출처 - https://zipkin.io/\n즉, Zipkin은 시스템의 흐름 데이터를 수집하여 차후에 특정 시간대나 특정 요청에 대한 데이터를 확인할 수 있도록 돕는 시스템 입니다!\n이는 trace ID 등 여러 데이터를 기준으로 조회할 수 있고 소요 시간, 실패 여부 등의 정보를 확인할 수 있습니다!\n구현 방식 Applications need to be “instrumented” to report trace data to Zipkin. This usually means configuration of a tracer or instrumentation library. The most popular ways to report data to Zipkin are via HTTP or Kafka, though many other options exist, such as Apache ActiveMQ, gRPC and RabbitMQ. The data served to the UI are stored in-memory, or persistently with a supported backend such as Apache Cassandra or Elasticsearch.\nZipkin 서버 쪽으로 Log 정보들을 전송하여 쌓게 되고, 대표적으로 Http, Kafka 등을 사용하여 전송하게 된다. UI는 메모리 기반으로 Zipkin의 기본 화면을 사용하거나 다른 System을 붙여서 사용할 수 있다! 대체적으로 ELK 환경(Elastic Search, Kibana)과 연결 지어 사용하는 것 같다!\n구조 ❗ Request 결과 전송은 response 응답 후에 비동기 방식으로 쌓는다! 때문에 따로 reponse 응답에 시간 소요에는 영향을 끼치지 않는다. 본 System은 어려운 점은 없다! 따로 큰 부하 없이 효율적인 로직으로 logging 정보를 수집, 정리, 조회 API 등의 역할을 한다. 여러 언어의 프로젝트에 붙여 사용할 수 있고, 사용자 커스텀 기능도 지원한다. 때문에 프로젝트의 Logging 목적에 맞추어 여러 데이터를 활용할 수 있다.\nSpring Cloud Sleuth 개요 및 특징 Overview\nSpring Cloud Sleuth provides Spring Boot auto-configuration for distributed tracing.\nFeatures\nSleuth configures everything you need to get started. This includes where trace data (spans) are reported to, how many traces to keep (sampling), if remote fields (baggage) are sent, and which libraries are traced.\nSpecifically, Spring Cloud Sleuth…\nAdds trace and span ids to the Slf4J MDC, so you can extract all the logs from a given trace or span in a log aggregator. Instruments common ingress and egress points from Spring applications (servlet filter, rest template, scheduled actions, message channels, feign client). If spring-cloud-sleuth-zipkin is available then the app will generate and report Zipkincompatible traces via HTTP. By default it sends them to a Zipkin collector service on localhost (port 9411). Configure the location of the service using spring.zipkin.baseUrl. 출처 - https://spring.io/projects/spring-cloud-sleuth/#overview\n기능 실제로 Trace Id, span Id 등 request에 고유 식별 값(id)을 부여하는 Lib 이다. 특히나 Zipkin과 쉽게 연동이 가능한 Lib도 제공하고 있어 Spring 환경에서 해당 시스템을 붙이기 매우 쉽다!\n구현 기능의 동작은 간단하다! 기본적으로 Http Header에 b3-propagation 규격으로 값들을 주고 받는다!\nTrace Id 값은 없을 시 부여하고 갱신하지 않고, span Id는 새로운 모듈의 인입 시점마다 새로 부여한다!\n위 방식을 통해 trace Id값과 span Id 값을 추출하고 header에 담아 식별 값을 부여하고, Logging 하게 된다!\nID 부여 Flow Sleuth도 사용법은 굉장히 간단하다. 실제로 동작 방식을 보았을 때에는 특별하게 구현된 로직이나 방법은 딱히 보이지 않는다! 굉장히 간단한 방식과 정해진 규격을 통해서 깔끔하게 MSA 환경 에서의 추적 환경을 쉽게 구성해주는 것 같다!\n내 생각 SI, SM 애초에 개발이라는 영역 내에서 Monitoring 이나 Debugging은 매우 중요한 요소이다. 헌데 MSA 환경이 등장하고 여러 모듈에 걸친 복잡한 Process가 생기고, 만약 문제가 생겼을 때에 그 해결 과정은 매우 복잡했을 것 같다.. 문제를 파악하는 과정 에서도 분명히 애로사항이 크지 않았을까..? log에 프로젝트 고유의 id 값을 부여하고 logging 하는 공통 로직을 넣거나 하는 등의 방식을 사용했을 것 같다. 하지만 Spring과 Zipkin을 통하여 단순히 Lib를 더하고, 프로젝트에 맞춘 사용자 정의만 한다면 이 모든 것이 매우 쉽게 구현된다!! 이 얼마나 놀라운가.. 화려하고 어려운 로직이 아님에도 아마 많은 MSA 환경 프로젝트들이 구원 받았을 것이다!! 😂😂\nAPM을 통해서 Id 값을 통해 MSA 환경에서도 매우 쉽게 Monitoring 하다가 문득 이 값들은 도대체 어떻게 생성되고 관리되는 거지 라는 궁금증에서 시작했는데 의외로 여러 영역에 걸쳐 다양한 정보들을 배울 수 있어서 재밌었다..!! 간단하게 끝날 일인 줄 알았는데 구글링을 꽤나 오래 했던 것 같다.. 신선하고 놀라운 동작보다는 여러 Lib의 하모니를 통한 편한 환경 구축에 대해 보았다 흐흐.. 역시 Lib 짱짱..?😎😎\n출처 MSA 환경에서 분산 추적시스템 적용하기 [마이크로서비스] 분산추적 Spring Cloud Sleuth, Zipkin, ELK (10) OpenZipkin · A distributed tracing system Spring Cloud Sleuth [MSA] MSA 환경 분산 로그 트레이싱 (분산 트랜잭션\u0026amp;시스템 추적) - 개발하는 지토\n","permalink":"https://HyoseungJeon.github.io/posts/etc/msa-%ED%99%98%EA%B2%BD-traceid-logging/","summary":"💡 요즘 프로젝트를 가면 다 MSA 환경으로 개발하고 있다! 하여 APM을 통한 모니터링을 할 때 TraceId를 통해 flow를 확인하고 있는데.. 실제로 이게 어떻게 구현되는지 궁금했다..! 한번 그에 대해 내용을 알아보자~~~!😊😊 개요 MSA 환경의 Monitoring 대부분의 프로젝트는 요즘 분산 환경으로 구현되어 있다! 하여 복잡한 로직들은 N개의 프로젝트 흐름을 거쳐 실행된다! 하지만 실제로 해당 흐름을 추적하는 일은 조금 어렵다.. (Trace Id가 없었다면..!) 하여 위와 같은 애로사항을 해결하기 위한 방법이 필요했고 그 방식으로 TraceId를 부여하는 logging 방식이 등장했다!","title":"MSA 환경 TraceId Logging"},{"content":" 💡 새로운 프로젝트에 들어와 공통 모듈을 맡으며 처음으로 계정 권한에 관련한 작업을 맡게 됐다! 하여 현재 계정의 권한이 어떤 방법으로 부여되는지 소스 코드를 살펴보게 되었는데.. Spring Security를 사용하여 구현하고 있었다.. 말로만 들어보고 건드려 본 적이 없는 영역인데 이번 기회에 한번 알아보자!! 😎😎 Spring Security Spring Security란? Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.\nSpring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements 출처 - https://spring.io/projects/spring-security\n요약 하자면 Spring에 초점을 맞춘 인증 Framework 이다! 특히나 인증, 권한을 동시에 부여하는 것과 확장성을 주요 특징으로 강조하는 것 같다.\n❗ - 인증(Authentication): 해당 사용자가 본인 여부를 확인하는 절차 - 인가(Authorization): 인증된 사용자가 요청한 자원에 접근 가능 여부를 확인하는 절차 - 두 개의 차이점을 명확히 짚고 넘어가자!! 동작 방식 Spring은 기본적으로 Filter → Interceptor → AOP → Interceptor → Filter layer로 동작한다! 여기서 Spring Security는 Filter 단에서 동작하게 된다. 즉, Spring의 Servlet단에 접근하기 전에 이미 작업이 먼저 처리된다! 자세한 내용은 블로그보다 Docs를 확인하는 것이 정확하고 빠르다..!! https://docs.spring.io/spring-security/reference/servlet/architecture.html\nDiagram 자세히 보기 Spring Security에 대해 깊게 알아보려면 내용이 블로그에 정리해둘 만큼 간략하지 않다..! 😂 (장문의 글이 될 것 같아 포기했다..) 하여 내가 생각했을 때 가장 포인트가 되는 부분들만 간략하게 정리하려 한다! 나머지는 Docs가 최고다!! 번역기 만세, Spring 만세 🤷‍♂️🤷‍♂️\nConfig Setting @Configuration @EnableWebSecurity public class SecurityConfig { @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { http .csrf(Customizer.withDefaults()) .authorizeHttpRequests(authorize -\u0026gt; authorize .anyRequest().authenticated() ) .httpBasic(Customizer.withDefaults()) .formLogin(Customizer.withDefaults()); return http.build(); } } 사용 방법은 간단하다! 프로젝트의 build Tool의 Lib에 Security Framework를 넣고 Config File을 정의하면 끝이다! 세부적인 기능들은 천천히 비즈니스 규칙에 맞추어 추가하면 끝이다!\n해당 Config는 보다시피 @Bean으로 주입 되고 있다! 자세한 내용은 Doc에 나와있는데 간단히 말하면 사용자 정의 Filter를 추가하는 Proxy 단 Filter에서 해당 bean을 읽어 주입하여 Filter가 적용되게 된다!\nHttpSecurity 기본적으로 프로젝트의 보안 설정을 정의하는 객체이다! 대부분의 보안 관련한 흐름이나 페이지, 사용자 정의 Filter 설정 등 보안과 흐름 제어에 필요한 모든 설정을 여기서 한다! 사실상 Spring Security의 Main 객체인 것 같다!!\nchain 방식으로 옵션들을 정의하고 build하여 반환하는 형태로 filterChain bean에서 삽입한다!\n자세한 사용 내용은 https://kimchanjung.github.io/programming/2020/07/02/spring-security-02/ Blog를 참고하면 좋을 것 같다!\nFilter 종류 Filter의 종류는 매우 다양하다! 위와 같이 chain 방식으로 소스를 작성하여 세부 filter를 정의할 수 있다! 위 소스 기반으로 기본적인 filter 소스를 알아보자!\nCsrfFilter - csrf attack으로 부터 보호하는 filter UsernamePasswordAuthenticationFIlter - 사용자의 화면으로부터 username과 password를 받아 token을 생성 후 AuthenticationManager에게 인증을 요청하는 filter BasicAuthenticationFilter - Header의 정보를 통해 token 생성 후 인증을 요청하는 filter AuthorizationFilter - 기본적으로 마지막에 위치하는 filter로 request에 따른 승인 규칙에 따라 동작 된다. 이 외에 사용자 정의 filter나 ExceptionTranslationFilter 등 filter가 존재한다!\nAuthenticationManagerBuilder loadUserByUsername\n사실 상 인증 부분도 중요하지만 실제로 계정의 권한을 부여하는 소스가 중요하다! 우리가 사용하는 비즈니스 규칙에 따라 권한을 삽입해주는 custom 소스를 작성해야 하기 때문이다!\n규칙에 따른 계정의 권한을 조회 후 List\u0026lt;GrantedAuthority\u0026gt; authorities 형태로 Manager에 담아 둔다. 후에 Security 목적 외에 Service 단에서도 활용이 가능하다!\n내 생각 기존에 사용되던 권한 부여 방식이 계정 그룹 별 권한 정책이 추가 가능성이 있어 소스를 살펴보게 되었다! 이전엔 비즈니스에 관련된 모듈을 맡아 이런 권한 관련한 부분에 대해 동작 방식이나 자세한 소스에 대한 내용은 알지 못했었다..! 하지만 이번에 좋은 기회로 인하여 사실상 비즈니스의 토대가 되는 로그인과 인증, 인가에 대한 프로세스와 정보를 알게 되어 너무 감사했다.. 사실상 소스 자체로는 결국 또 Spring이 다 해주는 모습 이였지만, 이 구조를 위해 Spring이 꽤나 디테일한 부분에 신경을 쓰고 짜놓았구나 라는 생각이 들었다. 이번 학습을 통해 Filter에 실제 동작 방식과 전체적인 사용자 request의 흐름에 대해 조금 더 깊이 있게 이해할 수 있었다! 이전에 Intercepter 단에 사용자의 Request param 정보를 Controller layer이 가져가기 위해 작업했던 경험이 있었는데 이번엔 Filter에 대해서도 이해하게 되어 어느 정도 전체적인 흐름에 대한 이해가 더욱 되어서 좋았던 것 같다.\n출처 Architecture :: Spring Security Spring Security :: Spring Security [Spring Security] 공식 문서로 Spring Security 구조 파악하기 Spring Security 적용 [Spring Security] 스프링시큐리티 설정값들의 역할과 설정방법(2)\n","permalink":"https://HyoseungJeon.github.io/posts/spring/springsecurity/","summary":"💡 새로운 프로젝트에 들어와 공통 모듈을 맡으며 처음으로 계정 권한에 관련한 작업을 맡게 됐다! 하여 현재 계정의 권한이 어떤 방법으로 부여되는지 소스 코드를 살펴보게 되었는데.. Spring Security를 사용하여 구현하고 있었다.. 말로만 들어보고 건드려 본 적이 없는 영역인데 이번 기회에 한번 알아보자!! 😎😎 Spring Security Spring Security란? Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.\nSpring Security is a framework that focuses on providing both authentication and authorization to Java applications.","title":"Spring Security"},{"content":" 🔥 이전에 공통 개발 건이 생겨 ZTree 라는 Lib 을 이용해 개발을 한 적이 있다! 하여 해당 tree 구조의 Data를 뽑기 위해 사용된 API를 확인하던 중 위 문법을 처음 발견했다..! Query에 이런 문법이 존재 하는지도 처음 알았는데 그 사용법과 동작 방식 또한 RDB에서 접하지 못한 방식이라.. 매우 신기했다..! 그 내용이 뭔지 같이 알아보자~~😁✌ With Queries 정의 WITH provides a way to write auxiliary statements for use in a larger query. These statements, which are often referred to as Common Table Expressions or CTEs, can be thought of as defining temporary tables that exist just for one query. Each auxiliary statement in a WITH clause can be a SELECT, INSERT, UPDATE, or DELETE; and the WITH clause itself is attached to a primary statement that can be a SELECT, INSERT, UPDATE, DELETE, or MERGE. 출처 - https://www.postgresql.org/docs/current/queries-with.html\n요약하면 한개의 임시테이블을 사용하여 조회된 데이터들을 MERGE, 새로운 데이터를 생성, 반환하는 postgreSQL의 하나의 Query이다!\nRecursive Queries The optional RECURSIVE modifier changes WITH from a mere syntactic convenience into a feature that accomplishes things not otherwise possible in standard SQL. Using RECURSIVE, a WITH query can refer to its own output.\nWith 함께 사용되는 Recursive query는 With 구문의 출력을 재귀적으로 다시 사용할 수 있도록 해주는 문법이다!\n조금 더 깊이! 구문의 동작 원리는 단순하다. 초기의 기준 테이블로부터 재귀 조건에 맞는 테이블을 조회하고, 그 테이블을 임시 테이블에 add, 후에 조회 했던 이전 테이블을 기준으로 다시 재귀 조회의 반복이다.\n하여 해당 Query는 재귀 조건과 기준 테이블의 여부가 중요하다! 우리는 재귀라는 단어와 함께 항상 딸려오는 문제를 안다. 바로 무한루프이다! 이 문법 또한 재귀방식 이기 때문에 데이터에 Cycle 형태의 Data가 존재한다면 무한Loop를 돌게 된다..😂 하여 이를 방지하기 위한 여러 방법이 있지만 간단하게는 공통 field로 제공되는 is_cycle와 Path Field를 활용하여 방지할 수 있다! 또한 트리 구조를 표현하기 위한 Query인 만큼, level과 Path를 노출할 수도 있다!\n예제 WITH RECURSIVE search_tree(id, link, data) AS ( SELECT t.id, t.link, t.data FROM tree t UNION ALL SELECT t.id, t.link, t.data FROM tree t, search_tree st WHERE t.id = st.link ) SELECT * FROM search_tree; WITH RECURSIVE search_tree(id, link, data, path) AS ( SELECT t.id, t.link, t.data, ARRAY[t.id] FROM tree t UNION ALL SELECT t.id, t.link, t.data, path || t.id FROM tree t, search_tree st WHERE t.id = st.link ) SELECT * FROM search_tree ORDER BY path; WITH RECURSIVE search_tree(id, link, data, depth) AS ( SELECT t.id, t.link, t.data, 0 FROM tree t UNION ALL SELECT t.id, t.link, t.data, depth + 1 FROM tree t, search_tree st WHERE t.id = st.link ) SELECT * FROM search_tree ORDER BY depth; 기본 사용법은 간단하다! 기본 문법 구문 안에 기준 테이블, 혹은 조회 시작점의 select을을 작성 하고 재귀로 호출할 select 문을 작성하면 새로운 임시 테이블이 만들어 진다! 후에 해당 data를 마음대로 활용하면 된다. 추가적으로 Path나 Depth도 활용이 가능하다!\nWITH RECURSIVE search_graph(id, link, data, depth) AS ( SELECT g.id, g.link, g.data, 1 FROM graph g UNION ALL SELECT g.id, g.link, g.data, sg.depth + 1 FROM graph g, search_graph sg WHERE g.id = sg.link )CYCLE id SET is_cycle USING path SELECT * FROM search_graph; 또한 위에 말했던 cycle 문제도 간단하게 CYCLE id SET is_cycle USING path 구문을 추가하여 해결이 가능하다!\n이외의 자세한 예제나 내용은 출처에 작성한 공식 Docs을 참고하자!!\n내 소스 내 Case는 간단하다! Menu의 권한 정보들을 Tree형태의 Data(실제론 Row 형태)로 조회해 화면에 노출하면 끝..이다! 하여 위 Query를 활용하여 작성이 되어있던 Source를 활용했다! 작업 내용은 단순하게 Node 테이블에 권한 테이블을 JOIN하여 권한 여부를 함께 조회했다! (사실 query 파악에 오래 걸렸지 작업한 내용은 적다..😊)\n내 생각 지금 까지 맡았던 업무의 특징인지.. 내가 Query에 관심이 없는지.. 혹은 공부를 제대로 안했던건지..!! 재귀 Query를 처음 보았다.. 😜 확실히 단순한 Query만 보다가 이런 것들을 보니 호오오..!! 하고 놀라긴 했다!! 단순히 Java에서 할 생각을 했는데 애초에 조회 단에서 부터 Depth와 Sorting, 계층 구조로 까지 Data를 뽑으니.. 확실히 좋아 보이긴 했다! 하지만.. 단점은 쿼리의 조회 성능이 매우 떨어졌다 ㅜ… 대략 데이터는 6,000 개 정도 있던 것 같은데 재귀 방식 때문인지 5초 정도의 조회 시간이 걸렸다..! 이에 더해 ZTree Rendering Time 까지 합하니 어마어마했다.. 다행히 해당 페이지가 Back Office 단이라 크게 문제가 되진 않았지만.. 아마도 Front Office 쪽에서는 확실히 성능 개선이 필요해 보였다! PostgreSQL에서는 위와 같은 Query를 제공하는 것을 확인했으니.. 앞으로 재귀 기능을 이용한 기능이 필요할 때에 확실히 고려할 수 있는 내 식견이 넓어졌으니 너무너무 만족스럽다!!\n출처\n7.8. WITH Queries (Common Table Expressions)\nMySQL :: MySQL 8.0 Reference Manual :: 13.2.20 WITH (Common Table Expressions)\n계층형 쿼리에 쓰일 법한 with recursive 절에 대해 알아봅시다.\nWITH Queries (Common Table Expressions)\n","permalink":"https://HyoseungJeon.github.io/posts/sql/withrecursive/","summary":"🔥 이전에 공통 개발 건이 생겨 ZTree 라는 Lib 을 이용해 개발을 한 적이 있다! 하여 해당 tree 구조의 Data를 뽑기 위해 사용된 API를 확인하던 중 위 문법을 처음 발견했다..! Query에 이런 문법이 존재 하는지도 처음 알았는데 그 사용법과 동작 방식 또한 RDB에서 접하지 못한 방식이라.. 매우 신기했다..! 그 내용이 뭔지 같이 알아보자~~😁✌ With Queries 정의 WITH provides a way to write auxiliary statements for use in a larger query.","title":"With Recursive"},{"content":" 💡 공통 개발을 하며 개선 건이 생겼다! 기존에 계정의 권한을 관리할 때에 Grid에 뿌려진 Data를 찾아 해당 사용여부를 Y로 업데이트 해야 하는 번거로움이 있었다..! 아마 초기 설계했을 때에는 관리되는 데이터의 수가 적어 그런 것 같은데.. 관리 대상의 수가 6,000건 정도로 늘어나니 제대로 권한 관리하기가 어려웠다!! 하여 해당 자료구조를 Tree 형태로 마이그레이션 하게 됐다! 기존에 사용되던 ZTree Lib를 활용하여 개발하기로 의사결정이 되었다! 한번 해보자.. Z Tree 정의 zTree is an advanced jQuery \u0026rsquo;tree plug-in\u0026rsquo;. The performance is excellent, it is easy to configurw (with a full set of options), and has many advanced features (that usually only come with paid software). zTree is open source and uses the MIT license. 출처 - https://www.treejs.cn/v3/main.php#_zTreeInfo\nzTree는 jQuery spec을 이용한 tree 자료구조를 노출, 관리하기 위한 plug-in 이다! 유료버전도 있다고 하는데.. 우선 현재 프로젝트에서는 유료버전 라이센스를 사용하지는 않고 오픈 소스 기준으로 작업이 되있는 것 같다!\n세부 기능 다양한 브라우저와 호환 가능 (IE, FireFox, Chrome, Opera, Safari) JSON Data 지원 checkBox, radio Btn 기능 지원 이 외에도 다양한 Custom 기능이나 지연 로딩 등 성능적인 부분에서도 다양한 기능들이 지원된다!\n예제 DEMO \u0026lt;HEAD\u0026gt; \u0026lt;TITLE\u0026gt; ZTREE DEMO - Simple Data\u0026lt;/TITLE\u0026gt; \u0026lt;meta http-equiv=\u0026#34;content-type\u0026#34; content=\u0026#34;text/html; charset=UTF-8\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;../../../css/demo.css\u0026#34; type=\u0026#34;text/css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;../../../css/zTreeStyle/zTreeStyle.css\u0026#34; type=\u0026#34;text/css\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;../../../js/jquery-1.4.4.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;../../../js/jquery.ztree.core-3.5.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;SCRIPT type=\u0026#34;text/javascript\u0026#34;\u0026gt; \u0026lt;!-- var setting = { data: { simpleData: { enable: true } } }; var zNodes =[ { id:1, pId:0, name:\u0026#34;pNode 1\u0026#34;, open:true}, { id:11, pId:1, name:\u0026#34;pNode 11\u0026#34;}, { id:111, pId:11, name:\u0026#34;leaf node 111\u0026#34;}, { id:112, pId:11, name:\u0026#34;leaf node 112\u0026#34;}, { id:113, pId:11, name:\u0026#34;leaf node 113\u0026#34;}, { id:114, pId:11, name:\u0026#34;leaf node 114\u0026#34;}, { id:12, pId:1, name:\u0026#34;pNode 12\u0026#34;}, { id:121, pId:12, name:\u0026#34;leaf node 121\u0026#34;}, { id:122, pId:12, name:\u0026#34;leaf node 122\u0026#34;}, { id:123, pId:12, name:\u0026#34;leaf node 123\u0026#34;}, { id:124, pId:12, name:\u0026#34;leaf node 124\u0026#34;}, { id:13, pId:1, name:\u0026#34;pNode 13 - no child\u0026#34;, isParent:true}, { id:2, pId:0, name:\u0026#34;pNode 2\u0026#34;}, { id:21, pId:2, name:\u0026#34;pNode 21\u0026#34;, open:true}, { id:211, pId:21, name:\u0026#34;leaf node 211\u0026#34;}, { id:212, pId:21, name:\u0026#34;leaf node 212\u0026#34;}, { id:213, pId:21, name:\u0026#34;leaf node 213\u0026#34;}, { id:214, pId:21, name:\u0026#34;leaf node 214\u0026#34;} ]; $(document).ready(function(){ $.fn.zTree.init($(\u0026#34;#treeDemo\u0026#34;), setting, zNodes); }); //--\u0026gt; \u0026lt;/SCRIPT\u0026gt; \u0026lt;/HEAD\u0026gt; \u0026lt;BODY\u0026gt; \u0026lt;h1\u0026gt;Simple JSON Data\u0026lt;/h1\u0026gt; \u0026lt;h6\u0026gt;[ File Path: core/simpleData.html ]\u0026lt;/h6\u0026gt; \u0026lt;div class=\u0026#34;content_wrap\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;zTreeDemoBackground left\u0026#34;\u0026gt; \u0026lt;ul id=\u0026#34;treeDemo\u0026#34; class=\u0026#34;ztree\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 사용법은 간단하다. JQuery, z-tree Lib를 import 해주고 ztree field에 mapping에 init 후 여러가지 custom 방식들을 활용하여 나만의 zTree를 구성하면 된다!\n자세한 기능들은 https://www.treejs.cn/v3/demo.php#_101 Demo Guide site를 참고하면 된다. 대부분 tree 구조에서 활용되는 case들이 많이 있다! 따로 유료 버전을 사용하지 않아도 충분히 제 기능을 다 한다.\n내 소스 data: { simpleData: { enable: true, idKey: \u0026#39;id\u0026#39;, pIdKey: \u0026#39;pId\u0026#39;, rootPId: null, lvl: \u0026#39;lvl\u0026#39;, caloUrl: null, menuId: null }, }, ===== 생략 ===== let iconSkin = \u0026#34;\u0026#34; if (testCd === \u0026#39;20\u0026#39;) { iconSkin = \u0026#39;ico_docu \u0026#39; } ======== 생략 ====== if(key.keyCode === 13) { const treeObj = $.fn.zTree.getZTreeObj(\u0026#34;tree\u0026#34;); const text = $(\u0026#39;#snb_treebox-search-input-field\u0026#39;).val() if (!treeObj) { alert(\u0026#34;업무그룹코드를 선택해주세요.\u0026#34;) return } if(!text){ alert(\u0026#34;검색어를 입력해주세요.\u0026#34;) return } /* 1. 원본 검색어가 없거나, 새로운 검색어일 경우 */ if (!orgSchText || orgSchText !== text) { orgSchText = text reSchFlag = false; } else { reSchFlag = true; } /* 2. Node List 검색 */ if (reSchFlag) { schMenuIndex = schMenuIndex \u0026lt; schMenuList.length - 1 ? schMenuIndex + 1 : 0; } else { schMenuIndex = 0; /* 2.1 List setting */ schMenuList = treeObj.getNodesByFilter(node =\u0026gt; { return node.name.indexOf(text) \u0026gt; -1 }); } /* 3. 현재 index Node 노출 */ treeObj.selectNode(schMenuList[schMenuIndex]); } ====== 생략 ===== checked: useYn === \u0026#34;Y\u0026#34;, checkedOld: useYn === \u0026#34;Y\u0026#34;, 사실 특별히 추가한 코드는 없다! 그래도 한번 짚어갈 부분을 확인해보자!\n기본적으로 Node 객체를 활용하여 tree를 구성하게 된다! 하여 node에 내부 Data를 Custom하고 해당 속성 값들을 활용하여 목적에 맞게 Tree를 구성할 수 있다는 것이 큰 장점이다! 보일 지 모르겠지만 iconSkin 값을 'ico_docu ' 띄어쓰기를 포함해 넣었다! 왜냐하면 기본적인 zTree 동작으로 leaf Node들은 iconSkin 값을 그대로 class에 선언하여 사용하지만 그 외 Node들은 해당 값을 prefix 방식으로 적용하여 open, close suffix를 붙여 class를 적용한다! 하여 만약 사용자가 open, close 형태의 icon이 아닌 정적인 형태의 icon을 활용 할 경우에는 애매했다! 하여 class가 선언되는 방식을 이용, space 공간을 추가하여 class를 분리하고 의도한 skin이 나오도록 설정하였다! Tree에 검색 기능을 추가 했는데, 여러 건이 검색 될 경우 List에 검색 결과 Node들을 담고 차례대로 순환 구조로 select 되게 구현하였다! zTree는 단순하게 Lib 하나를 더 loading 것 만으로도 CheckBox Custom이 가능했다! check 값들을 계산하거나, level 단의 checkBox 동작 같은 경우에도 간단하게 구현되었다. 너무 편하네.. 내 생각 오픈 소스 라이브러리 임에도 불구하고 굉장히 탄탄하게 구현이 되있는 것 같았다! Grid 관련한 라이브러리는 유료, 무료 모두 사용해보았지만, 유료 임에도 불친절하고 기본적인 기능도 구현되있지 않은 것들도 있었고, 무료임에도 세세한 기능과 유연한 Custom 기능까지 있는 것이 있었다! Tree 구조 관련한 Lib는 이번에 처음 사용해보았는데 첫 경험은 아주 좋았던 것 같다!! 무언가 이런 기능은 있겠지..? 하고 Docs를 살펴보면 대부분의 기능이 있었다!! 뭐 당연할 수도 있지만.. 불친절한 Lib를 사용했던 경험이 많다 보니 더 그렇게 느껴진 것 같기도 하다! 그래도 해당 lib가 굉장히 친절하고 Docs도 잘 나와 있다고 느꼈다!\n오히려 이번엔 해당 tree를 뿌리기 위해 Query를 개선 했던 것이 더 기억에 남는다..! 나중에 Posting을 할 수도 있겠지만, Query vs Java에 문제는 항상 나를 고민하게 만드는 것 같다.. 기존 menu 권한을 조회하는 Query는 시간이 5초 가량 걸리고 있었다.. 하지만 여러 Table이 엮여있고, 또 기존에 사용되던 것이 있어 함부로 개선하기도 조금 무서웠다.. 하여 조건 만 추가하여 기존 소스를 살렸다! 나중에 zTree에서 Lazy loading 기능을 활용하여.. 화면 속도를 더 개선하는 방향으로 조금 작업 해봐야겠다.. 생각보다 일이 잘 풀려서 놀랐던 ZTree에게 감사를..!!😁😁👍\n출처\nHome [zTree \u0026ndash; jQuery tree plug-ins.]\n","permalink":"https://HyoseungJeon.github.io/posts/jquery/ztree/","summary":"💡 공통 개발을 하며 개선 건이 생겼다! 기존에 계정의 권한을 관리할 때에 Grid에 뿌려진 Data를 찾아 해당 사용여부를 Y로 업데이트 해야 하는 번거로움이 있었다..! 아마 초기 설계했을 때에는 관리되는 데이터의 수가 적어 그런 것 같은데.. 관리 대상의 수가 6,000건 정도로 늘어나니 제대로 권한 관리하기가 어려웠다!! 하여 해당 자료구조를 Tree 형태로 마이그레이션 하게 됐다! 기존에 사용되던 ZTree Lib를 활용하여 개발하기로 의사결정이 되었다! 한번 해보자.. Z Tree 정의 zTree is an advanced jQuery \u0026rsquo;tree plug-in\u0026rsquo;.","title":"ZTree"},{"content":" Clean Architecture 소프트웨어 구조와 설계의 원칙 로버트 C. 마틴 지음 | 송준이 옮김\n서론 우아한 스터디에서 해당 책을 주제로 스터디 모임이 열렸다! 공개 모집이라 여러가지 좋은 내용의 스터디 그룹들이 있었지만 구조 설계에 관심이 많아 해당 스터디에 지원했었다..\n하지만 탈락.. 😂😂 그래도 책에 대해 찾아보니 좋은 내용의 도서인 것 같아 한번 읽어보면 좋겠다 라는 생각이 들어 회사를 통해 구매했다!!\n책의 전반적인 내용은 소프트웨어 아키텍쳐의 중요성과 그 설계 방법, 노하우 등 다년간의 경험을 통한 지식들을 전달하는 내용이다! 좀 더 자세히 보자면 설계 원칙 부터 시작해서 여러 디자인 패턴들과 또 추구해야하는 가치등에 대해 설명하고 있다! 추가적으로 공학적인 내용 이외에도 실제 비지니스 케이스를 통한 구조의 설명, 개발자로서 어떠한 태도를 취하고 작업을 해야하는지에 대한 내용들도 포함하고 있었다! 단순히 공학자로서의 고리타분한 이야기들만 반복되는 것이 아닌 개발자를 떠나 하나의 직업적인 가치로서 다시 한번 개발자에 대한 직무를 쳐다볼 수 있는 책이였다.\n본문 개발자는 어떤 직업일까? 전문직? 사무직? 단순히 코드를 쓰는 작업자? 사람마다 개발자라는 직업을 그리는 이미지는 다를 것이다. 나는 개발자를 공학자라고 생각한다. 공학의 영역은 매우 넓지만 난 특히나 개발을 건축학에 빗대어 자주 생각한다. 우리는 누구나 집을 지을 수 있다! 바닥을 깔고 벽을 올리고 지붕을 덮는다. 문을 만들고 창문도 하나 내어준다. 헌데 그게 올바른 집인가? 살기 좋은 집인가? 사람마다 만족의 기준은 다르겠지만 최소한 따뜻하거나 시원하고, 관리하기 용이한 그런 집을 선호한다. 그리고 무엇보다 안전이 또 중요하겠다. 근데 어떤 집은 기능이 떨어지기도 하고, 또 어떤 집은 기능은 다 좋은데 무언가 변화를 주어야 할 때 마다 필요 이상의 힘을 써야 하는 집이 있기도 하다. 또 다른 집은 정말 이쁜데 바람이 불거나 지진이 났을 때 곧 무너질 것 같은 집도 있다. 대부분 위와 같은 문제를 일으키는 이유는 뭘까? 난 이 모든 문제의 원인은 설계, 분석에 있다고 본다! 거주의 목적, 위치, 환경, 고려해야 할 요구사항, 예상되는 이슈 등등 설계자는 다양한 요건에 맞춰 건물을 설계할 것이다. 예를 들어 한국의 전통적인 가옥은 대부분 나무로 짓기 때문에 습기에 취약하다. 하여 항상 건물의 토대가 되는 기둥은 바닥층에 두터운 돌을 깔고 그 위에 기둥을 올린다. 바닥으로부터 올라오는 습기를 방지하여 더욱 집을 오래 사용할 수 있도록 한 것이다. 이는 환경에 대한 설계의 고려일 것이다. 또한 현대의 주택을 예로 들면 요즘은 가전제품이나 네트워크 인프라가 집에서도 중요한 요소가 되었다. 하여 방에서나 거실의 콘센트 위치나 인터넷 선 등과 같은 배치가 중요해졌다! 만약 따로 네트워크 배선이 구성되어 있지 않은 집은 공유기를 통하여 인터넷 선을 설치하여 몰딩을 덮거나 하는 등 귀찮은 일이 생긴다. 하지만 따로 해당 환경을 구성해놓은 집은 그냥 해당 포트로 간편하게 인터넷을 연결하면 끝이다! 이처럼 건축에서는 여러가지 환경을 고려하여 건물이나 방 구조를 설계해야 한다. 이는 개발도 똑같다!\n하나의 사이트를 만들어도 그 내부 구조는 다 제각각이다. 어떤 사이트는 기획이나 사용자의 요구사항에 쉽고 빠르게 대응할 수 있는 반면, 다른 사이트는 간단한 요구사항도 매우 큰 job으로 잡히는 경우가 있다. 아까 인터넷 배선 문제와 비슷하지 않나? 초기 설계에 요구사항이 변경되거나 추가될 가능성이 있는 영역을 어떻게 설계하였나에 대한 문제이다. 만약 해당 요구사항에 대하여 변동 가능성이나 혹은 고객에게 해당 영역을 확인, 검수 했다면 그리고 변동 가능성이 높게 잡혔다면 설계를 어떻게 해야 했을까? 당연히 그 환경에 맞추어 기능의 변경, 확장이 용이하게 작업을 했어야 한다. 작업을 빨리 쳐내야 하거나 시간이 없다고 하더라도, 해당 작업은 위 기능을 충족하게 만들어 져야 한다. 하지만!! 현실에서는 그러한 소스들을 별로 찾을 수가 없다. 우리는 Spring과 java언어에 의해서 해당 기능을 쉽게 구현할 수 있음에도 불구하고 내가 본 케이스들에서는 별로 지켜진 적이 없다.. 의존성 역전 등 많은 시행착오들에 의해 정의된 개발만의 공학서가 있는데도 불구하고 아직 필드에서는 효과가 발휘되지 못하고 있는 것이다. 물론 내가 겪은 작은 케이스들의 표본에서의 생각이지만 아마 한국에서는 대부분의 소스가 이럴 것 같다!!\n위와 같은 문제점을 짚고 얘기하는 이유는 다른게 없다. 내가 읽은 이 책에서는 내가 말하고자 하는 이 이야기들을 좀 더 전문적이고 학술적으로 잘 풀어놓았다! 또한 그 뿐만 아니라 실제 케이스에 비교하며 해당 내용들을 더욱 와닿게 설명해 주었다. 그리고 그 내용들에는 실제로 어떠한 것들이 있고 어떤 규칙들이 있는지 자세하게 나와있었다.\n특히 내가 가장 와닿았던 내용은 사용자에게 근접한 영역은 가장 Domain과 멀게 설계되어야 하고 domain이 가장 중심부에 있어야 한다는 것이다. 사용자에게 제공되는 화면은 언제나 변경 가능하고 쉽게 변경이 가능해야 한다. 왜냐면 가장 요구사항이나 변경사항이 많은 영역이기 때문이다. 하지만 domain과 깊게 연결되어 있다면 매번 그 영향도 파악에 많은 비용이 소모될 것이고, 또 예기치 못한 버그까지 발생할 수 있다. 실제로 두 관계나 너무 깊었던 프로젝트에서 개발을 했을 때 실제로 요구사항은 간단했지만 예상하지 못했던 이슈를 겪었던 케이스가 있었다.. 난 그래서 도메인은 도메인의 역할만 수행하면 되고, 화면은 화면의 역할만 수행하면 되는 문제일 텐데 왜 항상 이런 설계로 인해서 비용을 더 높일까? 라는 생각을 했었다. 하지만 그 문제에 있어서 이론적으로 확실한 필요성을 제시한 이 책이 너무 좋았다. 난 철저하게 업무는 도메인에 묶어야 한다고 생각한다. 이 얘기를 하면 SQL Query 얘기를 안할 수 없는데, 지금은 Spring 위에서 작업을 해도 모든 업무 로직을 쿼리에 녹인 경우가 더러 있었다. 시간 복잡도나 그런 요소들은 우선 뒤로 두고 설계 관점에서 본다면 내 생각엔 너무 아득히 잘못된 영역이라고 생각했다. 패러다임의 변화일 수도 있지만 나는 쿼리는 단순히 테이블에 넣고, 빼고, 읽는 역할만 해야 한다고 생각한다. 그리고 그 이유는 위의 내용으로 설명된다. DB의 마이그레이션이나 혹은 RDB 환경이 아닌 DB를 프로젝트에 붙여야 될 수도 있고, 또 쓸데없이 한 테이블에 수많은 Update, insert 쿼리가 만들어지게 된다. 나는 이러한 점들이 잘 이해되지 않았다. 우리는 Spring의 Service나 Entity 영역을 통해서 DB 환경에 구애받지 않는 설계로 할 수 있는데 쿼리에 묶어 버리면 개발자는 해당 비지니스 로직을 쿼리로 확인해야 한다. 물론 서비스에 깔끔하게 정리하고 쿼리에서는 단순히 update만 하는 경우도 있었다! 근데 만약 service 반, 쿼리 반 으로 설계된 업무면 더욱 골치가 아파진다. 변경사항들을 반영하며 결국 여러 갈래로 작업이 수행되고 업무를 수행하는 개발자에 따라 누구는 service에, 누구는 쿼리에 내용을 반영한다. 결국 후엔 유지보수에 많은 비용이 드는 업무로 진화하게 되고 매번 사이드 이펙트를 고려해야 하는 소스로 변화한다. 난 현재의 개발 페러다임의 변화가 너무 좋다. 왜냐하면 이러한 문제들을 피해가기 위한 매우 좋은 방법이기 때문이다. 각 모듈, 각 서비스 간의 경계를 확실히 세우고, 그 역할들만 수행하게 만들고 Domain을 그 자체로 보관하려고 한다면 우리는 많은 문제들을 피해갈 수 있다. 물론 그렇게 하는 작업이 어렵긴 하지만 유지보수를 본다면 난 작업 자체가 그렇게 하는 것이 맞다고 본다.\n그리고 하나의 서버의 내용에서 확대하여 한 프로젝트의 개념으로도 접근할 수 있다. 요즘은 MSA 환경으로 대부분 되어있다. 그럼 더어어어어 더욱 이 클린 아키텍쳐가 중요해진다!! 모듈간의 간섭, 영향도에 대한 문제에 있어서도 우리는 명확하게 업무를 처리할 수 있게 된다.. 결국 계층간의 경계를 확실히 하는 일이 모듈간의 경계를 짓는 일과 똑같다고 느꼈기 때문이다. 기본적으로 우리는 그 경계를 공고히 할수록 더 큰 문제도 쉽게 해결할 수 있는 방향으로 간다. 경계를 확실히 한다? 라는 뜻이 무엇일까. 난 그 행위에 대해 정확하게는 각 모듈이 맡는 업무에 대해 정확히 정의하고, 애매하게 정의되는 업무를 만들지 않는다는 뜻이다. 그리고 애매한 여러개의 업무가 생긴다면 해당 업무를 맡는 모듈이 새로 생성되어야 한다고 판단한다. 애초에 애매한 업무는 없을 것이다. 그저 제대로 정의가 되지 않았을 것이다.. 이는 초짜 개발자의 낙관적인 판단일 수도 있지만 원래 생각은 이상에서 시작되어야 되지 않나..? 모듈이 무분별하게 추가되는 것은 당연히 피해야 하는 일이지만 업무가 정확히 정의 된 상황이라면 무분별에게 나오진 않을 것이다. 그리고 그 무분별하게 생성되는 모듈의 숫자를 줄이기 위해 우리는 업무를 정확하게 정의하는 것에 더욱 힘을 쏟을 것이다.\n경계를 명확히 한다면 또 따라오는 엄청난 장점이 있다. 바로 테스트가 용이해진다는 것이다. 모듈이던 서비스건 무분별에게 의존성이 엮여있다면 테스트는 점점 어려워진다. 케이스도 기하급수적으로 늘어나고, 데이터를 세팅하는 것 부터 이미 복잡해진다. 결국 제대로된 테스트를 하지 못하게 되고 배포후에 운영에서 다양한 케이스를 겪으며 찾아 되는 버그가 많았다. 물론 테스트를 통해 모든 예외 케이스를 잡아내어 미리 처리할 순 없다. 매우 이상적인 일이다. 헌데 그런 케이스들을 제외하고 경계가 확실한 상황에서 테스트 케이스를 잘 분리하여 간편하게 테스트를 수행 했다면 아마 10개의 이슈 개수가 1/2 로 줄지 않을까?\n책에서는 DB, 웹, 프레임워크를 세부사항이라고 하였다. 즉, 위 세가지는 도메인에서 가장 멀게 설계되어야 하는 것들이라는 말이다. 이 말은 결국 내가 위해서 서술했던 내용들을 마지막에 정리하여 설명해준다고 생각한다. 이 책의 목차가 왜 마지막 쯔음에 이러한 내용을 설명했는지 책의 흐름을 따라왔다면 잘 느꼈을 거라고 생각한다. 우리는 이 영역들을 분리했고 또 그 위치가 어디인지 정의하는 과정에 왔다. 근데 여기서 프레임워크가 껴있다는 것은 조금 의외일 수도 있다. 현재 우리는 Vue, Spring 등 다양한 프레임워크로 프로젝트를 진행하고 있다. 하지만 때때론 해당 프레임 워크에 엮이지 않아도 해결 가능한 문제들을 해당 프레임워크로 해결하려고 한다. 책에서 말했던 내용 중에 와닿았던 부분은 ‘프레임 워크는 우리의 도메인을 알지 못한다’ 였다. 맞다 프레임 워크는 다수의 사용자에게 제공되는 도구이지 우리에게 모든 것이 다 맞는 도구는 아니다. 개인화된 도구가 아니라는 말이다. 하여 때때로는 우리의 방식에 맞지 않는 도구는 사용하지 않아도 된다. 하지만 불필요하게, 지나치게 프레임워크에 의존하는 경우가 있었다. 물론 대부분의 프로젝트들이 공통적으로 마주하는 문제들은 프레임워크가 매우 쉽게 해결해주고 있다. 그래서 우리가 매우 의지하게 되는 것도 당연하다. 하지만 이 책에서는 불필요한 영역까지도 모두 프레임워크에 의존해서 해당 프레임워크가 아니면 개발 자체가 되지 않을 수준으로 가고 있는 현상에 대해 지적했다고 생각한다. 결국 이 키워드가 던지는 말은 한번 더 생각해 보라는 뜻 같았다. 지금 너가 사용하는 그 어노테이션, 프레임 워크가 진짜 필요해? 라는 질문을 스스로 갖게 만들어주었다.\n이 책의 주제에서 내가 가장 주의깊게 본 부분은 위와 같은 행위들을 하는 이유는 소프트웨어를 부드럽게 만들기 위해서 라는 것이다. 난 부드러운 소프트웨어 라는 말이 너무 좋았다. 내가 추구하는 소프트웨어의 형태를 가장 간단하고 또 확실하게 설명해주는 문장 같다. 우리는 딱딱한 언어로 일을 하지만 그 누구보다 부드러워야 한다고 생각한다. 우리는 공학자다. 결국 사용자들에게 더욱 좋은 환경으로 큰 행위를 쉽게 하게 만들어주는 사람이다. 그 말인 즉슨, 사용자들의 요구사항에 기민하게 대처하는 사람이 공학자로서의 가치를 지키는 사람이라고 생각한다. 우리는 소프트웨어를 부드럽게 설계해야지만 여러가지 환경의 변화, 요구의 변화 등에 대해 빠르게 대처할 수 있다. 책에서는 결국 우리가 부드럽게 소프트웨어를 설계할 수 있도록 경험에 의해서 만들어진 여러가지 이론들을 설명해준다. 우리는 책을 읽으며 계속 염두에 두어야 할 사항은 부드러운 소프트웨어이다. 내 생각이지만, 복잡하고 이론적인 내용들을 다 외우고 모두 적용하고 이런 식으로 책을 이해하라고 만든 책이 아닌 것 같다. 왜? 부드러운 소프트웨어를 만들어야 하냐가 오히려 더 초점인 책이라고 느꼈다. 그리고 그 방법을 서술해 놓은 것 뿐이고, 나에겐 구조의 중요성과 해야만 하는 이유에 대해 그 당위성과 이유를 결론지으려는 책이였다.\n결론 처음에 책의 내용을 보았을 때에 생각보다 딱딱해보이고, 또 외울 것이 방대하게 많구나.. 라는 느낌이 들었다. 자격증을 딸 때나 학교에서 시험을 위해 외우던 그런 지식들이 또 장대하게 나열되어 있는 것을 보고 솔직히 조금 지쳤다. 더이상 그렇게 외우고 집어넣고 하고 싶지 않았다. 하지만 이 책을 읽으며 원래 그 이론들이 말해주려던 어떠한 가치에 대해서 확실하게 깨달았다. 결국 그 이론들이 말해주려던 것은 ‘소프트웨어는 부드러워야 해’ 라는 것이였다. 책이란 결국 사람들이 각자 내용을 읽고 다른 생각을 하기 마련일 것이다. 하지만 난 이 책을 읽고서 위의 가치의 중요성을 크게 깨닫게 됐다. 그리고 내가 항상 고구마 먹은 듯 막혀있던 생각의 길을 뻥 뚫어주었다. 내가 걸으려고 하는 길의 안개를 확 걷어주었다. 그 가치에 대해 내가 따라가는 것이 맞나? 라는 의심이 실제 필드에서 뛸 때마다 느꼈다. 하지만 그 길이 맞아 라는 확신을 나에게 주었다. 내 전공은 컴퓨터 과학과 이다. 그리고 공학과에 속해있었다. 하지만 실제 업무에서는 공학자로 일하고 있었을까? 난 항상 공학자로 있으려고 했지만 현실은 그렇게 돕지 않았다. 오히려 내가 이상한가 라는 질문을 되묻게 되었다. 하지만 이 책을 읽고 나서는 자신감을 얻었다. 나와 같은 생각을 하는 사람들이 있고 그리고 그 가치가 추구할 만 것이다 라는 답을 들은 것 만으로도 매우 큰 감동을 받았다. 나에겐 이론 저서가 아니였다.\n","permalink":"https://HyoseungJeon.github.io/posts/%EB%8F%85%ED%9B%84%EA%B0%90/cleanarchitecture/","summary":"Clean Architecture 소프트웨어 구조와 설계의 원칙 로버트 C. 마틴 지음 | 송준이 옮김\n서론 우아한 스터디에서 해당 책을 주제로 스터디 모임이 열렸다! 공개 모집이라 여러가지 좋은 내용의 스터디 그룹들이 있었지만 구조 설계에 관심이 많아 해당 스터디에 지원했었다..\n하지만 탈락.. 😂😂 그래도 책에 대해 찾아보니 좋은 내용의 도서인 것 같아 한번 읽어보면 좋겠다 라는 생각이 들어 회사를 통해 구매했다!!\n책의 전반적인 내용은 소프트웨어 아키텍쳐의 중요성과 그 설계 방법, 노하우 등 다년간의 경험을 통한 지식들을 전달하는 내용이다!","title":"Clean Architecture"},{"content":" 문제 Intellij 내에서 간단한 문구 수정 때문에 properties file을 수정했는데 갑자기 file 전체에 변경사항이 잡혔다! 내용을 확인해보니 utf-8 Code 의 제일 앞 알파벳이 다 대문자로 upper 된 것 이였다..;\n원인 사실 크게 문제가 될 것 같지는 않지만 코드 리뷰 페이지에서 file 전체에 변경사항이 잡혀 edit line이 쓸데없이 많이 counting 되었다. 또한 호오오오옥~~ 시나 모르는 bug가 발생할 가능성이 무서워.. 수정을 해야할 것 같았다!\n문제의 원인은 project를 처음에 import 할 때에 eclipse type으로 열면 project option이 auto upper로 설정되는 듯 하였다! (maven, gralde로 import한 프로젝트에서는 발생하지 않았다!)\n해결 방법 문제 해결방식은 단순했다! intellij global option을 설정하는 file (아마도) intellij \u0026gt; bin \u0026gt; idea.properties file 내에 idea.native2ascii.lowercase=true 만 추가해주면 됐다!\n사소한 문제지만 기억해두면 찾을 필요가 없을 것 같아 posting 해둔다 ㅎㅎ..\n출처\nIntellij 프로퍼티 파일 Ascii로 변경시 key값이 대문자로 변경되는 문제\n","permalink":"https://HyoseungJeon.github.io/posts/intellij/propertiesautoupper/","summary":"문제 Intellij 내에서 간단한 문구 수정 때문에 properties file을 수정했는데 갑자기 file 전체에 변경사항이 잡혔다! 내용을 확인해보니 utf-8 Code 의 제일 앞 알파벳이 다 대문자로 upper 된 것 이였다..;\n원인 사실 크게 문제가 될 것 같지는 않지만 코드 리뷰 페이지에서 file 전체에 변경사항이 잡혀 edit line이 쓸데없이 많이 counting 되었다. 또한 호오오오옥~~ 시나 모르는 bug가 발생할 가능성이 무서워.. 수정을 해야할 것 같았다!\n문제의 원인은 project를 처음에 import 할 때에 eclipse type으로 열면 project option이 auto upper로 설정되는 듯 하였다!","title":"Properties Auto Upper"},{"content":" 💡 Push Message Server에 문제가 발생했다! 등록된 결함의 내용은 간헐적으로 push 알림이 사용자에게 2건 씩 날라간다는 내용이였다. 그 이유는 무엇일까?? 이유는 Multi Thread 환경에서 Data의 동기 처리가 제대로 되어있지 않아서 였다.. 좀 더 잣세히 알아보자! Synchronized Synchronized란? The Java programming language provides two basic synchronization idioms: synchronized methods and synchronized statements. The more complex of the two, synchronized statements, are described in the next section. This section is about synchronized methods. 출처 - https://docs.oracle.com/javase/tutorial/essential/concurrency/syncmeth.html\nSynchronized에 관련한 Java Doc 페이지가 없어 사용 예제 페이지의 자료를 가져왔다!\n결국 Java의 병렬 Thread에 관련한 문제 해결 기법으로 해당 method type을 사용하여 함수를 동기화로 설정하는 명령문이다!\n동작 원리 Intrinsic Locks and Synchronization\nSynchronization is built around an internal entity known as the intrinsic lock or monitor lock. (The API specification often refers to this entity simply as a \u0026ldquo;monitor.\u0026rdquo;) Intrinsic locks play a role in both aspects of synchronization: enforcing exclusive access to an object\u0026rsquo;s state and establishing happens-before relationships that are essential to visibility.\nEvery object has an intrinsic lock associated with it. By convention, a thread that needs exclusive and consistent access to an object\u0026rsquo;s fields has to acquire the object\u0026rsquo;s intrinsic lock before accessing them, and then release the intrinsic lock when it\u0026rsquo;s done with them. A thread is said to own the intrinsic lock between the time it has acquired the lock and released the lock. As long as a thread owns an intrinsic lock, no other thread can acquire the same lock. The other thread will block when it attempts to acquire the lock.\nWhen a thread releases an intrinsic lock, a happens-before relationship is established between that action and any subsequent acquisition of the same lock. 출처 - https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html\n간단하게 설명하면 Lock, wait 기법으로 동기화를 구현한다!\n1개의 Thread가 동기화 method를 호출하면 고유한 Lock을 획득하게 되고 실행이 종료된 후에 해당 Lock을 해제한다. Lock을 소지중인 상태에서 다른 Thread에서 접근 시 Lock의 소지여부 상태를 체크하여 wait 상태로 해당 Lock의 해제를 기다리게 된다. 후에 Lock이 풀린 후 해당 method가 다시 고유의 Lock을 생성, 획득 후 작업을 처리하게 된다.\nChcek Point 해당 Lock의 시점에 따라 동기화 처리의 Scope가 결정된다! static, class inner method, 람다식 호출 등 사용 방식에 따라 thread간의 동기화 처리 방식이 달라진다.\n!! 중요한 점은 1개의 Instance 안에서만 동기 방식으로 처리된다는 것이다!\n간단하게 말하면 해당 method가 서로 다른 객체로 생성된 후 각 method를 호출해도 해당 instance 환경을 사용하는 thread 간에서만 동기 방식으로 수행된다는 것 이다. 즉, Singletone pattern을 지키지 않은 instance의 method에 해당 동기화 선언문을 작성해도 실제론 효과가 없다는 말이다.\n작업 소요시간이 큰 scope에 동기화 선언을 하면 작업의 효율이 매우 저하된다! Multi thread로 얻는 효율성을 강제로 막게 되는 부분인데, 만약 해당 동기 작업이 8초의 cost를 갖는다면 다른 thread들은 해당 시간 동안 다른 작업을 처리하지 못하게 된다. Data의 정합성을 위해서 사용하는 경우라면 해당 영역만 분리하여 사용하는 것이 올바른 사용방법이다!\nLock의 획득 주체가 누군지 정확하게 파악해야 한다!\n밑의 블로그에서 위 주제와 관련한 내용을 잘 정리해주셨다! 자세한 내용은 하단의 블로그를 참고하면 된다.\n결론적으론 데이터의 정합성과 작업 효율를 고려하여 Instance 단위인지, class 단위인지, block 단위인지 여부를 판단하고 사용할 필요가 있다.\nhttps://velog.io/@backtony/Java-synchronized-동기화\n예제 // instance scope public class SynchronizedCounter { private int c = 0; public synchronized void increment() { c++; } public synchronized void decrement() { c--; } public synchronized int value() { return c; } } // class scope public class SynchronizedCounter { private int c = 0; public static synchronized void increment() { c++; } public synchronized void decrement() { c--; } public synchronized int value() { return c; } public void run(String name) { synchronized (B.class){ System.out.println(name + \u0026#34; lock\u0026#34;); b.run(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(name + \u0026#34; unlock\u0026#34;); } } } public class Main { public static void main(String[] args) { SynchronizedCounter a = new SynchronizedCounter(); Thread thread1 = new Thread(() -\u0026gt; { a.increment(); }); Thread thread2 = new Thread(() -\u0026gt; { a.increment(); }); thread1.start(); thread2.start(); } } 사용법은 간단하다.\n동기적으로 실행할 method에 synchronized 선언을 추가하면 된다!\n단, 위에 서술한 주의사항들을 참고하여 목적에 맞는 형태로 사용하면 된다.\n내 사용 예제 @Override public synchronized List\u0026lt;Object\u0026gt; loadPushMessageList(SimpleSenderContext context) throws Exception { } 내 작업 내용은 간단했다! 발송 Message List를 불러오는 method에 동기화 선언을 추가했다. 그리고 해당 class는 @Component 로 선언이 되어있어 1개의 Instance로 관리되고 있다! 하여 해당 method 내에서 발송 list를 읽고, 읽은 list에 flag를 추가하여 중복된 row을 읽어오지 않도록 처리하였다!\n느낀점 작업의 효율성을 위해 병렬 Thread 환경을 추가하는 것은 너무 좋다고 생각한다! 실제로 Java 언어를 통해 쉽게 병렬처리 환경을 구현할 수 있기 때문에 필수적이라고 생각도 든다. (필요하다면!) 하지만 단순하게 Domain에 대한 분석이 없이 무작정 적용하거나, 혹은 실제 작업의 수행 환경이 고려되지 않는다면 예고치 않은 bug를 또 마주할 수 있다는 것을 확인했다. 물론 사전에 처리가 제대로 안돼있었던게 문제긴 하지만 이번 기회에 또 좋은 지식을 얻게 되어 좋았다!!!\n출처\nJava - synchronized 동기화\n","permalink":"https://HyoseungJeon.github.io/posts/java/synchronized/","summary":"💡 Push Message Server에 문제가 발생했다! 등록된 결함의 내용은 간헐적으로 push 알림이 사용자에게 2건 씩 날라간다는 내용이였다. 그 이유는 무엇일까?? 이유는 Multi Thread 환경에서 Data의 동기 처리가 제대로 되어있지 않아서 였다.. 좀 더 잣세히 알아보자! Synchronized Synchronized란? The Java programming language provides two basic synchronization idioms: synchronized methods and synchronized statements. The more complex of the two, synchronized statements, are described in the next section. This section is about synchronized methods.","title":"Synchronized"},{"content":" 💡 프로젝트 투입 후 새로운 노트북을 지원 받아 일을 하게 됐다! 근데.. 시간이 지날수록 Intellij의 성능이 매우 느려졌고.. 컴퓨터의 기능이 정지하는 수준까지 가게 되었다.. 해서 작업관리자를 먼저 확인해보니 Memory의 점유율이 이상했다.. 노트북은 16GB의 Memory를 갖고 있었는데 실제로 가용한 메모리의 양이 11GB 정도였다! 해서 추가적으로 확인해보니 Memory의 비페이징 풀 이라는 항목이 3.5GB 정도를 점유하고 있었다.. 하여 그 문제점을 해결하던 중 window의 NUD 를 발견하게 되었다..! 이 문제를 좀 알아보자.. Window NUD NDU란? Network Data Usage Monitoring Driver의 약어로 네트워크의 사용량을 모니터링 하고 그 정보를 관리하는 Window의 기능이다.\n문제 원인 환경 현재 프로젝트에서는 노트북에 보안 환경 세팅이 완료된 Window User를 추가하고 해당 계정으로 Window에 접속하는 방식의 업무 환경을 지원하고 있다! 하여 Network나 문서 관련한 보안 프로그램들이 자동으로 Setting이 되고 Window 계정 권한과 관련된 것들도 자동으로 다 Lock 된 상태로 사용하게 된다.\n원인 분석 Window의 이벤트 뷰어 기능을 사용한 결과 보안 관련한 error가 엄청나게 찍혀있었다..! (매일 매일 많이 로그가 쌓여있었다) 하여 보안 log 저장소의 용량이 혼자서 1000MB 이상으로 비이상적이게 많이 쌓여있었다.. 해당 로그의 내용은 Sensitive Privilege Use 작업으로 사용 프로그램 권한을 검사하다가 나는 error 같은데.. 정확한 내용은 더 디버깅 해보지 못했다! (디버깅 툴 설치 사용이 불가능 했다)\n메모리의 점유 관련한 정보를 작업관리자를 통해 확인하기 어려워 RAMMAP Program을 설치하여 더 추가적인 정보를 확인해보았다! 비페이징 메모리 점유에 관련한 정보를 찾아보니 security 항목으로 비페이징 메모리를 점유하고 있더라..\n결국 문제의 관계는 Window 보안 프로그램의 동작 오류로 인하여 모니터링 혹은 관련 프로그램의 메모리 할당이 해제되지 않고, error 발생 시 마다 kill 되지 않은 메모리가 쌓여서 사용하지 않는 메모리의 점유가 늘어나 발생한 문제 생각했다!\n하여 관련한 내용을 추가적으로 검색해보다가 Window의 NUD issue에 접근했다!!\n해당 Issue를 검색해보니 나와 증상이 똑같이 비페이징 메모리가 지속적으로 쌓이고 점유된 메모리가 사라지지도 않았다. 해당 문제는 Window 8 버전 때 부터 지속적으로 올라오던 문제라고 하더라.. 하지만 일반 PC를 사용할 때에는 전혀 문제가 없었는데 왜 이 환경에서만 발생하였을까?\n난 이 문제를 내부 보안프로그램의 문제점이라고 생각했다. 해당 보안프로그램의 고려 환경은 우리와 같은 외부 Office 환경에서 Setting을 통해 접근하는 환경은 고려하지 않은 대상 같았다. 하여 위와 같은 문제점들이 발생한 것 아닐까..? 일반 사내 Office 환경의 사용자들도 문제를 인식했다면 이런 문제들이 진작에 보고되고 해결되었을텐데.. 전혀 개선이 없는 것 보니 결국 새로운 환경의 사용자에게 발생한 문제로 보였다!\n해결 방법 문제는 굉장히 쉽게 해결되었다.. NUD의 동작을 통해 불필요한 메모리 점유가 발생함으로 해당 기능을 끄는 것으로 문제는 해결되었다..!!\nWindow regedit option에서 NUD 기능을 꺼버리고 재부팅 하니 메모리 점유가 정상으로 돌아왔다..! (오….. 드디어 돌아왔구나….)\nHow? window key + R 로 실행 창 띄움 regedit 입력 후 확인 컴퓨터{localPC}\\SYSTEM\\ControlSet001\\Services\\Ndu 경로 접근 start option “4”로 설정 재부팅 해당 Option 값이 NUD를 끄는 값이라고 하더라.. 위 과정을 거치면 메모리는 돌아온다..!\n내 생각 보안 프로그램의 window 강제 세팅 때문에 Window Defender의 실시간 모니터링 option 프로그램 예외로 intellij를 등록하지 못해서 성능이 매우 느려진다.. 사용하는 프로젝트도 많은데 Load 할 수록 성능이 매우 떨어지더라.. 정말 여러가지로 개발자한테는 최악의 환경인 것 같다.. ㅜ\n아마도 일반 오피스 업무 사용자들은 상관 없을 수 있는 문제들인데 개발자의 환경에는 정말 악독한 상황이라 더 힘든 것 같다.. 다른 프로젝트들에서 겪지 못했던 추가적인 문제들을 마주하니 당황스럽기도 하고 또 스트레스도 나름 받았던 것 같다..\n사실 어떻게 내가 처리할 수 없는 영역이라 기능적인 얘기를 하기는 좀 그렇다! 하지만 업무 환경의 중요성이 새삼 중요하다는 걸 깨달았다..! 또한 window의 단점이 강하게 와닿았다.. 원하지도 않은 기능 때문에 불필요한 memory 점유와 강제 option 설정 등 개발자로 하여금 불편한 요소들을 참 많이 갖고 있구나.. 싶었다!! 덕분에 Mac 환경에 대한 경험이 더 강하게 필요하겠다 라는 생각이 들었다! 내년엔 꼭 사서 사용해봐야지..\n","permalink":"https://HyoseungJeon.github.io/posts/window/nud%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%88%84%EC%88%98/","summary":"💡 프로젝트 투입 후 새로운 노트북을 지원 받아 일을 하게 됐다! 근데.. 시간이 지날수록 Intellij의 성능이 매우 느려졌고.. 컴퓨터의 기능이 정지하는 수준까지 가게 되었다.. 해서 작업관리자를 먼저 확인해보니 Memory의 점유율이 이상했다.. 노트북은 16GB의 Memory를 갖고 있었는데 실제로 가용한 메모리의 양이 11GB 정도였다! 해서 추가적으로 확인해보니 Memory의 비페이징 풀 이라는 항목이 3.5GB 정도를 점유하고 있었다.. 하여 그 문제점을 해결하던 중 window의 NUD 를 발견하게 되었다..! 이 문제를 좀 알아보자.. Window NUD NDU란?","title":"Nud 메모리누수"},{"content":" Nice본인인증 이슈2 문제 본인인증 기능이 운영기에 배포 후 얼마 지나지 않아 특정 사용자가 인증에 지속적으로 실패하는 문제가 발생했다!\n원인 Kibana Log를 살펴본 결과 Nice의 본인인증 완료 후 화면에 encoding Data를 받아 복호화 하는 과정중에 에러가 발생했다! 그리고 복호화 실패의 원인은 유효한 encoding Data가 아닌 값을 받아 발생하였다.\n하여 해당 사용자의 request URI를 기준으로 local에서 test 해본 결과 encdoing Data가 변조 되어 controller 단에서 받아 문제가 생겼다! 하여 변조된 과정을 따라가보니 Nice 본인인증에서 Get 방식으로 URI에 data를 담아 보내주는데, base64 encoding 방식을 사용하여 특수문자가 포함된 param을 보내고 있었다! 헌데 사용자의 정보를 통한 encoding 값에 특수문자가 포함이 되고, api를 통해 값을 받을 때 “+”특수 문자가 공백(space)로 치환되서 넘어오고 있었다!\n하여 “+” 문자의 “space” 치환으로 인한 데이터 변조에 의해 문제가 발생하고 있었다. 특정 사용자에게만 문제가 발생한 이유도 해당 사용자의 encoding 값에 “+” 특수문자의 포함 여부에 달려있어 그랬던 것이였다…\n해결방법 우선 해당 URI param Data에 대한 변조는 담당 모듈 측에서 확인을 해주기로 했다! 그리고 내가 구현한 redirect api 에서는 해당 encoding Data의 변조에 대응하기 위해 공백을 다시 “+”로 치환해주는 로직을 추가하였다!! (사실 내가 또 변조하는 소스가 있어도 되는지 의구심은 든다..)\nString encodeData = originEncodeData.replaceAll(\u0026#34; \u0026#34;, \u0026#34;+\u0026#34;); 내 생각 어쨌든 터질 문제였다고 생각한다!! 해당 기능을 구현할 당시에도 Nice Doc 에서는 이미 jsp 방식의 구현 guide를 제공하고 있지 않았다! (아무리 찾아도 내용이 없었다..)\nNice는 key 발급을 통한 RestAPI 방식으로 서비스를 제공하고 있었다! 해당 방식으로 인증 부분을 구현했다면.. 발생했던 여러 issue들이 다 발생하지 않았을 텐데.. 결국 너무 날 것의 방식으로 구현된 소스가 결합도를 의도치 않게 높여 다양한 문제가 발생한 것 같다..\n하지만!! issue 통해 또 정보를 배우는 것 아니겠나..!\nURI를 통한 param Data를 주고 받는 과정에서 우리는 특수문자나 공백에 대한 제약사항이 있다! 하여 encoding, decoding 하는 과정에 대한 부분을 신경 써야 한다! “%20”이나 “+” 관하여 request filter 단에서 처리하는 것 같은데 (내 유추이다) 이 사실이 존재했다는 것과 그 과정을 이해하게 되었다!\n내가 짚고 싶은 점은 2개 인 것 같다!\n코드화 된 Data는 Get 방식으로 주고 받는게 조금 위험해 보인다..! 물론 이미 암호화된 Data라면 간단하게 GET 방식으로 의사소통 하는게 가벼워 보이고 좋지만! 그 과정 속에 URL String? 이라는 환경에 갇혀서 하게 되고, 만약 encoding 된 값이 대응하기 어려운 특수문자 같은 것들이 존재한다면 우리는 그 과정에 대해 대응을 해야 하는 업무량이 생긴다! (물론 일반적인 경우는 Spring이 다 해주는 것 같다..)\n두번째론 URI의 특수문자 관련한 encoding 과정에 대한 지식이 생겼다! 어찌 보면 당연하긴 한데 간과하고 있었던 영역이기도 하다! 다시 한번 UTF-8 이나.. ISO-889~~ 등에 관련한 encoding 방식에 대해 어느 정도 기본적인 지식이 필요한 것 같다!\n","permalink":"https://HyoseungJeon.github.io/posts/api/nice%EB%B3%B8%EC%9D%B8%EC%9D%B8%EC%A6%9D%EC%9D%B4%EC%8A%88%EB%8C%80%EC%9D%912/","summary":"Nice본인인증 이슈2 문제 본인인증 기능이 운영기에 배포 후 얼마 지나지 않아 특정 사용자가 인증에 지속적으로 실패하는 문제가 발생했다!\n원인 Kibana Log를 살펴본 결과 Nice의 본인인증 완료 후 화면에 encoding Data를 받아 복호화 하는 과정중에 에러가 발생했다! 그리고 복호화 실패의 원인은 유효한 encoding Data가 아닌 값을 받아 발생하였다.\n하여 해당 사용자의 request URI를 기준으로 local에서 test 해본 결과 encdoing Data가 변조 되어 controller 단에서 받아 문제가 생겼다! 하여 변조된 과정을 따라가보니 Nice 본인인증에서 Get 방식으로 URI에 data를 담아 보내주는데, base64 encoding 방식을 사용하여 특수문자가 포함된 param을 보내고 있었다!","title":"Nice본인인증이슈대응2"},{"content":" Nice본인인증 이슈 문제 issue로 올라온 사항은 Android, IOS App 단에서 본인인증이 제대로 실행되지 않는다는 사항이였다! 본인인증 popup에서 인증을 완료 시 정상적으로 처리되지 않고 에러페이지로 이동하는 상황 이였다.\n원인 문제의 원인은 본인인증 Callback method가 실행되지 않는 상황이였다!!\n현재 구현된 프로젝트는 하이브리드 App방식으로 Android, IOS 각 OS의 Webview를 통해 App을 구현하고 있었다! 하지만 내가 기존에 구현한 방식은 해당 환경까지 듣지 못하여 App 환경까지 고려하여 구현을 하지 않았다.. 🤦‍♂️ 기존에는 Web의 BOM을 활용하여 opener.parent.{callbackMehtod}로 인자와 함께 값을 넘겨 처리하고 있었다.\n하지만 App 단에서는 애초에 Opener 객체가 존재하지 않아 정상적으로 callBack을 수행할 수 없었다!\n해결 방법 위 issue는 사실 모듈 간 의사소통의 문제였던 것 같다..! App 모듈 측에서 제공하는 내부 함수 호출 method가 있었다!! 해서 해당 내용을 guide 받고 문제를 해결.. 할 뻔 했는데 추가적인 문제가 발생하였다!\n연달은 문제 문제 userAgent를 체크하여 App 환경일 시 제공 받은 guide의 method로 callback method를 실행하도록 수정하였다! 하지만 callBack method는 실행 되지만 함께 넘긴 parameter를 받지 못해 callback이 정상적으로 동작하지 않았다.. 😂😂\n원인 그 원인은 App 모듈 측에서 제공하는 함수가 문제였다. 문제 해결을 위해 해당 method의 소스를 살펴보았는데 Javascript의 eval 함수를 사용하여.. 호출을 하고 있었다..! 하여 호출한 page의 callback method는 잘 찾아서 호출 하였는데 Nice 본인인증의 redirect page의 scope는 참조하지 못해 parameter로 넘기는 객체를 찾지 못하고 있었다..\n해결 방법 우선 eval 함수를 사용하는 점은.. 타 모듈의 업무이기 때문에 더 관여하지 않기로 했다..! 이미 배포하여 사용 중인 소스이고 좀 애매했다 ㅜ..\n문제를 간단히 해결하기 위해 여러 방법들을 생각해봤다! 구글링 결과 eval 사용 부분을 수정해야 한다는 내용이 많았다.. 하지만 건드릴 수 없는 부분이니 배제할 수 밖에 없었다 ㅜ..\n하여 결국 찾은 최선의 방법은 객체를 넘기지 말고 JSON String 형태로 그냥 풀어서 보내고 받는 단에서 parsing 하는 방법이였다! 불필요한 소스가 한 두줄 들어가긴 하지만 현재 상황에서 문제를 해결하기에는 가장 쉬운 방법이였다.. 소스는 문제 없이 동작하고 이슈는 해결 되었다!\n내 생각 요즘 Web 사이트들의 Spec은 Hybrid app을 지원하는 것 같다! 대부분의 App이 위와 같은 방식으로 쉽게 구현하고 있는 것 같더라.. 하여 기본적으로 Web Window 객체를 활용한 Spec을 최대한 지양하고 JavaScript 그대로의 성능을 살려 구현을 해야 할 것 같다!\n혹은 애초에 Nice 본인인증 구현 방식 자체를 최신의 API 의사소통 방식을 통해 구현했다면..? 굉장히 여러 이슈들을 피해갈 수 있었을 것 같다.. 하지만!! 개발이 무조건 최선의 환경과 최신의 기술에서만 하는 일은 아니다.. 집을 지을 때에도 무조건 전기톱이나 최신 공구가 있어야 집을 짓는 건 아니지 않나!! 무딘 날이 있으면 내가 직접 갈아서 일을 할 때도 있는 것이고.. 옛 연장도 최대한 효율적으로 사용하여 결국 목적을 이루는 것 또한 내 직업의 일이다!\n비록 해결 자체는 쉬웠던 이슈였지만 여러모로 또 많은 걸 깨닫게 해주었던 이슈였다!! 재밌었다!!\n","permalink":"https://HyoseungJeon.github.io/posts/api/nice%EB%B3%B8%EC%9D%B8%EC%9D%B8%EC%A6%9D%EC%9D%B4%EC%8A%88%EB%8C%80%EC%9D%91/","summary":"Nice본인인증 이슈 문제 issue로 올라온 사항은 Android, IOS App 단에서 본인인증이 제대로 실행되지 않는다는 사항이였다! 본인인증 popup에서 인증을 완료 시 정상적으로 처리되지 않고 에러페이지로 이동하는 상황 이였다.\n원인 문제의 원인은 본인인증 Callback method가 실행되지 않는 상황이였다!!\n현재 구현된 프로젝트는 하이브리드 App방식으로 Android, IOS 각 OS의 Webview를 통해 App을 구현하고 있었다! 하지만 내가 기존에 구현한 방식은 해당 환경까지 듣지 못하여 App 환경까지 고려하여 구현을 하지 않았다.. 🤦‍♂️ 기존에는 Web의 BOM을 활용하여 opener.","title":"Nice본인인증 이슈대응"},{"content":" JQuery Custom Validate 개발 방향 지난번 JQuery Validate Plugin은 rule과 message를 mapping 해서 할당 후 노출하는 구조였다! 해서 내가 해결하려고 했던 정적으로 message를 계속 선언하는 부분이 개선되지 않았다. 해서 field의 attribute 값들로 모든 setting이 가능한 방식으로 구현을 해보려고 한다…! 😁😁\n소스 validateForm(formId) { const formTag = $(`#${formId}`) // form tag check if (!formTag.is(\u0026#34;form\u0026#34;)) { console.error(`${formId} is not Form tag or can\u0026#39;t find!! check id`) alert(\u0026#34;사용자 에러 메세지 노출\u0026#34;); return false; } // 하위 all input, select element 조회 for(let element of formTag.find(\u0026#39;input\u0026#39;, \u0026#39;select\u0026#39;)) { const { style, type, name, value, dataset } = element // element check if (type === \u0026#39;hidden\u0026#39; || style.display === \u0026#39;none\u0026#39; || !$(element).is(\u0026#34;:visible\u0026#34;)) continue; // get tag info, rule option (by attribute) let ruleAry = typeof dataset.rules === \u0026#39;string\u0026#39; ? dataset.rules.split(\u0026#39; \u0026#39;) : [] ruleAry = type === \u0026#39;select\u0026#39; ? [\u0026#39;required_sel\u0026#39;] : ruleAry for (let rule of ruleAry) { const { validate, message } = getValidateRule(rule) if (!validate(value)) { // alert 노출 alert(argMessage(message, name)); $(element).focus() return false; } } } return true; } const ruleMap = new Map([ [ \u0026#39;required\u0026#39;, { validate: v =\u0026gt; !!v, message: \u0026#39;을(를) 입력해주세요.\u0026#39; } ], [ \u0026#39;required_sel\u0026#39;, { validate: v =\u0026gt; !!v, message: \u0026#39;을(를) 선택해주세요.\u0026#39; } ], [ \u0026#39;regNo\u0026#39;, { validate: v =\u0026gt; !!v, message: \u0026#34;올바른 법인등록번호를 입력해주세요.\u0026#34; } ], [ \u0026#39;email\u0026#39;, { validate: v =\u0026gt; !!v, message: \u0026#34;올바른 이메일 형식을 입력해주세요.\u0026#34; } ], ]) function getValidateRule(ruleName) { if (!ruleMap.has(ruleName)) { console.warn(`[Validation is bypass] ${ruleName} is not defined, plz check rule name.`) return { validate: v =\u0026gt; true, message: \u0026#34;bypass\u0026#34; } } return ruleMap.get(ruleName) } 구조 구조는 상대적으로 간단하다. DOM Element field로 Form을 최상단에 부모로 선언하고, 해당 자식값에 필요한 input, select field를 선언한다. 그리고 name, value, dataset-rules 값을 선언한다.\nValidation check 할 key(항목명), value(validate: check function, message: 노출 message)를 선언한다.\n사용할 곳에서 validate 함수에 첫번째 매개변수로 form field의 id값을 입력하고 넘겨 실행한다.\n로직은 다음과 같다.\nform field 내 모든 input, select field를 조회한다. 단, form field 아닐 시 error, alert 노출 field의 name, value, rules 값을 꺼낸다. 단, 비노출 상태일 시 다음으로 rules 값을 array 형태로 선언한다. 단, string 이외의 type 경우 빈 array로 선언 type이 select 인 경우 특정 rule array로 선언 rule array를 순회한다. rule name으로 Map에서 validate function과 message를 꺼낸다. validate fail 시 alert 노출, focus를 이동한 후 종료한다. 내 생각 아직 많은 예외 케이스들에 대한 처리가 있지는 않지만 정확하게 구조에 따라 작성을 한다면 아무런 문제 없이 동작했다! 하지만 message 노출에 관련한 부분은 개선이 필요했다 ㅎ.. 기존에 message get 방식을 그대로 차용해와서 사용했다. 때문에 이 부분도 개선할 필요가 보이더라 ㅜ.. 그 부분을 제외한다면 정확하게 의도대로 동작하였고 사용성도 내 기준에서는 괜찮은 듯 했다! 이로 인해 수많은 분기 문들과 보일러 플레이트가 많이 사라졌다.. 😆😆 더 좋은 방향으로 계속 개선해봐야겠다!!\n","permalink":"https://HyoseungJeon.github.io/posts/javascript/validate/","summary":"JQuery Custom Validate 개발 방향 지난번 JQuery Validate Plugin은 rule과 message를 mapping 해서 할당 후 노출하는 구조였다! 해서 내가 해결하려고 했던 정적으로 message를 계속 선언하는 부분이 개선되지 않았다. 해서 field의 attribute 값들로 모든 setting이 가능한 방식으로 구현을 해보려고 한다…! 😁😁\n소스 validateForm(formId) { const formTag = $(`#${formId}`) // form tag check if (!formTag.is(\u0026#34;form\u0026#34;)) { console.error(`${formId} is not Form tag or can\u0026#39;t find!! check id`) alert(\u0026#34;사용자 에러 메세지 노출\u0026#34;); return false; } // 하위 all input, select element 조회 for(let element of formTag.","title":"Custom Validate"},{"content":" 💡 프로젝트 투입 후 맡게 된 화면에서 가변 Input field가 추가되었는데 Validate 부분이 분기 문으로 처리되어 있었다..! 해서 결국 관련된 소스를 하나하나 찾아서 추가하고 영향도 있는 부분은 수정하는 작업을 했다… 사실상 요구사항은 간단했지만 필요 이상으로 작업이 오래 걸렸다! 그럼으로 기존 분기 처리로 된 Validate가 아닌 jQuery 기반의 Validate로 구현을 한번 해보자! JQuery Validate? 정의 The jQuery Validation Plugin provides drop-in validation for your existing forms, while making all kinds of customizations to fit your application really easy. 출처 - https://github.com/jquery-validation/jquery-validation\n단순히 유효성 검사를 쉽게 조작하여 처리할 수 있도록 돕는 Plugin이다! (딱히 더 정확한 정의는 없는 것 같다 ㅎ..😂)\n사용 이유 우선 기존 프로젝트가 jQuery를 기반으로 구현되었다! 해서 관련된 Plugin을 활용해서 사용하려 했다. 현재 form, input field로 구현된 소스로 구조에 변화 없이 validate 처리가 가능함으로 쉽게 구현이 가능할 것 같았다! rule, message Mapping 정의로 현재 Validate 처리 logic를 쉽게 복각하기 쉬워 보였다! 기존에 field 에 각각 alert message를 할당하여 노출하는 방식이였는데, 그대로 활용하기 쉬울 것이라고 예상했다.\n사용법 \u0026lt;form\u0026gt; \u0026lt;input required\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script src=\u0026#34;jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;jquery.validate.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const option = { rules: { userId : { required: true, rangelength: [2, 10] }, userEmail: { required: true, email: true } }, messages: { userId: { required: \u0026#34;이름은 필수 입력입니다.\u0026#34;, rangelength: \u0026#34;이름은 {0}자에서 {1}자까지 사용 가능합니다.\u0026#34; }, userEmail: { required: \u0026#34;이메일은 필수 입력입니다.\u0026#34;, email: \u0026#34;이메일 형식을 확인하세요.\u0026#34; } }, submitHandler: function(){ console.log(\u0026#34;submit!\u0026#34;); } } $(\u0026#34;form\u0026#34;).validate(option); \u0026lt;/script\u0026gt; 사용법은 간단하다! option 정의 후 form field의 id값으로 찾아 validate fucntion을 option값을 넘겨 실행하면 된다!\noption 정의에 관련한 자세한 내용은 출처 Page들을 참고하면 된다.\n내 소스 소스가.. 없다..! 🤔\n왜냐하면 처음에 고려한 설계와 다르게 내가 원하는 기능이 지원하고 있지 않았다.. 😂 (아닐 수도 있음)\n기존에 alert 문구 노출 방식은 field 값을 참고해 “{title name}을 입력해주세요” 등의 문구로 노출하고 있었다. 하지만 위의 rule, message 방식은 정적으로 message를 선언하는 방식으로 결국은 매번 똑같이 message 문구를 넣어주는 수 밖에 없었다! 내가 원한 건 자동으로 input field의 title, name 값을 읽고 validate 조건을 체크해 alert 문구를 뿌려주는 방식이였다! 매번 새로운 field가 추가될 때 마다 분기를 치고 message를 추가하고, validate Logic을 넣고 등의 방식을 피하기 위해서 였는데.. 똑같은 노가다 소스를 작성해야 했다.. 해서 jQuery Spec을 이용한 다른 방식의 validate Util을 따로 구현했다! 내용은 다른 Posting에서 작성하겠다. (차후 링크 추가 예정)\n내 생각 물론 기존의 if else을 이용한 처리 방식보다는 가독성도 높고 사용법도 간편해서 좋았다! 하지만 내가 추구했던 방향은 유지보수의 측면이였다. 결국 field 추가와 삭제, 가변 field 처리 등에 관련하여 기능의 한계가 분명해 보였다. 물론 그런 고수준? 의 기능을 지원하기 위해서 기본 Plugin에게 기대하기는 어렵다고 생각이 들기도 한다.. (사실 잘 모르겠다.. 왜 이렇게 구현했는지..?)\nvalidate function은 form field 기준으로 단 1번 호출하고, 그에 따라 callBack, alert, error handling 등이 자연스럽게 처리 되는 방식을 필요로 했다. 여기저기 분기가 들어가 있고, messaage를 정적으로 매번 선언하고, 그에 따른 error handling도 따로 되어 있다면 결국 유지보수에서는 어마어마한 cost가 들어간다. (실제로 가변 field 추가하는 업무에 필요 이상의 많은 작업 시간을 사용했다)\n만약 input field에 대한 정의 (html source)만으로 validate가 동작 한다면 위와 같은 작업 시간은 필요가 없을 것이다. soruce 전체를 확인하거나 작업할 필요 없이 해당 input field만 정확하게 정의한다면 문제 없이 validate 가 처리될 것이다. 작업자는 결국 소스 여기저기를 살펴보거나 side effect를 걱정할 필요 없이 오로지 field 정의에만 신경을 쓰면 될 것이다.\n결국 이 이야기에 끝에는 항상 작업의 일정 때문에 어쩔 수 없이 그렇게 작업했다가 자주 나온다.. 하지만 난 항상 의문이다. 처음의 설계에 80, 작업에 20과 설계에 20, 작업에 80에 비중을 둔다면 결국 변경사항이 생겼을 때 80에 가까운 작업을 항상 해야할 것 이다. 혹은 새로운 작업자는 그 80의 작업을 다 확인하고 일을 해야 한다. 뭐가 맞을까..? 난 무조건 전자인 것 같다! 물론 사람마다 생각과 의견은 다르니 그럴 수 있다. 하지만 난 내 설계를 해가는 것이 재미있고 좋다! 새로운 Posting에서 내 생각의 소스를 써보겠다 😁👍\n출처 : https://github.com/jquery-validation/jquery-validation\nDocumentation\n","permalink":"https://HyoseungJeon.github.io/posts/jquery/validate/","summary":"💡 프로젝트 투입 후 맡게 된 화면에서 가변 Input field가 추가되었는데 Validate 부분이 분기 문으로 처리되어 있었다..! 해서 결국 관련된 소스를 하나하나 찾아서 추가하고 영향도 있는 부분은 수정하는 작업을 했다… 사실상 요구사항은 간단했지만 필요 이상으로 작업이 오래 걸렸다! 그럼으로 기존 분기 처리로 된 Validate가 아닌 jQuery 기반의 Validate로 구현을 한번 해보자! JQuery Validate? 정의 The jQuery Validation Plugin provides drop-in validation for your existing forms, while making all kinds of customizations to fit your application really easy.","title":"JQuery Validate"},{"content":" 💡 새로운 프로젝트에서 Push 알림 기능을 담당하게 됐다! 웹 개발을 하면서 한번도 접해보지 못했었는데 문자/이메일 은 너무 많이 경험해본 것 같아 Push를 해보겠다고 하였다!!😁😁 좋은 경험이 되기를!!!! FCM이란? 정의 Firebase Cloud Messaging(FCM)은 메시지를 안정적으로 무료 전송할 수 있는 크로스 플랫폼 메시징 솔루션입니다. 출처 - https://firebase.google.com/docs/cloud-messaging?hl=ko\n기능 알림 메시지 또는 데이터 메시지 전송 사용자에게 표시되는 알림 메시지를 전송합니다. 또는 데이터 메시지를 전송하고 애플리케이션 코드에서 임의로 처리합니다. 자세한 내용은 https://firebase.google.com/docs/cloud-messaging/concept-options?hl=ko#notifications_and_data_messages을 참조하세요. 다양한 메시지 타겟팅 단일 기기, 기기 그룹, 주제를 구독한 기기 등 3가지 방식으로 클라이언트 앱에 메시지를 배포할 수 있습니다. 클라이언트 앱에서 메시지 전송 FCM의 신뢰성 높고 배터리 효율적인 연결 채널을 통해 기기에서 다시 서버로 확인, 채팅, 기타 메시지를 보낼 수 있습니다. 기본 원리 FCM 구현에는 송수신을 위한 두 가지 주요 구성요소가 포함됩니다.\nFirebase용 Cloud Functions 또는 앱 서버와 같이 메시지를 작성, 타겟팅, 전송할 수 있는 신뢰할 수 있는 환경 해당 플랫폼별 전송 서비스를 통해 메시지를 수신하는 Apple, Android 또는 웹(자바스크립트) 클라이언트 앱 Firebase Admin SDK 또는 FCM 서버 프로토콜을 통해 메시지를 보낼 수 있습니다. 알림 작성기를 사용하면 기본 제공되는 강력한 타겟팅 및 분석 기능이나 커스텀 가져온 세그먼트를 사용하여 마케팅 또는 참여 메시지를 테스트하고 전송할 수 있습니다.\nFCM의 구성요소에 대한 자세한 내용과 중요한 정보는 아키텍처 개요를 참조하세요.\n즉, 무료로 Server 단에서 FCM Server를 통해여 정해진 규약에 따라 사용자 클라이언트에게 메세지를 보내는 서비스이다!\n사용법 FirebaseApp firebaseApp; ClassPathResource filePath = new ClassPathResource(pushFirebaseProperties.getFileName()); FirebaseOptions options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(filePath.getInputStream())) .build(); firebaseApp = FirebaseApp.initializeApp(options); FirebaseMessaging FirebaseMessagingInstance = FirebaseMessaging.getInstance(firebaseApp); // 메시지 설정 Notification notification = Notification.builder() .build(); MulticastMessage message = MulticastMessage .builder() .setNotification(notification) .build(); // 메시지 전송 BatchResponse response = FirebaseMessagingInstance.sendMulticast(message); 사용법은 간단하다. 발급 받은 Firebase 인증 정보 File을 읽고 App 객체를 생성, FirebaseMessaging\nInstance를 생성하여 메시지를 설정 후에 send 하면 끝이다!\n단, 내부 source를 공개하기는 어렵지만 구조는 이러하다.\nSpring Daemon Server로 구성 알림 등록 시, 알림 대기 목록 table insert Daemon server는 5초 간격으로 table read 조회 된 row 있을 시 병렬 처리 Thread에 작업 할당 알림 발송 병렬 처리 (FCM 발송) 성공/실패 Log table insert 처음 인수인계를 받고 Daemon server로 구현된 방식이 신기했다! Spring batch가 아닌 오랜만에 보는 Daemon server.. 좀 두려웠다;;\n알림은 크게 단 건, 다 건 두 종류로 처리하고 있었다! 그래서 당연히 단 건은 Controller API로 받아서 즉시 처리할 줄 알았는데 두 종류 모두 Daemon Server가 각 case의 Table을 읽고 처리하고 있었다..! (무슨 의미일까..?) 어차피 5초마다 돌기 때문에 거의 실시간이라고 봐도 무방하지만.. 굳이 Thread를 하나 더 생성하여 할당 시키는 이유는 아직 납득하지 못했다.. 😒😒\nSpring Daemon Server Run 방식 자체도 조금 신기했는데, Scheduling File을 통해.. 단순히 Thread 2개를 run 시키고 해당 Thread Daemon이 계속 도는? 방식 이였다!! 처음에 위 File이 있어서 Batch로 구현 되어있나..? 라는 생각을 하였는데 Job도 없고.. 하여 엄청 헷갈렸는데 Daemon이란 걸 이해하고 바로 납득이 갔다!\n하여 Size가 10개 씩 잡힌 Thread 돌며 작업을 처리하고, 알림을 보낸다!! Runnable Class 를 상속 받은 Sender, Worker, Manager Context 들이 작업을 할당 받아 처리하고 있다.\n내 생각 생각보다 FCM이 제공하는 Service가 좋아서 쉽게 사용자에게 알림을 보낼 수가 있었다! 하지만 역시 그 환경을 구성하는 일이 더 중요하다고 봤다..\nPush 알림의 종류는 단 건, 다 건 두 종류였다! 내 생각에는 단 건은 문자 Service 와 같이 MQ를 이용하여 구성을 하고, 다 건은 Batch로 예약된 시간에 Server가 할당된 Thread를 통해서 처리를 하면 깔끔할 것이라고 생각했다! 하지만 둘 다 Daemon 방식으로 처리 되고 있는 것이 조금 놀라웠다..; 아니 사실 좀 이상하다고 생각했다! 하지만 기존의 Project 소스를 Reference로 삼아 작업을 한 것이라 어쩔 수 없었다는 말을 듣고 어느 정도 납득을 하긴 했다.. 하지만 이러한 상황들 때문에 오래된 것이든 경험을 해보고 또 배우고! 또 새로운 것의 장점을 제대로 느낄 수 있는 거 아닐까?\n언제나 그렇듯 제공되는 API는 기능일 뿐 결국 구성하는 방식이 중요했다! 특히 Spring 인데도 불구하고 FCM Instant 주입 방식이 static Syn~~ 방식으로 되어 있었다..! 그리고 Manager Context에 해당 FCM을 할당, 다른 Context에게 계속 param으로 넘기면서 사용하고 있었다;; 매번 param에 선언, static으로 선언한 이유도.. 이해가 가지 않았다. 해서 Config 단으로 FCM 초기화 Source을 이관하고, 해당 FCM 객체를 @Bean으로 선언하여 Single Tone으로 어디서나 주입 받아 사용할 수 있도록 수정 하였다! 기존 Service는 이미 제공되고 있어서 건드릴 수 없었지만 적어도 주입 방법이라도 바꾸고 싶었다.. 😂 (너무 신경 쓰여서 도저히 둘 수가 없었다..)\nCtrl C + V 는 좋다.. 하지만 아무런 사고 없이, 생각 없이 붙이는 작업은 최악이라고 생각한다..! 이런 기회를 통해서 마음을 한번 다시 다잡게 되었다!\n출처:\nhttps://firebase.google.com/docs/cloud-messaging?hl=ko\n","permalink":"https://HyoseungJeon.github.io/posts/api/fcm/","summary":"💡 새로운 프로젝트에서 Push 알림 기능을 담당하게 됐다! 웹 개발을 하면서 한번도 접해보지 못했었는데 문자/이메일 은 너무 많이 경험해본 것 같아 Push를 해보겠다고 하였다!!😁😁 좋은 경험이 되기를!!!! FCM이란? 정의 Firebase Cloud Messaging(FCM)은 메시지를 안정적으로 무료 전송할 수 있는 크로스 플랫폼 메시징 솔루션입니다. 출처 - https://firebase.google.com/docs/cloud-messaging?hl=ko\n기능 알림 메시지 또는 데이터 메시지 전송 사용자에게 표시되는 알림 메시지를 전송합니다. 또는 데이터 메시지를 전송하고 애플리케이션 코드에서 임의로 처리합니다. 자세한 내용은 https://firebase.google.com/docs/cloud-messaging/concept-options?hl=ko#notifications_and_data_messages을 참조하세요. 다양한 메시지 타겟팅 단일 기기, 기기 그룹, 주제를 구독한 기기 등 3가지 방식으로 클라이언트 앱에 메시지를 배포할 수 있습니다.","title":"FCM"},{"content":" 💡 사용자에게 현재 STATIC Directory에 있는 pdf File 들을 다운로드 기능과 함께 목록을 제공하는 기능을 구현하는 일을 받았다! 정적 자산을 객체로 받아 화면에 알맞게 던져주는 기능을 구현해보자!! 생각보다 자주 구현할 일이 있는 기능이지만 실제로는 처음 해봐서 재미있었다..😁👍 File Class 란? 정의 An abstract representation of file and directory pathnames.\nUser interfaces and operating systems use system-dependent pathname strings to name files and directories. This class presents an abstract, system-independent view of hierarchical pathnames.\n출처 - https://docs.oracle.com/javase/8/docs/api/java/io/File.html\nFile, Directory의 추상 Class 즉, 파일이나 경로에 대한 정보를 추상화한 Class이다.\n해당 객체는 경로의 문자열을 통하여 선언이 가능하다.\n사용법 기본 import java.io.File; public class Main { public static void main(String[] args) { String filePath = \u0026#34;C:/java/Test.txt\u0026#34;; String parentPath = \u0026#34;C:/java\u0026#34;; string fileName = \u0026#34;Test.txt\u0026#34;; // File(String pathname) 생성자 사용 File file1 = new File(filePath); // File(String parent, String child) 생성자 사용 File file2 = new File(parentPath, fileName); // File(File parent, String child) 생성자 사용 File parent = new File(parentPath); File file3 = new File(parent, fileName); // 파일명 System.out.println(file1 .getName()); // java // 절대 경로 System.out.println(file2 .getAbsolutePath()); // C:/java // 경로 System.out.println(file2 .getPath()); // C:/java // 존재 여부 System.out.println(file3 .exists()); // ture or false } } File의 정적 경로를 생성자로 사용하여 File 객체를 선언한다.\n후에 위와 같은 여러 method들을 통하여 해당 File의 정보를 조회할 수 있다.\n자세한 사용 방법은 Doc를 참고하는 것이 좋다!\n내 사용 예제 public File getUserManualFile() { File userManualFile; final String userManualFileDir = ResourceUtils.CLASSPATH_URL_PREFIX + \u0026#34;static/upload/manual\\\u0026#34;\u0026#34;; try { userManualFile = ResourceUtils.getFile(userManualFileDir); } catch (FileNotFoundException e) { throw new RuntimeException(\u0026#34;File을 찾을수가 없습니다.\u0026#34;); } return userManualFile; } public String popUserManual(Model model) { File file = mainService.getUserManualFile(); model.addAttribute(\u0026#34;userManualFileList\u0026#34;, file.listFiles()); return \u0026#34;/popup/userManualPopup\u0026#34;; } ResourceUtils - Spring Util 을 통하여 노출할 File들의 상위 File 객체를 가져온다!\n후에 해당 객체의 listFiles 함수를 통하여 File 객체 형태로 화면에 반환해준다.\n화면에서는 해당 File 객체를 이용하여 필요한 정보를 노출한다.\nUtility methods for resolving resource locations to files in the file system. Mainly for internal use within the framework. Spring FrameWork 에서 지원하는 Util로 프로젝트 내 resource 자원을 쉽게 조회하기 위한 Class이다. 출처 - https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/ResourceUtils.html\n느낀점 S3 Server에 File이 올라가 있고, 해당 File 정보를 DB나 직접 Server에 조회하여 이름과 경로를 가져오고 뿌리는 방식을 생각했었다. 하지만 static 경로에 File을 위치 시키는 경우도 당연히 존재하는데 해당 경우에 대한 처리는 알지 못했었다!! 해서 이번 기회를 통해 새로운 지식을 알게 되어서 좋았다. 프로젝트의 정적 경로에 File들에 대해 다루는 방법을 알게 되었고 Spring에서 해당 기술을 위해 지원하는 Util 또한 존재한다는 것을 알게 되어 역시 Spring은.. 좋은 FrameWork이라는 것을 또 깨달았다..\n이번 기능을 구현하며 집중했던 부분은 File 객체를 최대한 활용하는 것 이였다! 따로 Dto response를 활용하여 뺄 수 있었지만 실제로 File 객체가 공식화 된 Dto 라고 여기고.. 해당 File 통해 화면에서 정보를 노출하려 했다! 실제로 필요한 File에 대한 정보가 해당 객체에도 충분하게 담겨있어 화면에서도 사용하기 용이했다. 간단하지만 재미있는 경험이였다!\n출처\nhttps://docs.oracle.com/javase/8/docs/api/java/io/File.html\nhttps://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/ResourceUtils.html\n","permalink":"https://HyoseungJeon.github.io/posts/java/file/","summary":"💡 사용자에게 현재 STATIC Directory에 있는 pdf File 들을 다운로드 기능과 함께 목록을 제공하는 기능을 구현하는 일을 받았다! 정적 자산을 객체로 받아 화면에 알맞게 던져주는 기능을 구현해보자!! 생각보다 자주 구현할 일이 있는 기능이지만 실제로는 처음 해봐서 재미있었다..😁👍 File Class 란? 정의 An abstract representation of file and directory pathnames.\nUser interfaces and operating systems use system-dependent pathname strings to name files and directories. This class presents an abstract, system-independent view of hierarchical pathnames.","title":"File"},{"content":" 💡 새로운 Project에 투입되어 바로 Nice 본인 인증 API 기능을 추가하는 작업을 배정 받았다! Spring JSP, thymeleaf 각 project에 추가를 하면 된다!! 여기 저기서 사용하는 외부 API 로 실제 내가 개발해보는 재미를 느껴보자😍 Nice 본인인증 이란? NICE 평가정보 회사에서 제공하는 본인 확인 서비스로 사용자의 주민등록번호 등과 같은 정보를 통해 실명 확인 과정을 거쳐 사용자의 명의를 확인할 수 있는 기능을 제공하는 API 이다.\n아마 내 생각엔 국내에서 개인 인증을 해야 하는 모든 사이트들이 API를 사용하여 인증을 하고 있을 것이다! 나 또한 엄청 쓰는 것 같다..\n해서 프로젝트 에서는 Nice 본인인증의 휴대폰 본인확인 방식을 넣게 되었다!\n개발 개발 방향 해당 API 에 관련하여 Docs 에서 자료를 찾아본 결과, API 호출 방식과 jsp file로 구현하는 방식으로 2개의 가이드라인을 제공하고 있었다.\n본 프로젝트에서는 다른 프로젝트에서 JSP 방식의 구현을 채택하여 사용 중 이여서 그런지 해당 방식으로 기능을 구현하기로 했다.\nGuide Line 사용 방법은 굉장히 간단하다!\nNice에서 제공하는 .jar File을 project에 import 하고,\n가이드에 나와있는 .jsp File들을 참고하여 사용자의 key 등등의 custom 값들만 변경해주면 사용 준비는 끝난다\n우리는 프로젝트의 Nexus Repository에 해당 .jar File을 업로드 후 당겨서 쓰는 방식으로 setting 을 했다!\n다른 부분들은 굉장히 기본적이지만 내가 집중해서 말하고 싶은 부분이 있다\n해당 기능은 당연하게도 공통 방식으로 구현이 된다. 해서 모든 페이지에서 호출이 가능하고 적절한 response를 돌려줘야 한다!\n가이드 문서의 구현 방식은 returnUrl을 popup Open 시 request로 받고 인증 완료 시 해당 Url site로 결과값과 함께 redirect 해주는 방식으로 되어있었다!\n처음에 해당 가이드를 통해 생각을 했을 때에는 그럼 사용자에게 request로 returnUrl을 입력 받아야겠다! 라고 생각을 하게 되었다.\n하지만 해당 방식은 사용자에게 꽤나 불편한..? 요소로 작용할 것 같았다. 호출 시에 매번 호출 페이지의 URL을 보내야 한다니 조금 이상하긴 했다.\n해서 다른 예제들을 참고하여 기능을 재구현 했다!\n내 구현 방식 사용자는 단순히 js내의 nice 본인인증 Open Method을 호출하고\ndata Setting 부분은 공통으로 처리\n단, returnUrl에 사용자의 returnUrl이 아닌 공통의 redirect Page의 URL을 넣는다.\nvar niceInfo = ${niceInfo}; opener.parent.callback(niceInfo); close(); 해당 redirect Page는 Nice에서 받은 사용자 정보를 Method를 호출한 js File의 callback method에 param을 담아 호출하고, page를 닫는다.\n하면 사용자는 인증 완료 시 호출할 callBack method 1개와 본인 인증 호출 method 한줄만 추가하면 사용할 수 있게 된다. 넘겨줄 값이 없다!! 사용 편의성이 훨씬 좋지 않은가..?\n내 생각 아마 혼자 개발 했다면 가이드 라인대로 개발을 진행했을 것 같다.. 하지만 브라우저의 Window 객체를 통한 활용 방식을 알고 있었다면 굉장히 간단히 구현해냈을 기능이다..\n웹 개발을 비교적 최신 기술인 Vue 2.0 부터 시작해서 인지 Popup 관련한 지식이나 Window 객체의 활용에 대한 지식이 부족한 것 같다 😢\nwindow Popup은 꼭 Window.opener 인터페이스가 따라온다! 함께 생각하도록 하자!!\n출처\nNICE아이디 - 휴대폰본인확인\n","permalink":"https://HyoseungJeon.github.io/posts/api/nice%EB%B3%B8%EC%9D%B8%EC%9D%B8%EC%A6%9D/","summary":"💡 새로운 Project에 투입되어 바로 Nice 본인 인증 API 기능을 추가하는 작업을 배정 받았다! Spring JSP, thymeleaf 각 project에 추가를 하면 된다!! 여기 저기서 사용하는 외부 API 로 실제 내가 개발해보는 재미를 느껴보자😍 Nice 본인인증 이란? NICE 평가정보 회사에서 제공하는 본인 확인 서비스로 사용자의 주민등록번호 등과 같은 정보를 통해 실명 확인 과정을 거쳐 사용자의 명의를 확인할 수 있는 기능을 제공하는 API 이다.\n아마 내 생각엔 국내에서 개인 인증을 해야 하는 모든 사이트들이 API를 사용하여 인증을 하고 있을 것이다!","title":"Nice 본인인증"},{"content":" 💡 주로 Business Logic 을 작성하거나 혹은 보게 될 때 방대한 if else 분기와 보일러 플레이트들을 마주하게 된다!! 이는 Debuging 과정을 힘들게 하여.. 결국 지속적으로 안좋은 코드를 만들게 된다.. 하여 간단한 전략 패턴을 배워보고 활용해보자!! 전략 패턴이란? (Strategy Pattern) 정의 전략 패턴(strategy pattern) 또는 정책 패턴(policy pattern)은 실행 중에 알고리즘을 선택할 수 있게 하는 행위 소프트웨어 디자인 패턴이다. 전략 패턴은\n특정한 계열의 알고리즘들을 정의하고 각 알고리즘을 캡슐화하며 이 알고리즘들을 해당 계열 안에서 상호 교체가 가능하게 만든다. 전략은 알고리즘을 사용하는 클라이언트와는 독립적으로 다양하게 만든다.[1] 전략은 유연하고 재사용 가능한 객체 지향 소프트웨어를 어떻게 설계하는지 기술하기 위해 디자인 패턴의 개념을 보급시킨 디자인 패턴(Gamma 등)이라는 영향력 있는 책에 포함된 패턴들 가운데 하나이다.\n출처 - https://ko.wikipedia.org/wiki/전략_패턴\n정확한 정의를 참고하기 위하여 찾아보았지만 개인 블로그들의 정의보단 Wiki를 참고하는 것이 좋을 것 같다 가져왔다!\n내 정의 이 Design Pattern 의 이름은 ‘전략’ 이다! 이는 전쟁에서 승리를 가져오기 위한 하나의 방법을 서술하는 의미이다. 그리고 다시 우리는 프로그래밍의 측면에서 이 의미를 해석해본다면,\n우리가 목적으로 하는 것을 위하여 공통적인 여러가지 전략을 정의하여 상황에 따라 전략을 가변적으로 사용하게 만드는 패턴이라고 생각한다.\n그리고 그 패턴을 가능하게 하는 것이 캡슐화 인 것이다.\n구조 기본 구조 Context Class (abstract)\n전략을 선택하여 문제 해결을 수행할 구조를 정의한 Class\nStrategy Class를 변수로 갖고있다.\nStrategy Class (Interface)\n문제를 해결 할 전략의 형태를 정의한 Class\nContext class를 상속한 실제 Context class 생성, 해당 class에 목적에 맞는 Strategy class를 상속 받아 구현된 class을 set 한다.\n전략을 할당한 Context class의 공통 실행 method를 통하여 전략을 수행한다.\n예제 소스 public abstract class Order { private Process process; private Object data; public void runProcess() { // 공통 수행 method or logic 정의 // Common Validate logic process.validate(data); process.beforeProcess(data); process.run(data); process.afterProcess(data); } public void runProcessExceptBefore() { process.validate(data); process.run(data); process.afterProcess(); } } public interface Process { public void validate(Object data); public void beforeProcess(Object data); public void run(Object data); public void afterProcess(Object data); } public class NormalOrder extends Order {} public class Returning implements Process { @Override public void validate(Object data) { // check data // throw Exception } @Override public void beforeProcess(Object data) { // beforeProcess // can change Data } @Override public void run(Object data) { // run // call api, CRUD db } @Override public void afterProcess(Object data) { // afterProcess // call callback method, api, CRUD db } } public static void main(String[] args) { NormalOrder normalOrder = new NormalOrder(); normalOrder.setData(new Object()); normalOrder.setProcess(new Returning()); normalOrder.runProcess(); } Spring MVC 에서 보면 Service에 모든 분기와 process가 포함된 소스가 존재하는 것이 아닌 전략이나 수행 될 프로세스에 맞춰 분리가 가능하고, Service단의 소스가 간결해진다. 또한 전략 수행의 대상을 다양한 매개체로 설정하고 구현한다면 재활용성 또한 커지게 된다!\n결론 디자인 패턴에 대하여 학습할 때 마다 느끼는 점은, 실제 비즈니스 프로젝트에 적용할 때에 얼마나 효과적으로 적용할 수 있는지 에 대한 고민인 것 같다. 만약 사이즈가 작은 프로젝트에 여러 디자인 패턴을 적용하여 오히려 더 복잡한 구조를 만들어내거나, 혹은 본 패턴이 추구하는 목적을 잃고 단지 보여주기 위한 구조를 잡는다면 오히려 악효과를 낳게 된다. 요즘 분위기를 보다 보면 주객전도란 말이 너무 맞는 것 같다. 디자인 패턴의 목적은 결국 유지보수의 용이성이다. 반복되는 문제를 해결하기 위한 하나의 전략이다. 하지만 실제로는 목적을 위한 설계가 아닌 설계에 목적을 맞추어 해결하고 그 의미가 퇴색되게 만든다.\n디자인 패턴을 적용하기 전에 항상 생각하자, 전략 패턴처럼 내가 해결해야 할 문제에 대하여 디자인 패턴을 해보자가 아니라, 그 목적에 맞는지, 확실한 설계의 이점이 있는 것인지 생각해보는 것이 먼저이다!\n출처:\nhttps://ko.wikipedia.org/wiki/%EC%A0%84%EB%9E%B5_%ED%8C%A8%ED%84%B4 https://mountainous-grill-560.notion.site/09d333d821b7490187bccd2cdc5f91ef https://victorydntmd.tistory.com/292\n","permalink":"https://HyoseungJeon.github.io/posts/designpattern/behavioral-patterns/strategypattern/","summary":"💡 주로 Business Logic 을 작성하거나 혹은 보게 될 때 방대한 if else 분기와 보일러 플레이트들을 마주하게 된다!! 이는 Debuging 과정을 힘들게 하여.. 결국 지속적으로 안좋은 코드를 만들게 된다.. 하여 간단한 전략 패턴을 배워보고 활용해보자!! 전략 패턴이란? (Strategy Pattern) 정의 전략 패턴(strategy pattern) 또는 정책 패턴(policy pattern)은 실행 중에 알고리즘을 선택할 수 있게 하는 행위 소프트웨어 디자인 패턴이다. 전략 패턴은\n특정한 계열의 알고리즘들을 정의하고 각 알고리즘을 캡슐화하며 이 알고리즘들을 해당 계열 안에서 상호 교체가 가능하게 만든다.","title":"Strategy Pattern"},{"content":" Reflection이란? 정의 Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions. The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control. - Oracle Java Doc\n나만의 정의로는 Runtime 환경에 들어서 load된 Class의 각 속성에 접근할 수 있는 기능이다.\nComplie 환경이 아닌 곳에서 정의되지 않은 Class에 접근하여 constructor, method, field, annotation 을 조작, 사용할 수 있다.\n생각해볼 점 우리는 Java를 객체지향언어(OOP) 라고 학습했었다. 지겹도록 들은 OOP의 특장점으로 캡슐화를 논하였는데 Reflection은 캡슐화를 위반하는 성격을 갖고 있다.\n왜 OOP 언어가 자신의 특징을 위반하는 API spec을 갖고 있을까?\n난 이점이 재밌다고 본다. 그리고 이 Spec 현재에 많은 것들을 가능하게 만들었다!\n결국 정체성과 별개로 Java는 객체의 활용성에 집중을 했다고 개인적으로 생각한다. 간단하게 이 기술을 살펴보면서 생각을 더 넓혀보자!!\n사용 방법 Simple case public static void main(String[] args) { Object obj = new Object(); try { Class cls = obj.getClass(); Constructor[] constructors = cls.getConstructors(); Method[] methods = cls.getMethods(); Field[] fields = cls.getFields(); Arrays.stream(fields).forEach(field -\u0026gt; { Annotation[] annotations = field.getAnnotations(); if (field.isAnnotationPresent(Service.class)) { return; } }); } catch (Exception e) { System.out.println(e); } } 위의 간단한 예제와 같이 객체에서 Class 를 추출 후 해당 속성인 값들을 꺼낼 수 있다.\n이후 각 속성 값들의 cotroll methods 이나 세부 방법은 다른 blog나 문서들을 참고 하는 것이 좋을 것 같다.\n내 사용 예제 프로젝트를 진행하면서 공통으로 Masking 기능을 구현할 일이 생겼다. 프로젝트 내에 따로 Common Soruce가 존재하지 않아 직접 구현해야 하는 상황 이였다.\npublic class MaskingUtil { /** * Dto class 마스킹 처리 * * @param dto * @return 성공여부 */ public static void maskingDto(Object dto) { Field[] fields = dto.getClass().getDeclaredFields(); if (List.class.isInstance(dto)) { List\u0026lt;?\u0026gt; listDto = (List\u0026lt;?\u0026gt;) dto; listDto.forEach(MaskingUtil::maskingDto); } else { for (Field field : fields) { if (!field.isAnnotationPresent(Masking.class) || !field.getType().equals(String.class)) continue; maskingField(field, dto); } } } private static void maskingField(Field field, Object dto) { Masking annotation = field.getAnnotation(Masking.class); field.setAccessible(true); try { field.set(dto, maskingString(MaskingType.valueOf(annotation.type().name()), String.valueOf(field.get(dto)))); } catch (IllegalAccessException e) { throw new RuntimeException(e); } finally { field.setAccessible(false); } } private static String maskingString(MaskingType maskingType, String str) { String result = \u0026#34;\u0026#34;; MaskingEntity maskingEntity = MaskingType.map.get(maskingType.name()); if(\u0026#34;null\u0026#34;.equals(str)) return result; if(Objects.nonNull(maskingEntity) \u0026amp;\u0026amp; StringUtils.hasText(maskingEntity.getRegex())) { result = str.replaceAll(maskingEntity.getRegex(), maskingEntity.getReplacement()); } else { switch (maskingType) { case NAME: { if (str.length() \u0026gt; 2) result = str.replaceAll(\u0026#34;(?\u0026lt;=.{1,2}).(?=.{1,2})\u0026#34;, maskingEntity.getReplacement()); else result = str.replaceAll(\u0026#34;(?\u0026lt;=.{1,2}).(?=.{0,2})\u0026#34;, maskingEntity.getReplacement()); break; } case ADDRESS_BASE: { StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); String[] splitStr = str.split(\u0026#34;\\\\\\\\s\u0026#34;); if (splitStr.length \u0026gt; 2) { sj.add(splitStr[0]).add(splitStr[1].replaceAll(\u0026#34;(?\u0026lt;=.).\u0026#34;, \u0026#34;*\u0026#34;)); Arrays.stream(splitStr).skip(2).forEach(el -\u0026gt; { sj.add(el.replaceAll(\u0026#34;.\u0026#34;, \u0026#34;*\u0026#34;)); }); } else { result = str; } break; } } } return result; } Process를 간단히 요약하면\nObject를 1개 받아 Field값들을 읽는다. Masking Annotation(Custom Annotation) 존재 여부 확인 후 Masking 처리를 시도한다. 따로 정의한 MaskingType enum class 을 참조하여 regex pattern을 받아 replaceAll 처리한다. 단, 정의된 pattern이 없을 시 Case에 따라 따로 Masking 처리를 한다. 세세한 내용들은 source 단을 확인한다.\n추가적으로 https://github.com/HyoseungJeon/JPA 에 내용이 작성되어있으니 참고한다.\n실제로 완벽한 source는 아니다. Collection Type을 List만 처리해 놓은 부분과 내부 Field 내의 Collection 처리 부분 custom Masking 처리 부분의 분리 등등 정리하지 못한 내용이 많다. 차차 내 나름대로의 version Update가 필요해 보인다..\n하지만 내가 집중하고 싶은 부분은 위 방법을 통해서 Masking 과정이 굉장히 간편해졌다.\n실제 response에 담을 Dto 객체에 Masking이 필요한 Field위에 annotation을 입력 후, method에 넘기기만 한다면 Masking 처리가 된다. 프로젝트 내에서는 문제 없이 잘 활용하였다. 위 code를 작성한 프로젝트 이전에는 이미 만들어져 있는 Masking Framwork을 따라 쉽게 작성하여 내부 logic을 파악하지 못하여 내 주관대로 작성한 부분이 있어 아쉽지만 위와 같은 과정을 거쳤을 거라고 생각한다.\nReflectionUtils Spring에서 제공하는 Reflection API를 활용하기 위한 interface Util class를 발견했다!새로 투입된 프로젝트 내의 Masking Source를 탐험하던 중 해당 Lib를 보게 되었다…!😍\n기존 Reflection을 raw 방식으로 활용할 때에는 Exception 처리나 내가 예상하지 못하는 error 들을 발견하거나 방지하기가 어려웠다.. 😢 근데 해당 Lib 내용을 살펴보니 발견하지 못했던 issue들을 처리한 code를 볼 수 있었다! Spring이 Reflection을 활용하다 보니 당연하게도 안정적으로 제공하는 Util이 있을 것인데.. 생각을 못해봤던 것 같다..! 구글링도 좋지만 확실히 source 단에서도 관련 lib을 검색해보는 것도 필요한 것 같다!\npublic static void doWithFields(Class\u0026lt;?\u0026gt; clazz, FieldCallback fc, @Nullable FieldFilter ff) { Class\u0026lt;?\u0026gt; targetClass = clazz; do { Field[] fields = getDeclaredFields(targetClass); Field[] var5 = fields; int var6 = fields.length; for(int var7 = 0; var7 \u0026lt; var6; ++var7) { Field field = var5[var7]; if (ff == null || ff.matches(field)) { try { fc.doWith(field); } catch (IllegalAccessException var10) { throw new IllegalStateException(\u0026#34;Not allowed to access field \u0026#39;\u0026#34; + field.getName() + \u0026#34;\u0026#39;: \u0026#34; + var10); } } } targetClass = targetClass.getSuperclass(); } while(targetClass != null \u0026amp;\u0026amp; targetClass != Object.class); } 특히 fields들을 조회하는 method를 보면 targetClass = targetClass.getSuperclass(); 부분이 있다! extend하는 경우는 생각하지 못했었는데.. 이러한 처리 부분이 있는 걸 보고 좀 쇼킹했다!\n내 생각 장점 정확히 정의된 Class를 입력 받는 것이 아닌, 추상화 상태의 Class를 통해 조작을 하니 넓은 범위를 커버 가능한 method를 작성할 수 있다는 게 큰 장점인 것 같다. 실제로 Spring이 구현될 수 있었던 핵심 spec 아닐까..?\n단점 OOP의 원칙인 캡슐화를 부숴버린다!! 생각보다 심각한 문제라고 생각이 들긴 하는데 만약 해당 method가 정확하게 guide 된 것에 따라가지 않는다면 사용자는 확인하기 어려운 이슈가 발생할 수 있을 것 같다!\n또한 연관 검색어로 항상 성능 이슈가 나온다! 그 원인은 Compiler의 최적화 단계를 거치지 않기 때문이라고 한다. 해서 무거운 logic이나 무분별하게 도입하는 거는 지양해야 할 것 같다.\nhttps://lob-dev.tistory.com/entry/Java의-Reflection-API\n정리 Relection은 내 눈에는 보이지 않지만 수많은 Lib 내에서 나의 개발을 유연하게 돕는 역할로 매우 많이 쓰이는 API 이다. 그 기능을 이용하여 실제로 개발을 해보니 정말로 강력한 기능이라는 느낌이 들었다. 항상 Java 개발을 하면서 “아 이런 부분은 field로 조작해서 할 수 있지 않을까?” 라고 생각해 왔던 것들을 프로젝트 내에서 실제로 구현해보고, 해당 방식을 통하여 기존의 source의 길이가 어마어마하게 줄어들고, 유지보수도 매우 쉬어지는 것을 경험했다.\n단순히 내가 구현을 해보며 느낀 장점 뿐만 아니라 실제로 프로젝트에 사용되는 주요 FrameWork들의 구현 방법에 대하여 알게 되어 조금 더 FrameWork의 구조를 파악하고 또 debugging 할 수 있는 영역이 늘어난 점도 매우 좋은 것 같다. 더욱 넓은 시각을 통해서 단순히 낮은 soruce level이 아닌 구조 전체를 통해서 문제를 파악하는 능력이 큰 것 같다!\n항상 생각하는 거지만, 그냥 편의를 누리는 것은 개발자에게 가장 치명적인 독인 것 같다.. 그냥 납득하지 말자!\n참조:\nhttps://docs.oracle.com/javase/8/docs/technotes/guides/reflection/index.html\nhttps://lob-dev.tistory.com/entry/Java의-Reflection-API\nhttps://gyrfalcon.tistory.com/entry/Java-Reflection\n","permalink":"https://HyoseungJeon.github.io/posts/java/reflection/","summary":"Reflection이란? 정의 Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions. The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.","title":"Reflection"},{"content":" Generic이란? Oracle Java Docs에서는 A generic type is a generic class or interface that is parameterized over types. 라고 설명하고 있다.\nType을 매개 변수로 받는 class, interface 라고 해석이 되는 듯하다..? 😂\n즉, class를 정의할 때에 바깥에서 class 내부 field의 type를 정의할 수 있는 방법이다.\n하여 객체를 선언할 때 class는 같지만 field Type이 다른 형태로 만들 수 있다. 우리가 가장 익숙한 곳은 아마 Collection Lib 를 사용할 때 일거다.\n사용법 문법 \u0026lt;WORD\u0026gt; 화살 괄호 쌍 안에 class 내에서 사용할 type의 가상 keyWord를 선언 후 사용하는 방식이다. 일반적인 변수 선언과 크게 다르지 않다. 이를 type 변수라고 부른다.\n/** * Generic version of the Box class. * @param \u0026lt;T\u0026gt; the type of the value being boxed */ public class Box\u0026lt;T\u0026gt; { // T stands for \u0026#34;Type\u0026#34; private T t; public void set(T t) { this.t = t; } public T get() { return t; } } public class Main { public static void main (String[] args) { Box\u0026lt;String\u0026gt; box1 = new Box\u0026lt;\u0026gt;(); Box\u0026lt;Integer\u0026gt; box2 = new Box\u0026lt;\u0026gt;(); box1.set(\u0026#34;box 1\u0026#34;); box2.set(2); System.out.prlntln(box1.get()); System.out.prlntln(box2.get()); } } 명명 규칙 매개변수 이름은 자유롭게 선언할 수 있으나 Java Doc에서 권장하는 일반적 규칙이 존재합니다.\nE - Element K - 키 N - 숫자 T - Type V - Value S, U, V… - 2nd, 3rd, 4th… 다른 Lib source 본다면 대체적으로 해당 규칙을 따르는 것을 알 수 있다. 해당 규칙을 통하여 어떠한 유형 값을 받는지도 자연스럽게 파악할 수 있다!\n주의사항 Generic Type Class 선언 시 해당 type은 원시형은 사용할 수 없다. 실제로 동작 시 참조 형식으로 동작하게 됨으로 자연스럽게 wrapper 형태의 참조형 type을 사용해야 한다.\n복수 type Parameter type 변수는 단일이 아닌 복수로 사용할 수 있다. 문법은 단순히 괄호 안에 , 로 다음 변수를 정의하면 끝이다. 사용법 또한 같다.\npublic interface Pair\u0026lt;K, V\u0026gt; { public K getKey(); public V getValue(); } public class OrderedPair\u0026lt;K, V\u0026gt; implements Pair\u0026lt;K, V\u0026gt; { private K key; private V value; public OrderedPair(K key, V value) { this.key = key; this.value = value; } public K getKey()\t{ return key; } public V getValue() { return value; } } Pair\u0026lt;String, Integer\u0026gt; p1 = new OrderedPair\u0026lt;String, Integer\u0026gt;(\u0026#34;Even\u0026#34;, 8); Pair\u0026lt;String, String\u0026gt; p2 = new OrderedPair\u0026lt;String, String\u0026gt;(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;); Parameterized Types value 변수 정의 시 다른 class를 type으로 정의할 수 있듯이 type 변수로 다른 Generic class를 넣을 수 있다!\nOrderedPair\u0026lt;String, **Box\u0026lt;Integer\u0026gt;**\u0026gt; p = new OrderedPair\u0026lt;\u0026gt;(\u0026#34;primes\u0026#34;, new Box\u0026lt;Integer\u0026gt;(...)); 장점 Compile 단계에서 type 관련한 문제 발생을 미리 방지할 수 있다.\n기존 Generic 기능이 없을 때에는 일반적 최상위 Class인 Object type을 정의하여 필요에 따라 type casting을 하여 기능을 구현하였다. 하지만 이는 자원 소모가 심하고 또 개발자가 예상치 못한 error 발생 시킬 가능성이 높았다.\ntype Casting 자원 소비가 없다.\ncompile 단계에서 선언한 type을 미리 mapping 하여 치환 후 build 함으로 인해 과거 Object 로 구현하던 때의 casting 자원도 아낄 수 있게 되어 성능에도 큰 이점을 가져왔다.\nETC Generic method, type 범위 정의, wild card 문법 등 나머지 Generic 관련한 추가적인 정보는 참조 blog들에 내용 정리가 잘 되어있다..!\n정리 내가 사용하는 method나 class에 가변적인 type이 들어가고, 선언하는 외부에서 그 type을 정할 수 있다는 점은 매우 매력적인 장점으로 보인다. 실제로 lib안의 generic 사용 예제들을 보면 개발자에게 많은 편의를 제공하고, 추가적으로 많은 에러를 자연스럽게 피할 수 있게 도와준다. 해당 기술에 대해 알게 된 점은 이 기술을 활용하는 법 보다는 이를 통해 우리가 Java 언어 환경 속에서 많은 error와 낭비를 피해왔구나 라는 것을 느꼈다. 특히 generic 은 처음 마주했을 때에는 조금 난해했고 실제로 사용할 때에도 불편하다는 생각이 들었다. 하지만 이에 대해 배우고 그 장점을 다시 쳐다보았을 때 실제로 이를 통해 누렸던 장점들이 정말 많이 와닿았다.\n하지만 실제로 이를 개발에서 활용할 방법에 대해서는 아직 해메이고 있다. 실제로 Masking 공통을 구현할 때에 처리할 class를 type 변수로 받아 처리하는 등의 시도를 해보았는데, 결국은 reflection 기술을 활용해 작업을 하여 의미가 없었다. 물론 이는 내 지식의 한계점 때문에 그런 걸 수도 있지만 본 기술의 특성 상 장점도 명확하지만 활용할 수 있는 점도 명확하다고 느꼈다. 자료들을 많이 찾아 보았지만 실제로 효과적인 예는 잘 보지 못했다.. (🤷‍♂️ 검색 실력의 한계일 수도 있다..) 실제 Project에서 활용할 만한 예는 그다지 였다.. 하지만 내가 직접 사용하여 개발을 하지 않아도 언어가 제공하는 기술의 장점에 대한 것을 깨우친 것 만으로도 아주 만족스럽고 또 재밌던 Java spec 였다!\n출처 :\nhttps://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%9C%EB%84%A4%EB%A6%ADGenerics-%EA%B0%9C%EB%85%90-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%B3%B5%ED%95%98%EA%B8%B0\nJAVA] - 제네릭(Generic)의 이해\nGeneric Types (The Java™ Tutorials \u0026gt; Learning the Java Language \u0026gt; Generics (Updated))\n","permalink":"https://HyoseungJeon.github.io/posts/java/generic/","summary":"Generic이란? Oracle Java Docs에서는 A generic type is a generic class or interface that is parameterized over types. 라고 설명하고 있다.\nType을 매개 변수로 받는 class, interface 라고 해석이 되는 듯하다..? 😂\n즉, class를 정의할 때에 바깥에서 class 내부 field의 type를 정의할 수 있는 방법이다.\n하여 객체를 선언할 때 class는 같지만 field Type이 다른 형태로 만들 수 있다. 우리가 가장 익숙한 곳은 아마 Collection Lib 를 사용할 때 일거다.","title":"Generic"},{"content":" 알게된 계기 이전 포스팅에서 Java의 Future 관련한 내용을 작성했었다. 그 내용을 요약하면 메일, 문자 발송 시스템의 처리 시간이 너무 불필요하게 길다는 것 이였다. 그 문제의 원인은 결국 blocking 발생 이였다. 하지만 Future 를 통하여 구현된 부분은 request 송신에 공통으로 사용된 부분 이였고 이와 별개로 내부 process Logic내에서 필요 없는 cost를 통해 지연이 발생하였고 하여 이를 병렬 처리하는 것이 필요했다. 하여 내용을 찾아보던 중 Spring에서 비동기 method 기능을 지원한다는 것을 발견하였다.\n@Async란? Async는 Spring 에서 제공하는 비동기 method 지원 annotation 으로 Java의 Thread pool을 이용하여 해당하는 method 병렬 처리를 가능하게 한다.\n기존의 Java Exceutor를 사용한 병렬 처리 구현 방법보다 간편하고, annotation을 통해서 쉽게 사용할 수 있다는 장점이 있다. 하지만 Spring의 AOP 방식을 이용하여 구현된 기능으로 그 한계가 같다는 점이 있다.\n사용 방법 기본 사용 방법은 Spring Application class에 @EnableAsync를 달아 Async 기능 사용을 열어주고, 비동기로 사용할 method에 @Async annotation을 달아주면 끝이다.\n하지만 이는 SimpleAsyncTaskExecutor를 사용하게 됨으로 Thread를 따로 관리할 수는 없고 단순히 생성만 하여 사용하게 된다.\n@EnableAsync @SpringBootApplication public class DemoApplication {public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } /* ============================================== */ @Service @RequiredArgsConstructor public class TestService { @Async(\u0026#34;sampleExecutor\u0026#34;) public void testAsync(String message){ for(int i = 1; i \u0026lt;= 3; i++){ System.out.println(message + \u0026#34;비동기 : \u0026#34; + i); } } } 때문에 실제로는 Custom Thread Pool을 생성하여 관리를 하게 한다.\n@Configuration @EnableAsync public class AsyncConfig { private int CORE_POOL_SIZE = 3; private int MAX_POOL_SIZE = 10; private int QUEUE_CAPACITY = 100_000; @Bean(name = \u0026#34;sampleExecutor\u0026#34;) public Executor threadPoolTaskExecutor(){ ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); taskExecutor.setCorePoolSize( CORE_POOL_SIZE ); taskExecutor.setMaxPoolSize( MAX_POOL_SIZE ); taskExecutor.setQueueCapacity( QUEUE_CAPACITY ); taskExecutor.setTaskDecorator( new CustomDecorator() ); // 데코레이터 적용 taskExecutor.setThreadNamePrefix( \u0026#34;Executor-\u0026#34; ); taskExecutor.setRejectedExecutionHandler( new ThreadPoolExecutor.CallerRunsPolicy() ); return taskExecutor; } 실제로 Thread Pool 통하여 관리하는 방식으로 사용할 때에는 Application 단의 @EnableAsync annotation을 지우고 Configuration 단에 Spring의 Async을 수행할 Thread Pool 정의 Config Class를 생성한다. 하고 해당 Annotation을 Class에 선언한다.\n후에 실제로 Executor을 생성하여 정의 하게 되는데 그 옵션은 아래와 같다.\nTaskExecutor Options corePoolSize\n기본적으로 활성화 된 thread의 개수 (Defalut : 1)\nmaxPoolSize\nQueue Capacity 이상의 요청이 들어올 경우, Thread Pool에 생성 가능한 최대 Thread 수 (Default : Integer.MAX_VALUE)\nqueueCapacity\nCorePoolSize 이상의 요청이 들어올 경우, Linked Blocking Queue 라는 공간에 task를 대기 시킨다, 해당 Quque 공간의 Capa (Default : MAX_VALUE)\ntaskDecorator\n해당 task를 Thread에 할당하기 전 작업을 Custom 정의할 수 있는 class, decorate method override를 통하여 해당 내용 작성\n→ 위 예제에서는 requestContext 내 정보를 복사\nthreadNamePrefix\n할당된 thread의 Prefix name 정의 (ex : “SAMPLE-SERVICE- “)\nrejectedExecutionHandler\n거부된 작업을 이후 Handling Policy를 정의\nAbortPolicy : 작업이 거부되면 RejectedExecutionException을 던진다. CallerRunsPolicy : Async 메소드를 불렀던 메인 스레드에서 거부된 작업을 실행한다. DiscardOldestPolicy : 큐에서 가장 오래된 task를 제거하고 실행시킨다. DiscardPolicy : Reject된 Task에 대해 어떠한 작업도 진행하지 않는다. 예외처리 thread와 관련하여 capacity 초과로 인한 Error와 같은 Exception 들을 처리 해놓는 부분이 필수적으로 필요하다.\n해당 예외로 인하여 작업이 실행되지 않고, log나 해당 Data 적재도 제대로 되지 않을 경우가 발생할 수 있다.\n@Configuration @EnableAsync public class AsyncConfig implements AsyncConfigurer {// 추가 private int CORE_POOL_SIZE = 3; //~~~~ //override method @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() { return new AsyncExceptionHandler();// 추가 } } @Slf4j public class AsyncExceptionHandler implements AsyncUncaughtExceptionHandler { @Override public void handleUncaughtException(Throwable ex, Method method, Object... params) { log.error( ex.getMessage(), ex ); } } Config class에 AsyncConfigurer class를 impl, getAsyncUncaughtExceptionHandler 를 정의하여 Exception Handler를 작성한다.\n위와 같은 Handler를 따로 정의하여 관리하는 방법이 효과적일 것 같다.\nCheckPoint 접근 제한자는 public만 가능하다.\n본 기능은 Spring AOP에 의해 구현되어 Proxy 객체를 기반으로 수행 됨으로 접근 권한이 public 하여야 한다.\n자가 호출 형태는 적용되지 않는다.\n실제로 error를 터트리진 않지만 할당한 ThreadPool 통해 병렬 처리 되진 않는다.\n이도 역시 AOP 때문이다.\nrequest Context 사용이 불가능 하다.\n새로운 Thread를 생성하기 때문에 기존 request 정보가 포함된 Context는 존재하지 않는다. 때문에 필요하다면 taskDecorator 를 통한 context copy 과정이 필요하다.\nException\n새로운 Thread 임으로 호출한 thread 까지 Exception이 전달되지 않는다. 하지만 return 값이 존재하는 형태라면 별도로 처리가 가능하다.\n느낀점 Java의 병렬 programing 관련하여 여러가지 방식들을 보게 되었는데 확실히 Spring이 상대적으로 복잡했던 Thread Pool 관련한 병렬 프로그래밍 방식들을 쉽게 처리할 수 있게 구현해 놓은 것 같다. 상대적으로 복잡한 설계가 필요 없었고 Config, annotataion 두개의 source로 실제 프로젝트에 굉장히 쉽게 병렬 처리를 적용했다. 실제로 해당 단위의 처리 시간이 16초에서 6초 가량으로 많이 줄었다. 다음 번엔 함께 사용했던 CompletableFuture 관련한 글을 쓰겠다!\n출처:\nAsync (Spring Framework 6.0.11 API)\n[Spring] @Async 비동기 멀티스레드 사용법\n","permalink":"https://HyoseungJeon.github.io/posts/spring/async/","summary":"알게된 계기 이전 포스팅에서 Java의 Future 관련한 내용을 작성했었다. 그 내용을 요약하면 메일, 문자 발송 시스템의 처리 시간이 너무 불필요하게 길다는 것 이였다. 그 문제의 원인은 결국 blocking 발생 이였다. 하지만 Future 를 통하여 구현된 부분은 request 송신에 공통으로 사용된 부분 이였고 이와 별개로 내부 process Logic내에서 필요 없는 cost를 통해 지연이 발생하였고 하여 이를 병렬 처리하는 것이 필요했다. 하여 내용을 찾아보던 중 Spring에서 비동기 method 기능을 지원한다는 것을 발견하였다.","title":"Async"},{"content":" 개발 블로그를 처음으로 개설했다..!\n사실 이전부터 블로그를 만들어 보려고 했지만 그 필요성을 잘 느끼지 못하여.. 만들지 않았다..! 무언가 다른 개발자들에게 정확하지 않은 정보를 전달하게 되거나 혹은 그냥 포트폴리오를 보여주기 위한 도구 같다고만 느꼈다..\n근데 실제 취업 후 여러 프로젝트를 진행해보며 여러 장애들을 겪고 또 야근을 하며 개발을 해보며 지내본 결과.. 내 경험을 모두 머리속에 기억하기는 정말로 어렵다.. 기존에는 노트나 메모지에 적어두고 기록해 왔었는데 실제로 해당 내용을 다시 찾을 때에는 너무 시간이 오래 걸리고 때때로 급한 마음에 마구마구 갈겨 쓴 글씨 때문에 나 조차도 못알아보는 기록들이 너무 많았다 ㅠ\u0026hellip;\n해서!! 이제부터는 내 블로그를 통해 내가 기억해야 할 경험들을 기록해두려고 한다..! 화이팅\u0026hellip;!!!\n","permalink":"https://HyoseungJeon.github.io/posts/%EC%9D%BC%EA%B8%B0%EC%9E%A5/23-07-18/","summary":"개발 블로그를 처음으로 개설했다..!\n사실 이전부터 블로그를 만들어 보려고 했지만 그 필요성을 잘 느끼지 못하여.. 만들지 않았다..! 무언가 다른 개발자들에게 정확하지 않은 정보를 전달하게 되거나 혹은 그냥 포트폴리오를 보여주기 위한 도구 같다고만 느꼈다..\n근데 실제 취업 후 여러 프로젝트를 진행해보며 여러 장애들을 겪고 또 야근을 하며 개발을 해보며 지내본 결과.. 내 경험을 모두 머리속에 기억하기는 정말로 어렵다.. 기존에는 노트나 메모지에 적어두고 기록해 왔었는데 실제로 해당 내용을 다시 찾을 때에는 너무 시간이 오래 걸리고 때때로 급한 마음에 마구마구 갈겨 쓴 글씨 때문에 나 조차도 못알아보는 기록들이 너무 많았다 ㅠ\u0026hellip;","title":"23.07.18"},{"content":" dateObj.setDate(dayValue) var theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(24); // 1962-07-24 theBigDay.setDate(22); // 1962-08-22 해당 Date 객체의 날짜(day)를 설정하는 함수\n입력된 dayValue 값으로 날짜를 변경 한다.\n별로 특이해 보이지 않지만 변경 이라는 부분 때문에 보이지 않는 에러가 발생한 경우가 있다.\n위 기능을 통하여 js 내에서 날짜를 변경 하게 되는데\nvar theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(32); // 1962-08-01 theBigDay.setDate(0); // 1962-07-31 예제와 같이 날짜 범위를 자동으로 계산해 Date를 set 한다.\nvar theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(threeDaysAgo.getDate() + 3); // 1962-07-10 theBigDay.setDate(threeDaysAgo.getDate() - 3); // 1962-07-07 해서 Date를 더하거나 빼는 경우에는 자신의 Date 값을 참조하여 다시 setDate 하는 방식을 사용한다.\n하지만!! 문제는 자신의 값을 참조하는 부분에서 오류가 발생한다.\n/** * 시작날짜, 종료날짜 세팅 * * @param { Number } dayNum 날짜 수 * @returns { Date } { startDate, endDate } */ export function initRangeDate(dayNum) { const baseDate = 2 const startDate = new Date() const endDate = new Date() startDate.setDate(startDate.getDate() + baseDate) /* 날짜 adding 관련 이슈사항 */ // 1. 다른 Date 객체 참조 endDate.setDate(startDate.getDate() + dayNum) // 2. 자신 Date 참조 endDate.setDate(endDate.getDate() + baseDate + dayNum) /* setDate는 param의 숫자 그대로 setting 때문에 다른 객체 참고시 해당 객체의 값 변화에 의하여 의도하지 않은 날짜로 set 가능성 생김 때문에 무조건 자신을 참고하는 방식으로 사용 소스에 기준이 되는 전역값 분리 및 활용 */ return { startDate, endDate } } 위 예제는 현재 날짜 기준, param1 만큼 날짜의 범위를 가진 두 데이터 객체를 반환하는 method 이다.\n위 소스에서 1. 부분을 본다면 나는\n종료 일자를 시작 일자의 param1 값 만큼 더하여 종료 일자를 계산할 수 있다고 생각했다.\n하지만 실제로 소스에서는 문제가 발생한다!\nstartDate.getDate() + baseDate 의 값이 다음달의 날짜로 넘어가지 않는다면 문제가 발생하지 않지만, 넘어 간다면? n달의 오차가 생기게 된다!\n해서 프로젝트 내에서는 실제로 달의 마지막 2일 전, baseDate만큼의 차이가 날 때 문제가 발견되었다.. 테스트 기간에는 다행히..? 중순 쯤이라 문제를 발견하지 못하였다.. 내 잘못이다..\n실제로 new Date().getDate() 의 return 값은 날짜이기 때문에 변하지 않은 자신의 값을 참조하여 setDate를 할 때에는 문제가 발생하지 않는다.\n하지만 이외의 객체를 참고한다면 위와 같이 예상치 못한 값 변화를 초래할 수 있다..!\n결론은 굉장히 단순하지만\n// 1. 다른 Date 객체 참조 endDate.setDate(startDate.getDate() + dayNum) // 2. 자신 Date 참조 endDate.setDate(endDate.getDate() + baseDate + dayNum) js 내에선 Date 값을 조절할 때에는 무조건 자신의 객체를 참고하여 setting 되어야 한다는 사실이다.\n아무래도 java나 C++ 언어에 익숙했던 경험 때문인지 1. 와 같은 소스가 문제가 없을 것이라고 판단했던 것 같다.. 혹은 해당 setDate를 addDate 라고 나도 모르게 인식하고 있었던 것 같다.\n항상 정확한 사용 방법을 따라 개발해야 한다..!\n참조\nDate.prototype.setDate() - JavaScript | MDN\n","permalink":"https://HyoseungJeon.github.io/posts/javascript/date/setdate/","summary":"dateObj.setDate(dayValue) var theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(24); // 1962-07-24 theBigDay.setDate(22); // 1962-08-22 해당 Date 객체의 날짜(day)를 설정하는 함수\n입력된 dayValue 값으로 날짜를 변경 한다.\n별로 특이해 보이지 않지만 변경 이라는 부분 때문에 보이지 않는 에러가 발생한 경우가 있다.\n위 기능을 통하여 js 내에서 날짜를 변경 하게 되는데\nvar theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(32); // 1962-08-01 theBigDay.setDate(0); // 1962-07-31 예제와 같이 날짜 범위를 자동으로 계산해 Date를 set 한다.","title":"setDate"},{"content":" 프로젝트를 옮기고 Spring 프로젝트를 세팅 하는 중 build error가 발생하였다!\n그 중 익숙하지 않은 build error가 있었는데\nThymeleaf 관련 Directory를 추적하지 못하여 file not found Error가 나왔다..!\n알고 보니 따로 Template Engine을 설정하여 Project를 생성한 경우가 아닐 시 자동으로 추적 경로가 등록되지 않는 경우 같더라..\n내용을 추가적으로 찾아보니 Maven의 경우 따로 실행 Configurations 내 Working Directory 잡아주어야 한다는 내용을 찾았다..!\nThymeleaf 프로젝트 build 시 Maven 관리 도구를 사용 중이고 따로 importing 한 프로젝트 라면 /WEB-INF/\nDirectory를 자동으로 추적하지 못하는 경우가 발생할 수 있다!!\n때문에 해당 프로젝트 실행 환경의 Working directory 내에\n$MODULE_WORKING_DIR$\n경로를 추가하여야 한다.\n참조\nhttps://stackoverflow.com/questions/33459740/error-no-url-for-servletcontext-resource-when-running-spring-integrated-test\n","permalink":"https://HyoseungJeon.github.io/posts/intellij/thymeleaf/","summary":"프로젝트를 옮기고 Spring 프로젝트를 세팅 하는 중 build error가 발생하였다!\n그 중 익숙하지 않은 build error가 있었는데\nThymeleaf 관련 Directory를 추적하지 못하여 file not found Error가 나왔다..!\n알고 보니 따로 Template Engine을 설정하여 Project를 생성한 경우가 아닐 시 자동으로 추적 경로가 등록되지 않는 경우 같더라..\n내용을 추가적으로 찾아보니 Maven의 경우 따로 실행 Configurations 내 Working Directory 잡아주어야 한다는 내용을 찾았다..!\nThymeleaf 프로젝트 build 시 Maven 관리 도구를 사용 중이고 따로 importing 한 프로젝트 라면 /WEB-INF/","title":"Thymeleaf"},{"content":" Future란? Java 1.5에 공개된 비동기 process 처리를 지원하는 interface Class 이다.\n비동기 방식을 지원하기 위해 당연하게도 mulitThread 방식을 활용하여 해당 기능을 지원하고 있다. 기존의 Thread 직접 선언 및 관리 방식과 다르게 interface를 활용하여 비동기를 구현할 수 있어 안정적인 비동기 구현 방법이다.\n해당 비동기 process를 호출 thread에서 사용 가능하다.\n단, 해당 값 조회를 시도할 시 blocking 상태로 변화하여 지연이 발생할 수 있다.\nMethods V get(), get(Long time, TimeUnit unit)\n실행 결과 값을 조회하는 method\n호출 시 해당 작업이 완료 될 때 까지 blocking 상태로 전환된다.\n매개변수 2개를 받을 시 해당 값 만큼 TimeOut 시간이 설정된다.\n작업이 지연될 경우, TimeoutException을 발생시킨다.\nboolean isDone()\n현재 작업의 완료 상태를 체크한다.\n어떠한 경우든 작업이 실행 중인 상태가 아니라면 true를 반환한다.\nboolean cancel(boolean mayInterruptIfRunning)\n현재 실행 중인 작업을 중단 시킨다.\nmayInterruptIfRunning 값이 true인 경우 해당 작업의 Thread 중단되어야 하는 경우 중단 시킨다. 그렇지 않은 경우에는 작업을 완료할 수 있다.\nFuture lib:\nif the thread executing this task should be interrupted\notherwise, in-progress tasks are allowed to complete\n정상 취소 성공 시 true return 한다.\nboolean isCancelled()\ncancel method를 통하여 정상 cancel 일 시 true를 return 한다.\n예제 소스 //ExecutorService 초기화 ExecutorService executor = Executors.newSingleThreadExecutor(); //Callable Task 생성 Callable\u0026lt;String\u0026gt; callableTask = () -\u0026gt; { System.out.println(LocalTime.now() + \u0026#34; Task Start\u0026#34;); Thread.sleep(1000L); return \u0026#34;Task Result\u0026#34;; }; //submit() 메서드로 Task 실행 Future\u0026lt;String\u0026gt; future = executor.submit(callableTask); System.out.println(LocalTime.now() + \u0026#34; Waiting the task done\u0026#34;); System.out.println(\u0026#34;isDone 1 = \u0026#34; + future.isDone()); String result = future.get(); //Task 결과 대기 System.out.println(\u0026#34;isDone 2 = \u0026#34; + future.isDone()); System.out.println(LocalTime.now() + \u0026#34; future.get() = \u0026#34; + result); //실행 결과 23:09:32.917 Waiting the task done isDone 1 = false 23:09:32.918 Task Start isDone 2 = true 23:09:33.922 future.get() = Task Result 내 경험 23년 3월 쯔음에 특정 프로세스를 excel file 단위로 처리하는 작업을 진행하였다. 업무 자체로는 문제가 없었는데 해당 프로세스는 완료 후 sms/email을 발송하는 logic이 있었다.\n때문에 bulk 단위 작업 시 해당 api 응답이 1분 가까이 소요되는 상태였다. 해당 부분이 issue로 올라왔다.\n실제 지연이 크게 발생한 이유는 DB Data 조작 시간 소요는 크지 않았는데 sms/email 발송 부분에서 30초 가량의 시간을 잡아먹고 있었다.\n내부 소스는 Future interface를 사용하고 있었는데 실제로 로직에서는 비동기로 동작시키고 바로 get을 해버리니 동기로 동작하고 있었다 ㅜ.. 🤔 해서 get을 제거하고 response를 받는 시점에 기존 get 로직을 넣었다! 기존 get 로직은 단순히 response Logging 목적의 소스라서 이관을 해도 문제가 없었다..\n하여 해당 로직을 개선하니 기존 30sec에서 12sec로 현저하게 시간이 줄어들었다!\n하지만 남은 12초는.. thymeleaf의 html rendering 방식을 사용하여 email을 발송하고 있었기에.. cost를 줄일 수가 없었다.. 🤦‍♂️ 그래도 시간은 1/3 수준으로 개선되었으니!! 만족이다!!\n확실히 sync/async에 관련된 작업을 할 때에는 확실하게 동작 테스트를 해보는게 중요한 것 같다. 누가 알았겠는가.. response Logging Logic 하나 때문에 18초의 시간이 소요되고 있었는지..\n참조: Java - Future Interface 비동기적 연산 작업을 위한 인터페이스\n","permalink":"https://HyoseungJeon.github.io/posts/java/future/","summary":"Future란? Java 1.5에 공개된 비동기 process 처리를 지원하는 interface Class 이다.\n비동기 방식을 지원하기 위해 당연하게도 mulitThread 방식을 활용하여 해당 기능을 지원하고 있다. 기존의 Thread 직접 선언 및 관리 방식과 다르게 interface를 활용하여 비동기를 구현할 수 있어 안정적인 비동기 구현 방법이다.\n해당 비동기 process를 호출 thread에서 사용 가능하다.\n단, 해당 값 조회를 시도할 시 blocking 상태로 변화하여 지연이 발생할 수 있다.\nMethods V get(), get(Long time, TimeUnit unit)\n실행 결과 값을 조회하는 method","title":"Future"},{"content":"","permalink":"https://HyoseungJeon.github.io/spring/","summary":"","title":"Spring"},{"content":"","permalink":"https://HyoseungJeon.github.io/ch/","summary":"","title":"첫 포스트"},{"content":" 설명 Spring 2.0 부터 추가된 기능으로 Request 인입 후 thread 생성 된 시점부터 전 구간에서 HttpServletRequest에 접근을 가능하게 해주는 기능이다.\n기존 Controller 단에 parameter 형식으로 선언 후 참고하던 방식과 다르게 위 객체를 통하여 request에 접근이 가능하다.\n예제 소스 :\n@GetMapping(\u0026#34;hello\u0026#34;) public void before(HttpServletRequest request) { sampleService.hello(request); } @GetMapping(\u0026#34;hello\u0026#34;) public void after() { HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest(); sampleService.hello(request); } 동작 원리 Request 인입 시 Spring 내 ThreadLocal 이라는 공간에 값을 저장하는 방식이다. 이름에서도 유추할 수 있듯이 단일 Thread내에 저장되는 방식으로 이외 Thread에서는 값 참조가 불가능하게 된다. 단, Inheritable = true 옵션값을 통하여 중첩 Thread 내에서 부모 Thread 값 참조가 가능하다. 자세한 내용은 ref site 참고\n장점 1차적인 장점으로는 request 객체를 참조하기 위해 매번 parameter에 선언한 필요가 없다는 것이다. 불필요한 코드 작성을 줄이고 가독성을 높여준다.\n전 구간에서 참조 가능하다. Controller에서 request 정보를 받아 다른 Service 내리거나 하는 작업이 생략된다.\n→ 위 점을 활용하여 request 정보를 활용하는 공통 Util class를 구현한다면 베스트 인 것 같다!!\n내 활용 방식 진행하던 프로젝트 내에서 Exception 발생 시 공통으로 인입 된 값을 logging 하는 방식에 활용했다. 기존 APM을 통하여 body 내 값이나 query 방식의 값들을 최적화된 log 값들과 함께 같이 세팅하여 기록하도록 구현하였다.\nrefs: RequestContextHolder (Spring Framework 6.0.11 API)\nRequestContextHolder\nSpring RequestContextHolder - 어디서든 HttpServletReqeust 사용하기\nSpring RequestContextHolder\n","permalink":"https://HyoseungJeon.github.io/posts/spring/requestcontextholder/","summary":"설명 Spring 2.0 부터 추가된 기능으로 Request 인입 후 thread 생성 된 시점부터 전 구간에서 HttpServletRequest에 접근을 가능하게 해주는 기능이다.\n기존 Controller 단에 parameter 형식으로 선언 후 참고하던 방식과 다르게 위 객체를 통하여 request에 접근이 가능하다.\n예제 소스 :\n@GetMapping(\u0026#34;hello\u0026#34;) public void before(HttpServletRequest request) { sampleService.hello(request); } @GetMapping(\u0026#34;hello\u0026#34;) public void after() { HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest(); sampleService.hello(request); } 동작 원리 Request 인입 시 Spring 내 ThreadLocal 이라는 공간에 값을 저장하는 방식이다.","title":"RequestContextHolder"}]