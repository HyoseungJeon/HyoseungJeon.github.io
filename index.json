[{"content":" Nice본인인증 이슈 문제 issue로 올라온 사항은 Android, IOS App 단에서 본인인증이 제대로 실행되지 않는다는 사항이였다! 본인인증 popup에서 인증을 완료 시 정상적으로 처리되지 않고 에러페이지로 이동하는 상황 이였다.\n원인 문제의 원인은 본인인증 Callback method가 실행되지 않는 상황이였다!!\n현재 구현된 프로젝트는 하이브리드 App방식으로 Android, IOS 각 OS의 Webview를 통해 App을 구현하고 있었다! 하지만 내가 기존에 구현한 방식은 해당 환경까지 듣지 못하여 App 환경까지 고려하여 구현을 하지 않았다.. 🤦‍♂️ 기존에는 Web의 BOM을 활용하여 opener.parent.{callbackMehtod}로 인자와 함께 값을 넘겨 처리하고 있었다.\n하지만 App 단에서는 애초에 Opener 객체가 존재하지 않아 정상적으로 callBack을 수행할 수 없었다!\n해결 방법 위 issue는 사실 모듈 간 의사소통의 문제였던 것 같다..! App 모듈 측에서 제공하는 내부 함수 호출 method가 있었다!! 해서 해당 내용을 guide 받고 문제를 해결.. 할 뻔 했는데 추가적인 문제가 발생하였다!\n연달은 문제 문제 userAgent를 체크하여 App 환경일 시 제공 받은 guide의 method로 callback method를 실행하도록 수정하였다! 하지만 callBack method는 실행 되지만 함께 넘긴 parameter를 받지 못해 callback이 정상적으로 동작하지 않았다.. 😂😂\n원인 그 원인은 App 모듈 측에서 제공하는 함수가 문제였다. 문제 해결을 위해 해당 method의 소스를 살펴보았는데 Javascript의 eval 함수를 사용하여.. 호출을 하고 있었다..! 하여 호출한 page의 callback method는 잘 찾아서 호출 하였는데 Nice 본인인증의 redirect page의 scope는 참조하지 못해 parameter로 넘기는 객체를 찾지 못하고 있었다..\n해결 방법 우선 eval 함수를 사용하는 점은.. 타 모듈의 업무이기 때문에 더 관여하지 않기로 했다..! 이미 배포하여 사용 중인 소스이고 좀 애매했다 ㅜ..\n문제를 간단히 해결하기 위해 여러 방법들을 생각해봤다! 구글링 결과 eval 사용 부분을 수정해야 한다는 내용이 많았다.. 하지만 건드릴 수 없는 부분이니 배제할 수 밖에 없었다 ㅜ..\n하여 결국 찾은 최선의 방법은 객체를 넘기지 말고 JSON String 형태로 그냥 풀어서 보내고 받는 단에서 parsing 하는 방법이였다! 불필요한 소스가 한 두줄 들어가긴 하지만 현재 상황에서 문제를 해결하기에는 가장 쉬운 방법이였다.. 소스는 문제 없이 동작하고 이슈는 해결 되었다!\n내 생각 요즘 Web 사이트들의 Spec은 Hybrid app을 지원하는 것 같다! 대부분의 App이 위와 같은 방식으로 쉽게 구현하고 있는 것 같더라.. 하여 기본적으로 Web Window 객체를 활용한 Spec을 최대한 지양하고 JavaScript 그대로의 성능을 살려 구현을 해야 할 것 같다!\n혹은 애초에 Nice 본인인증 구현 방식 자체를 최신의 API 의사소통 방식을 통해 구현했다면..? 굉장히 여러 이슈들을 피해갈 수 있었을 것 같다.. 하지만!! 개발이 무조건 최선의 환경과 최신의 기술에서만 하는 일은 아니다.. 집을 지을 때에도 무조건 전기톱이나 최신 공구가 있어야 집을 짓는 건 아니지 않나!! 무딘 날이 있으면 내가 직접 갈아서 일을 할 때도 있는 것이고.. 옛 연장도 최대한 효율적으로 사용하여 결국 목적을 이루는 것 또한 내 직업의 일이다!\n비록 해결 자체는 쉬웠던 이슈였지만 여러모로 또 많은 걸 깨닫게 해주었던 이슈였다!! 재밌었다!!\n","permalink":"https://HyoseungJeon.github.io/posts/api/nice%EB%B3%B8%EC%9D%B8%EC%9D%B8%EC%A6%9D%EC%9D%B4%EC%8A%88%EB%8C%80%EC%9D%91/","summary":"Nice본인인증 이슈 문제 issue로 올라온 사항은 Android, IOS App 단에서 본인인증이 제대로 실행되지 않는다는 사항이였다! 본인인증 popup에서 인증을 완료 시 정상적으로 처리되지 않고 에러페이지로 이동하는 상황 이였다.\n원인 문제의 원인은 본인인증 Callback method가 실행되지 않는 상황이였다!!\n현재 구현된 프로젝트는 하이브리드 App방식으로 Android, IOS 각 OS의 Webview를 통해 App을 구현하고 있었다! 하지만 내가 기존에 구현한 방식은 해당 환경까지 듣지 못하여 App 환경까지 고려하여 구현을 하지 않았다.. 🤦‍♂️ 기존에는 Web의 BOM을 활용하여 opener.","title":"Nice본인인증 이슈대응"},{"content":" JQuery Custom Validate 개발 방향 지난번 JQuery Validate Plugin은 rule과 message를 mapping 해서 할당 후 노출하는 구조였다! 해서 내가 해결하려고 했던 정적으로 message를 계속 선언하는 부분이 개선되지 않았다. 해서 field의 attribute 값들로 모든 setting이 가능한 방식으로 구현을 해보려고 한다…! 😁😁\n소스 validateForm(formId) { const formTag = $(`#${formId}`) // form tag check if (!formTag.is(\u0026#34;form\u0026#34;)) { console.error(`${formId} is not Form tag or can\u0026#39;t find!! check id`) alert(\u0026#34;사용자 에러 메세지 노출\u0026#34;); return false; } // 하위 all input, select element 조회 for(let element of formTag.find(\u0026#39;input\u0026#39;, \u0026#39;select\u0026#39;)) { const { style, type, name, value, dataset } = element // element check if (type === \u0026#39;hidden\u0026#39; || style.display === \u0026#39;none\u0026#39; || !$(element).is(\u0026#34;:visible\u0026#34;)) continue; // get tag info, rule option (by attribute) let ruleAry = typeof dataset.rules === \u0026#39;string\u0026#39; ? dataset.rules.split(\u0026#39; \u0026#39;) : [] ruleAry = type === \u0026#39;select\u0026#39; ? [\u0026#39;required_sel\u0026#39;] : ruleAry for (let rule of ruleAry) { const { validate, message } = getValidateRule(rule) if (!validate(value)) { // alert 노출 alert(argMessage(message, name)); $(element).focus() return false; } } } return true; } const ruleMap = new Map([ [ \u0026#39;required\u0026#39;, { validate: v =\u0026gt; !!v, message: \u0026#39;을(를) 입력해주세요.\u0026#39; } ], [ \u0026#39;required_sel\u0026#39;, { validate: v =\u0026gt; !!v, message: \u0026#39;을(를) 선택해주세요.\u0026#39; } ], [ \u0026#39;regNo\u0026#39;, { validate: v =\u0026gt; !!v, message: \u0026#34;올바른 법인등록번호를 입력해주세요.\u0026#34; } ], [ \u0026#39;email\u0026#39;, { validate: v =\u0026gt; !!v, message: \u0026#34;올바른 이메일 형식을 입력해주세요.\u0026#34; } ], ]) function getValidateRule(ruleName) { if (!ruleMap.has(ruleName)) { console.warn(`[Validation is bypass] ${ruleName} is not defined, plz check rule name.`) return { validate: v =\u0026gt; true, message: \u0026#34;bypass\u0026#34; } } return ruleMap.get(ruleName) } 구조 구조는 상대적으로 간단하다. DOM Element field로 Form을 최상단에 부모로 선언하고, 해당 자식값에 필요한 input, select field를 선언한다. 그리고 name, value, dataset-rules 값을 선언한다.\nValidation check 할 key(항목명), value(validate: check function, message: 노출 message)를 선언한다.\n사용할 곳에서 validate 함수에 첫번째 매개변수로 form field의 id값을 입력하고 넘겨 실행한다.\n로직은 다음과 같다.\nform field 내 모든 input, select field를 조회한다. 단, form field 아닐 시 error, alert 노출 field의 name, value, rules 값을 꺼낸다. 단, 비노출 상태일 시 다음으로 rules 값을 array 형태로 선언한다. 단, string 이외의 type 경우 빈 array로 선언 type이 select 인 경우 특정 rule array로 선언 rule array를 순회한다. rule name으로 Map에서 validate function과 message를 꺼낸다. validate fail 시 alert 노출, focus를 이동한 후 종료한다. 내 생각 아직 많은 예외 케이스들에 대한 처리가 있지는 않지만 정확하게 구조에 따라 작성을 한다면 아무런 문제 없이 동작했다! 하지만 message 노출에 관련한 부분은 개선이 필요했다 ㅎ.. 기존에 message get 방식을 그대로 차용해와서 사용했다. 때문에 이 부분도 개선할 필요가 보이더라 ㅜ.. 그 부분을 제외한다면 정확하게 의도대로 동작하였고 사용성도 내 기준에서는 괜찮은 듯 했다! 이로 인해 수많은 분기 문들과 보일러 플레이트가 많이 사라졌다.. 😆😆 더 좋은 방향으로 계속 개선해봐야겠다!!\n","permalink":"https://HyoseungJeon.github.io/posts/javascript/validate/","summary":"JQuery Custom Validate 개발 방향 지난번 JQuery Validate Plugin은 rule과 message를 mapping 해서 할당 후 노출하는 구조였다! 해서 내가 해결하려고 했던 정적으로 message를 계속 선언하는 부분이 개선되지 않았다. 해서 field의 attribute 값들로 모든 setting이 가능한 방식으로 구현을 해보려고 한다…! 😁😁\n소스 validateForm(formId) { const formTag = $(`#${formId}`) // form tag check if (!formTag.is(\u0026#34;form\u0026#34;)) { console.error(`${formId} is not Form tag or can\u0026#39;t find!! check id`) alert(\u0026#34;사용자 에러 메세지 노출\u0026#34;); return false; } // 하위 all input, select element 조회 for(let element of formTag.","title":"Custom Validate"},{"content":" 💡 프로젝트 투입 후 맡게 된 화면에서 가변 Input field가 추가되었는데 Validate 부분이 분기 문으로 처리되어 있었다..! 해서 결국 관련된 소스를 하나하나 찾아서 추가하고 영향도 있는 부분은 수정하는 작업을 했다… 사실상 요구사항은 간단했지만 필요 이상으로 작업이 오래 걸렸다! 그럼으로 기존 분기 처리로 된 Validate가 아닌 jQuery 기반의 Validate로 구현을 한번 해보자! JQuery Validate? 정의 The jQuery Validation Plugin provides drop-in validation for your existing forms, while making all kinds of customizations to fit your application really easy. 출처 - https://github.com/jquery-validation/jquery-validation\n단순히 유효성 검사를 쉽게 조작하여 처리할 수 있도록 돕는 Plugin이다! (딱히 더 정확한 정의는 없는 것 같다 ㅎ..😂)\n사용 이유 우선 기존 프로젝트가 jQuery를 기반으로 구현되었다! 해서 관련된 Plugin을 활용해서 사용하려 했다. 현재 form, input field로 구현된 소스로 구조에 변화 없이 validate 처리가 가능함으로 쉽게 구현이 가능할 것 같았다! rule, message Mapping 정의로 현재 Validate 처리 logic를 쉽게 복각하기 쉬워 보였다! 기존에 field 에 각각 alert message를 할당하여 노출하는 방식이였는데, 그대로 활용하기 쉬울 것이라고 예상했다.\n사용법 \u0026lt;form\u0026gt; \u0026lt;input required\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script src=\u0026#34;jquery.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;jquery.validate.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const option = { rules: { userId : { required: true, rangelength: [2, 10] }, userEmail: { required: true, email: true } }, messages: { userId: { required: \u0026#34;이름은 필수 입력입니다.\u0026#34;, rangelength: \u0026#34;이름은 {0}자에서 {1}자까지 사용 가능합니다.\u0026#34; }, userEmail: { required: \u0026#34;이메일은 필수 입력입니다.\u0026#34;, email: \u0026#34;이메일 형식을 확인하세요.\u0026#34; } }, submitHandler: function(){ console.log(\u0026#34;submit!\u0026#34;); } } $(\u0026#34;form\u0026#34;).validate(option); \u0026lt;/script\u0026gt; 사용법은 간단하다! option 정의 후 form field의 id값으로 찾아 validate fucntion을 option값을 넘겨 실행하면 된다!\noption 정의에 관련한 자세한 내용은 출처 Page들을 참고하면 된다.\n내 소스 소스가.. 없다..! 🤔\n왜냐하면 처음에 고려한 설계와 다르게 내가 원하는 기능이 지원하고 있지 않았다.. 😂 (아닐 수도 있음)\n기존에 alert 문구 노출 방식은 field 값을 참고해 “{title name}을 입력해주세요” 등의 문구로 노출하고 있었다. 하지만 위의 rule, message 방식은 정적으로 message를 선언하는 방식으로 결국은 매번 똑같이 message 문구를 넣어주는 수 밖에 없었다! 내가 원한 건 자동으로 input field의 title, name 값을 읽고 validate 조건을 체크해 alert 문구를 뿌려주는 방식이였다! 매번 새로운 field가 추가될 때 마다 분기를 치고 message를 추가하고, validate Logic을 넣고 등의 방식을 피하기 위해서 였는데.. 똑같은 노가다 소스를 작성해야 했다.. 해서 jQuery Spec을 이용한 다른 방식의 validate Util을 따로 구현했다! 내용은 다른 Posting에서 작성하겠다. (차후 링크 추가 예정)\n내 생각 물론 기존의 if else을 이용한 처리 방식보다는 가독성도 높고 사용법도 간편해서 좋았다! 하지만 내가 추구했던 방향은 유지보수의 측면이였다. 결국 field 추가와 삭제, 가변 field 처리 등에 관련하여 기능의 한계가 분명해 보였다. 물론 그런 고수준? 의 기능을 지원하기 위해서 기본 Plugin에게 기대하기는 어렵다고 생각이 들기도 한다.. (사실 잘 모르겠다.. 왜 이렇게 구현했는지..?)\nvalidate function은 form field 기준으로 단 1번 호출하고, 그에 따라 callBack, alert, error handling 등이 자연스럽게 처리 되는 방식을 필요로 했다. 여기저기 분기가 들어가 있고, messaage를 정적으로 매번 선언하고, 그에 따른 error handling도 따로 되어 있다면 결국 유지보수에서는 어마어마한 cost가 들어간다. (실제로 가변 field 추가하는 업무에 필요 이상의 많은 작업 시간을 사용했다)\n만약 input field에 대한 정의 (html source)만으로 validate가 동작 한다면 위와 같은 작업 시간은 필요가 없을 것이다. soruce 전체를 확인하거나 작업할 필요 없이 해당 input field만 정확하게 정의한다면 문제 없이 validate 가 처리될 것이다. 작업자는 결국 소스 여기저기를 살펴보거나 side effect를 걱정할 필요 없이 오로지 field 정의에만 신경을 쓰면 될 것이다.\n결국 이 이야기에 끝에는 항상 작업의 일정 때문에 어쩔 수 없이 그렇게 작업했다가 자주 나온다.. 하지만 난 항상 의문이다. 처음의 설계에 80, 작업에 20과 설계에 20, 작업에 80에 비중을 둔다면 결국 변경사항이 생겼을 때 80에 가까운 작업을 항상 해야할 것 이다. 혹은 새로운 작업자는 그 80의 작업을 다 확인하고 일을 해야 한다. 뭐가 맞을까..? 난 무조건 전자인 것 같다! 물론 사람마다 생각과 의견은 다르니 그럴 수 있다. 하지만 난 내 설계를 해가는 것이 재미있고 좋다! 새로운 Posting에서 내 생각의 소스를 써보겠다 😁👍\n출처 : https://github.com/jquery-validation/jquery-validation\nDocumentation\n","permalink":"https://HyoseungJeon.github.io/posts/jquery/validate/","summary":"💡 프로젝트 투입 후 맡게 된 화면에서 가변 Input field가 추가되었는데 Validate 부분이 분기 문으로 처리되어 있었다..! 해서 결국 관련된 소스를 하나하나 찾아서 추가하고 영향도 있는 부분은 수정하는 작업을 했다… 사실상 요구사항은 간단했지만 필요 이상으로 작업이 오래 걸렸다! 그럼으로 기존 분기 처리로 된 Validate가 아닌 jQuery 기반의 Validate로 구현을 한번 해보자! JQuery Validate? 정의 The jQuery Validation Plugin provides drop-in validation for your existing forms, while making all kinds of customizations to fit your application really easy.","title":"JQuery Validate"},{"content":" 💡 새로운 프로젝트에서 Push 알림 기능을 담당하게 됐다! 웹 개발을 하면서 한번도 접해보지 못했었는데 문자/이메일 은 너무 많이 경험해본 것 같아 Push를 해보겠다고 하였다!!😁😁 좋은 경험이 되기를!!!! FCM이란? 정의 Firebase Cloud Messaging(FCM)은 메시지를 안정적으로 무료 전송할 수 있는 크로스 플랫폼 메시징 솔루션입니다. 출처 - https://firebase.google.com/docs/cloud-messaging?hl=ko\n기능 알림 메시지 또는 데이터 메시지 전송 사용자에게 표시되는 알림 메시지를 전송합니다. 또는 데이터 메시지를 전송하고 애플리케이션 코드에서 임의로 처리합니다. 자세한 내용은 https://firebase.google.com/docs/cloud-messaging/concept-options?hl=ko#notifications_and_data_messages을 참조하세요. 다양한 메시지 타겟팅 단일 기기, 기기 그룹, 주제를 구독한 기기 등 3가지 방식으로 클라이언트 앱에 메시지를 배포할 수 있습니다. 클라이언트 앱에서 메시지 전송 FCM의 신뢰성 높고 배터리 효율적인 연결 채널을 통해 기기에서 다시 서버로 확인, 채팅, 기타 메시지를 보낼 수 있습니다. 기본 원리 FCM 구현에는 송수신을 위한 두 가지 주요 구성요소가 포함됩니다.\nFirebase용 Cloud Functions 또는 앱 서버와 같이 메시지를 작성, 타겟팅, 전송할 수 있는 신뢰할 수 있는 환경 해당 플랫폼별 전송 서비스를 통해 메시지를 수신하는 Apple, Android 또는 웹(자바스크립트) 클라이언트 앱 Firebase Admin SDK 또는 FCM 서버 프로토콜을 통해 메시지를 보낼 수 있습니다. 알림 작성기를 사용하면 기본 제공되는 강력한 타겟팅 및 분석 기능이나 커스텀 가져온 세그먼트를 사용하여 마케팅 또는 참여 메시지를 테스트하고 전송할 수 있습니다.\nFCM의 구성요소에 대한 자세한 내용과 중요한 정보는 아키텍처 개요를 참조하세요.\n즉, 무료로 Server 단에서 FCM Server를 통해여 정해진 규약에 따라 사용자 클라이언트에게 메세지를 보내는 서비스이다!\n사용법 FirebaseApp firebaseApp; ClassPathResource filePath = new ClassPathResource(pushFirebaseProperties.getFileName()); FirebaseOptions options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(filePath.getInputStream())) .build(); firebaseApp = FirebaseApp.initializeApp(options); FirebaseMessaging FirebaseMessagingInstance = FirebaseMessaging.getInstance(firebaseApp); // 메시지 설정 Notification notification = Notification.builder() .build(); MulticastMessage message = MulticastMessage .builder() .setNotification(notification) .build(); // 메시지 전송 BatchResponse response = FirebaseMessagingInstance.sendMulticast(message); 사용법은 간단하다. 발급 받은 Firebase 인증 정보 File을 읽고 App 객체를 생성, FirebaseMessaging\nInstance를 생성하여 메시지를 설정 후에 send 하면 끝이다!\n단, 내부 source를 공개하기는 어렵지만 구조는 이러하다.\nSpring Daemon Server로 구성 알림 등록 시, 알림 대기 목록 table insert Daemon server는 5초 간격으로 table read 조회 된 row 있을 시 병렬 처리 Thread에 작업 할당 알림 발송 병렬 처리 (FCM 발송) 성공/실패 Log table insert 처음 인수인계를 받고 Daemon server로 구현된 방식이 신기했다! Spring batch가 아닌 오랜만에 보는 Daemon server.. 좀 두려웠다;;\n알림은 크게 단 건, 다 건 두 종류로 처리하고 있었다! 그래서 당연히 단 건은 Controller API로 받아서 즉시 처리할 줄 알았는데 두 종류 모두 Daemon Server가 각 case의 Table을 읽고 처리하고 있었다..! (무슨 의미일까..?) 어차피 5초마다 돌기 때문에 거의 실시간이라고 봐도 무방하지만.. 굳이 Thread를 하나 더 생성하여 할당 시키는 이유는 아직 납득하지 못했다.. 😒😒\nSpring Daemon Server Run 방식 자체도 조금 신기했는데, Scheduling File을 통해.. 단순히 Thread 2개를 run 시키고 해당 Thread Daemon이 계속 도는? 방식 이였다!! 처음에 위 File이 있어서 Batch로 구현 되어있나..? 라는 생각을 하였는데 Job도 없고.. 하여 엄청 헷갈렸는데 Daemon이란 걸 이해하고 바로 납득이 갔다!\n하여 Size가 10개 씩 잡힌 Thread 돌며 작업을 처리하고, 알림을 보낸다!! Runnable Class 를 상속 받은 Sender, Worker, Manager Context 들이 작업을 할당 받아 처리하고 있다.\n내 생각 생각보다 FCM이 제공하는 Service가 좋아서 쉽게 사용자에게 알림을 보낼 수가 있었다! 하지만 역시 그 환경을 구성하는 일이 더 중요하다고 봤다..\nPush 알림의 종류는 단 건, 다 건 두 종류였다! 내 생각에는 단 건은 문자 Service 와 같이 MQ를 이용하여 구성을 하고, 다 건은 Batch로 예약된 시간에 Server가 할당된 Thread를 통해서 처리를 하면 깔끔할 것이라고 생각했다! 하지만 둘 다 Daemon 방식으로 처리 되고 있는 것이 조금 놀라웠다..; 아니 사실 좀 이상하다고 생각했다! 하지만 기존의 Project 소스를 Reference로 삼아 작업을 한 것이라 어쩔 수 없었다는 말을 듣고 어느 정도 납득을 하긴 했다.. 하지만 이러한 상황들 때문에 오래된 것이든 경험을 해보고 또 배우고! 또 새로운 것의 장점을 제대로 느낄 수 있는 거 아닐까?\n언제나 그렇듯 제공되는 API는 기능일 뿐 결국 구성하는 방식이 중요했다! 특히 Spring 인데도 불구하고 FCM Instant 주입 방식이 static Syn~~ 방식으로 되어 있었다..! 그리고 Manager Context에 해당 FCM을 할당, 다른 Context에게 계속 param으로 넘기면서 사용하고 있었다;; 매번 param에 선언, static으로 선언한 이유도.. 이해가 가지 않았다. 해서 Config 단으로 FCM 초기화 Source을 이관하고, 해당 FCM 객체를 @Bean으로 선언하여 Single Tone으로 어디서나 주입 받아 사용할 수 있도록 수정 하였다! 기존 Service는 이미 제공되고 있어서 건드릴 수 없었지만 적어도 주입 방법이라도 바꾸고 싶었다.. 😂 (너무 신경 쓰여서 도저히 둘 수가 없었다..)\nCtrl C + V 는 좋다.. 하지만 아무런 사고 없이, 생각 없이 붙이는 작업은 최악이라고 생각한다..! 이런 기회를 통해서 마음을 한번 다시 다잡게 되었다!\n출처:\nhttps://firebase.google.com/docs/cloud-messaging?hl=ko\n","permalink":"https://HyoseungJeon.github.io/posts/api/fcm/","summary":"💡 새로운 프로젝트에서 Push 알림 기능을 담당하게 됐다! 웹 개발을 하면서 한번도 접해보지 못했었는데 문자/이메일 은 너무 많이 경험해본 것 같아 Push를 해보겠다고 하였다!!😁😁 좋은 경험이 되기를!!!! FCM이란? 정의 Firebase Cloud Messaging(FCM)은 메시지를 안정적으로 무료 전송할 수 있는 크로스 플랫폼 메시징 솔루션입니다. 출처 - https://firebase.google.com/docs/cloud-messaging?hl=ko\n기능 알림 메시지 또는 데이터 메시지 전송 사용자에게 표시되는 알림 메시지를 전송합니다. 또는 데이터 메시지를 전송하고 애플리케이션 코드에서 임의로 처리합니다. 자세한 내용은 https://firebase.google.com/docs/cloud-messaging/concept-options?hl=ko#notifications_and_data_messages을 참조하세요. 다양한 메시지 타겟팅 단일 기기, 기기 그룹, 주제를 구독한 기기 등 3가지 방식으로 클라이언트 앱에 메시지를 배포할 수 있습니다.","title":"FCM"},{"content":" 💡 사용자에게 현재 STATIC Directory에 있는 pdf File 들을 다운로드 기능과 함께 목록을 제공하는 기능을 구현하는 일을 받았다! 정적 자산을 객체로 받아 화면에 알맞게 던져주는 기능을 구현해보자!! 생각보다 자주 구현할 일이 있는 기능이지만 실제로는 처음 해봐서 재미있었다..😁👍 File Class 란? 정의 An abstract representation of file and directory pathnames.\nUser interfaces and operating systems use system-dependent pathname strings to name files and directories. This class presents an abstract, system-independent view of hierarchical pathnames.\n출처 - https://docs.oracle.com/javase/8/docs/api/java/io/File.html\nFile, Directory의 추상 Class 즉, 파일이나 경로에 대한 정보를 추상화한 Class이다.\n해당 객체는 경로의 문자열을 통하여 선언이 가능하다.\n사용법 기본 import java.io.File; public class Main { public static void main(String[] args) { String filePath = \u0026#34;C:/java/Test.txt\u0026#34;; String parentPath = \u0026#34;C:/java\u0026#34;; string fileName = \u0026#34;Test.txt\u0026#34;; // File(String pathname) 생성자 사용 File file1 = new File(filePath); // File(String parent, String child) 생성자 사용 File file2 = new File(parentPath, fileName); // File(File parent, String child) 생성자 사용 File parent = new File(parentPath); File file3 = new File(parent, fileName); // 파일명 System.out.println(file1 .getName()); // java // 절대 경로 System.out.println(file2 .getAbsolutePath()); // C:/java // 경로 System.out.println(file2 .getPath()); // C:/java // 존재 여부 System.out.println(file3 .exists()); // ture or false } } File의 정적 경로를 생성자로 사용하여 File 객체를 선언한다.\n후에 위와 같은 여러 method들을 통하여 해당 File의 정보를 조회할 수 있다.\n자세한 사용 방법은 Doc를 참고하는 것이 좋다!\n내 사용 예제 public File getUserManualFile() { File userManualFile; final String userManualFileDir = ResourceUtils.CLASSPATH_URL_PREFIX + \u0026#34;static/upload/manual\\\u0026#34;\u0026#34;; try { userManualFile = ResourceUtils.getFile(userManualFileDir); } catch (FileNotFoundException e) { throw new RuntimeException(\u0026#34;File을 찾을수가 없습니다.\u0026#34;); } return userManualFile; } public String popUserManual(Model model) { File file = mainService.getUserManualFile(); model.addAttribute(\u0026#34;userManualFileList\u0026#34;, file.listFiles()); return \u0026#34;/popup/userManualPopup\u0026#34;; } ResourceUtils - Spring Util 을 통하여 노출할 File들의 상위 File 객체를 가져온다!\n후에 해당 객체의 listFiles 함수를 통하여 File 객체 형태로 화면에 반환해준다.\n화면에서는 해당 File 객체를 이용하여 필요한 정보를 노출한다.\nUtility methods for resolving resource locations to files in the file system. Mainly for internal use within the framework. Spring FrameWork 에서 지원하는 Util로 프로젝트 내 resource 자원을 쉽게 조회하기 위한 Class이다. 출처 - https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/ResourceUtils.html\n느낀점 S3 Server에 File이 올라가 있고, 해당 File 정보를 DB나 직접 Server에 조회하여 이름과 경로를 가져오고 뿌리는 방식을 생각했었다. 하지만 static 경로에 File을 위치 시키는 경우도 당연히 존재하는데 해당 경우에 대한 처리는 알지 못했었다!! 해서 이번 기회를 통해 새로운 지식을 알게 되어서 좋았다. 프로젝트의 정적 경로에 File들에 대해 다루는 방법을 알게 되었고 Spring에서 해당 기술을 위해 지원하는 Util 또한 존재한다는 것을 알게 되어 역시 Spring은.. 좋은 FrameWork이라는 것을 또 깨달았다..\n이번 기능을 구현하며 집중했던 부분은 File 객체를 최대한 활용하는 것 이였다! 따로 Dto response를 활용하여 뺄 수 있었지만 실제로 File 객체가 공식화 된 Dto 라고 여기고.. 해당 File 통해 화면에서 정보를 노출하려 했다! 실제로 필요한 File에 대한 정보가 해당 객체에도 충분하게 담겨있어 화면에서도 사용하기 용이했다. 간단하지만 재미있는 경험이였다!\n출처\nhttps://docs.oracle.com/javase/8/docs/api/java/io/File.html\nhttps://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/ResourceUtils.html\n","permalink":"https://HyoseungJeon.github.io/posts/java/file/","summary":"💡 사용자에게 현재 STATIC Directory에 있는 pdf File 들을 다운로드 기능과 함께 목록을 제공하는 기능을 구현하는 일을 받았다! 정적 자산을 객체로 받아 화면에 알맞게 던져주는 기능을 구현해보자!! 생각보다 자주 구현할 일이 있는 기능이지만 실제로는 처음 해봐서 재미있었다..😁👍 File Class 란? 정의 An abstract representation of file and directory pathnames.\nUser interfaces and operating systems use system-dependent pathname strings to name files and directories. This class presents an abstract, system-independent view of hierarchical pathnames.","title":"File"},{"content":" 💡 새로운 Project에 투입되어 바로 Nice 본인 인증 API 기능을 추가하는 작업을 배정 받았다! Spring JSP, thymeleaf 각 project에 추가를 하면 된다!! 여기 저기서 사용하는 외부 API 로 실제 내가 개발해보는 재미를 느껴보자😍 Nice 본인인증 이란? NICE 평가정보 회사에서 제공하는 본인 확인 서비스로 사용자의 주민등록번호 등과 같은 정보를 통해 실명 확인 과정을 거쳐 사용자의 명의를 확인할 수 있는 기능을 제공하는 API 이다.\n아마 내 생각엔 국내에서 개인 인증을 해야 하는 모든 사이트들이 API를 사용하여 인증을 하고 있을 것이다! 나 또한 엄청 쓰는 것 같다..\n해서 프로젝트 에서는 Nice 본인인증의 휴대폰 본인확인 방식을 넣게 되었다!\n개발 개발 방향 해당 API 에 관련하여 Docs 에서 자료를 찾아본 결과, API 호출 방식과 jsp file로 구현하는 방식으로 2개의 가이드라인을 제공하고 있었다.\n본 프로젝트에서는 다른 프로젝트에서 JSP 방식의 구현을 채택하여 사용 중 이여서 그런지 해당 방식으로 기능을 구현하기로 했다.\nGuide Line 사용 방법은 굉장히 간단하다!\nNice에서 제공하는 .jar File을 project에 import 하고,\n가이드에 나와있는 .jsp File들을 참고하여 사용자의 key 등등의 custom 값들만 변경해주면 사용 준비는 끝난다\n우리는 프로젝트의 Nexus Repository에 해당 .jar File을 업로드 후 당겨서 쓰는 방식으로 setting 을 했다!\n다른 부분들은 굉장히 기본적이지만 내가 집중해서 말하고 싶은 부분이 있다\n해당 기능은 당연하게도 공통 방식으로 구현이 된다. 해서 모든 페이지에서 호출이 가능하고 적절한 response를 돌려줘야 한다!\n가이드 문서의 구현 방식은 returnUrl을 popup Open 시 request로 받고 인증 완료 시 해당 Url site로 결과값과 함께 redirect 해주는 방식으로 되어있었다!\n처음에 해당 가이드를 통해 생각을 했을 때에는 그럼 사용자에게 request로 returnUrl을 입력 받아야겠다! 라고 생각을 하게 되었다.\n하지만 해당 방식은 사용자에게 꽤나 불편한..? 요소로 작용할 것 같았다. 호출 시에 매번 호출 페이지의 URL을 보내야 한다니 조금 이상하긴 했다.\n해서 다른 예제들을 참고하여 기능을 재구현 했다!\n내 구현 방식 사용자는 단순히 js내의 nice 본인인증 Open Method을 호출하고\ndata Setting 부분은 공통으로 처리\n단, returnUrl에 사용자의 returnUrl이 아닌 공통의 redirect Page의 URL을 넣는다.\nvar niceInfo = ${niceInfo}; opener.parent.callback(niceInfo); close(); 해당 redirect Page는 Nice에서 받은 사용자 정보를 Method를 호출한 js File의 callback method에 param을 담아 호출하고, page를 닫는다.\n하면 사용자는 인증 완료 시 호출할 callBack method 1개와 본인 인증 호출 method 한줄만 추가하면 사용할 수 있게 된다. 넘겨줄 값이 없다!! 사용 편의성이 훨씬 좋지 않은가..?\n내 생각 아마 혼자 개발 했다면 가이드 라인대로 개발을 진행했을 것 같다.. 하지만 브라우저의 Window 객체를 통한 활용 방식을 알고 있었다면 굉장히 간단히 구현해냈을 기능이다..\n웹 개발을 비교적 최신 기술인 Vue 2.0 부터 시작해서 인지 Popup 관련한 지식이나 Window 객체의 활용에 대한 지식이 부족한 것 같다 😢\nwindow Popup은 꼭 Window.opener 인터페이스가 따라온다! 함께 생각하도록 하자!!\n출처\nNICE아이디 - 휴대폰본인확인\n","permalink":"https://HyoseungJeon.github.io/posts/api/nice%EB%B3%B8%EC%9D%B8%EC%9D%B8%EC%A6%9D/","summary":"💡 새로운 Project에 투입되어 바로 Nice 본인 인증 API 기능을 추가하는 작업을 배정 받았다! Spring JSP, thymeleaf 각 project에 추가를 하면 된다!! 여기 저기서 사용하는 외부 API 로 실제 내가 개발해보는 재미를 느껴보자😍 Nice 본인인증 이란? NICE 평가정보 회사에서 제공하는 본인 확인 서비스로 사용자의 주민등록번호 등과 같은 정보를 통해 실명 확인 과정을 거쳐 사용자의 명의를 확인할 수 있는 기능을 제공하는 API 이다.\n아마 내 생각엔 국내에서 개인 인증을 해야 하는 모든 사이트들이 API를 사용하여 인증을 하고 있을 것이다!","title":"Nice 본인인증"},{"content":" 💡 주로 Business Logic 을 작성하거나 혹은 보게 될 때 방대한 if else 분기와 보일러 플레이트들을 마주하게 된다!! 이는 Debuging 과정을 힘들게 하여.. 결국 지속적으로 안좋은 코드를 만들게 된다.. 하여 간단한 전략 패턴을 배워보고 활용해보자!! 전략 패턴이란? (Strategy Pattern) 정의 전략 패턴(strategy pattern) 또는 정책 패턴(policy pattern)은 실행 중에 알고리즘을 선택할 수 있게 하는 행위 소프트웨어 디자인 패턴이다. 전략 패턴은\n특정한 계열의 알고리즘들을 정의하고 각 알고리즘을 캡슐화하며 이 알고리즘들을 해당 계열 안에서 상호 교체가 가능하게 만든다. 전략은 알고리즘을 사용하는 클라이언트와는 독립적으로 다양하게 만든다.[1] 전략은 유연하고 재사용 가능한 객체 지향 소프트웨어를 어떻게 설계하는지 기술하기 위해 디자인 패턴의 개념을 보급시킨 디자인 패턴(Gamma 등)이라는 영향력 있는 책에 포함된 패턴들 가운데 하나이다.\n출처 - https://ko.wikipedia.org/wiki/전략_패턴\n정확한 정의를 참고하기 위하여 찾아보았지만 개인 블로그들의 정의보단 Wiki를 참고하는 것이 좋을 것 같다 가져왔다!\n내 정의 이 Design Pattern 의 이름은 ‘전략’ 이다! 이는 전쟁에서 승리를 가져오기 위한 하나의 방법을 서술하는 의미이다. 그리고 다시 우리는 프로그래밍의 측면에서 이 의미를 해석해본다면,\n우리가 목적으로 하는 것을 위하여 공통적인 여러가지 전략을 정의하여 상황에 따라 전략을 가변적으로 사용하게 만드는 패턴이라고 생각한다.\n그리고 그 패턴을 가능하게 하는 것이 캡슐화 인 것이다.\n구조 기본 구조 Context Class (abstract)\n전략을 선택하여 문제 해결을 수행할 구조를 정의한 Class\nStrategy Class를 변수로 갖고있다.\nStrategy Class (Interface)\n문제를 해결 할 전략의 형태를 정의한 Class\nContext class를 상속한 실제 Context class 생성, 해당 class에 목적에 맞는 Strategy class를 상속 받아 구현된 class을 set 한다.\n전략을 할당한 Context class의 공통 실행 method를 통하여 전략을 수행한다.\n예제 소스 public abstract class Order { private Process process; private Object data; public void runProcess() { // 공통 수행 method or logic 정의 // Common Validate logic process.validate(data); process.beforeProcess(data); process.run(data); process.afterProcess(data); } public void runProcessExceptBefore() { process.validate(data); process.run(data); process.afterProcess(); } } public interface Process { public void validate(Object data); public void beforeProcess(Object data); public void run(Object data); public void afterProcess(Object data); } public class NormalOrder extends Order {} public class Returning implements Process { @Override public void validate(Object data) { // check data // throw Exception } @Override public void beforeProcess(Object data) { // beforeProcess // can change Data } @Override public void run(Object data) { // run // call api, CRUD db } @Override public void afterProcess(Object data) { // afterProcess // call callback method, api, CRUD db } } public static void main(String[] args) { NormalOrder normalOrder = new NormalOrder(); normalOrder.setData(new Object()); normalOrder.setProcess(new Returning()); normalOrder.runProcess(); } Spring MVC 에서 보면 Service에 모든 분기와 process가 포함된 소스가 존재하는 것이 아닌 전략이나 수행 될 프로세스에 맞춰 분리가 가능하고, Service단의 소스가 간결해진다. 또한 전략 수행의 대상을 다양한 매개체로 설정하고 구현한다면 재활용성 또한 커지게 된다!\n결론 디자인 패턴에 대하여 학습할 때 마다 느끼는 점은, 실제 비즈니스 프로젝트에 적용할 때에 얼마나 효과적으로 적용할 수 있는지 에 대한 고민인 것 같다. 만약 사이즈가 작은 프로젝트에 여러 디자인 패턴을 적용하여 오히려 더 복잡한 구조를 만들어내거나, 혹은 본 패턴이 추구하는 목적을 잃고 단지 보여주기 위한 구조를 잡는다면 오히려 악효과를 낳게 된다. 요즘 분위기를 보다 보면 주객전도란 말이 너무 맞는 것 같다. 디자인 패턴의 목적은 결국 유지보수의 용이성이다. 반복되는 문제를 해결하기 위한 하나의 전략이다. 하지만 실제로는 목적을 위한 설계가 아닌 설계에 목적을 맞추어 해결하고 그 의미가 퇴색되게 만든다.\n디자인 패턴을 적용하기 전에 항상 생각하자, 전략 패턴처럼 내가 해결해야 할 문제에 대하여 디자인 패턴을 해보자가 아니라, 그 목적에 맞는지, 확실한 설계의 이점이 있는 것인지 생각해보는 것이 먼저이다!\n출처:\nhttps://ko.wikipedia.org/wiki/%EC%A0%84%EB%9E%B5_%ED%8C%A8%ED%84%B4 https://mountainous-grill-560.notion.site/09d333d821b7490187bccd2cdc5f91ef https://victorydntmd.tistory.com/292\n","permalink":"https://HyoseungJeon.github.io/posts/designpattern/strategypattern/","summary":"💡 주로 Business Logic 을 작성하거나 혹은 보게 될 때 방대한 if else 분기와 보일러 플레이트들을 마주하게 된다!! 이는 Debuging 과정을 힘들게 하여.. 결국 지속적으로 안좋은 코드를 만들게 된다.. 하여 간단한 전략 패턴을 배워보고 활용해보자!! 전략 패턴이란? (Strategy Pattern) 정의 전략 패턴(strategy pattern) 또는 정책 패턴(policy pattern)은 실행 중에 알고리즘을 선택할 수 있게 하는 행위 소프트웨어 디자인 패턴이다. 전략 패턴은\n특정한 계열의 알고리즘들을 정의하고 각 알고리즘을 캡슐화하며 이 알고리즘들을 해당 계열 안에서 상호 교체가 가능하게 만든다.","title":"Strategy Pattern"},{"content":" Reflection이란? 정의 Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions. The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control. - Oracle Java Doc\n나만의 정의로는 Runtime 환경에 들어서 load된 Class의 각 속성에 접근할 수 있는 기능이다.\nComplie 환경이 아닌 곳에서 정의되지 않은 Class에 접근하여 constructor, method, field, annotation 을 조작, 사용할 수 있다.\n생각해볼 점 우리는 Java를 객체지향언어(OOP) 라고 학습했었다. 지겹도록 들은 OOP의 특장점으로 캡슐화를 논하였는데 Reflection은 캡슐화를 위반하는 성격을 갖고 있다.\n왜 OOP 언어가 자신의 특징을 위반하는 API spec을 갖고 있을까?\n난 이점이 재밌다고 본다. 그리고 이 Spec 현재에 많은 것들을 가능하게 만들었다!\n결국 정체성과 별개로 Java는 객체의 활용성에 집중을 했다고 개인적으로 생각한다. 간단하게 이 기술을 살펴보면서 생각을 더 넓혀보자!!\n사용 방법 Simple case public static void main(String[] args) { Object obj = new Object(); try { Class cls = obj.getClass(); Constructor[] constructors = cls.getConstructors(); Method[] methods = cls.getMethods(); Field[] fields = cls.getFields(); Arrays.stream(fields).forEach(field -\u0026gt; { Annotation[] annotations = field.getAnnotations(); if (field.isAnnotationPresent(Service.class)) { return; } }); } catch (Exception e) { System.out.println(e); } } 위의 간단한 예제와 같이 객체에서 Class 를 추출 후 해당 속성인 값들을 꺼낼 수 있다.\n이후 각 속성 값들의 cotroll methods 이나 세부 방법은 다른 blog나 문서들을 참고 하는 것이 좋을 것 같다.\n내 사용 예제 프로젝트를 진행하면서 공통으로 Masking 기능을 구현할 일이 생겼다. 프로젝트 내에 따로 Common Soruce가 존재하지 않아 직접 구현해야 하는 상황 이였다.\npublic class MaskingUtil { /** * Dto class 마스킹 처리 * * @param dto * @return 성공여부 */ public static void maskingDto(Object dto) { Field[] fields = dto.getClass().getDeclaredFields(); if (List.class.isInstance(dto)) { List\u0026lt;?\u0026gt; listDto = (List\u0026lt;?\u0026gt;) dto; listDto.forEach(MaskingUtil::maskingDto); } else { for (Field field : fields) { if (!field.isAnnotationPresent(Masking.class) || !field.getType().equals(String.class)) continue; maskingField(field, dto); } } } private static void maskingField(Field field, Object dto) { Masking annotation = field.getAnnotation(Masking.class); field.setAccessible(true); try { field.set(dto, maskingString(MaskingType.valueOf(annotation.type().name()), String.valueOf(field.get(dto)))); } catch (IllegalAccessException e) { throw new RuntimeException(e); } finally { field.setAccessible(false); } } private static String maskingString(MaskingType maskingType, String str) { String result = \u0026#34;\u0026#34;; MaskingEntity maskingEntity = MaskingType.map.get(maskingType.name()); if(\u0026#34;null\u0026#34;.equals(str)) return result; if(Objects.nonNull(maskingEntity) \u0026amp;\u0026amp; StringUtils.hasText(maskingEntity.getRegex())) { result = str.replaceAll(maskingEntity.getRegex(), maskingEntity.getReplacement()); } else { switch (maskingType) { case NAME: { if (str.length() \u0026gt; 2) result = str.replaceAll(\u0026#34;(?\u0026lt;=.{1,2}).(?=.{1,2})\u0026#34;, maskingEntity.getReplacement()); else result = str.replaceAll(\u0026#34;(?\u0026lt;=.{1,2}).(?=.{0,2})\u0026#34;, maskingEntity.getReplacement()); break; } case ADDRESS_BASE: { StringJoiner sj = new StringJoiner(\u0026#34; \u0026#34;); String[] splitStr = str.split(\u0026#34;\\\\\\\\s\u0026#34;); if (splitStr.length \u0026gt; 2) { sj.add(splitStr[0]).add(splitStr[1].replaceAll(\u0026#34;(?\u0026lt;=.).\u0026#34;, \u0026#34;*\u0026#34;)); Arrays.stream(splitStr).skip(2).forEach(el -\u0026gt; { sj.add(el.replaceAll(\u0026#34;.\u0026#34;, \u0026#34;*\u0026#34;)); }); } else { result = str; } break; } } } return result; } Process를 간단히 요약하면\nObject를 1개 받아 Field값들을 읽는다. Masking Annotation(Custom Annotation) 존재 여부 확인 후 Masking 처리를 시도한다. 따로 정의한 MaskingType enum class 을 참조하여 regex pattern을 받아 replaceAll 처리한다. 단, 정의된 pattern이 없을 시 Case에 따라 따로 Masking 처리를 한다. 세세한 내용들은 source 단을 확인한다.\n추가적으로 https://github.com/HyoseungJeon/JPA 에 내용이 작성되어있으니 참고한다.\n실제로 완벽한 source는 아니다. Collection Type을 List만 처리해 놓은 부분과 내부 Field 내의 Collection 처리 부분 custom Masking 처리 부분의 분리 등등 정리하지 못한 내용이 많다. 차차 내 나름대로의 version Update가 필요해 보인다..\n하지만 내가 집중하고 싶은 부분은 위 방법을 통해서 Masking 과정이 굉장히 간편해졌다.\n실제 response에 담을 Dto 객체에 Masking이 필요한 Field위에 annotation을 입력 후, method에 넘기기만 한다면 Masking 처리가 된다. 프로젝트 내에서는 문제 없이 잘 활용하였다. 위 code를 작성한 프로젝트 이전에는 이미 만들어져 있는 Masking Framwork을 따라 쉽게 작성하여 내부 logic을 파악하지 못하여 내 주관대로 작성한 부분이 있어 아쉽지만 위와 같은 과정을 거쳤을 거라고 생각한다.\nReflectionUtils Spring에서 제공하는 Reflection API를 활용하기 위한 interface Util class를 발견했다!새로 투입된 프로젝트 내의 Masking Source를 탐험하던 중 해당 Lib를 보게 되었다…!😍\n기존 Reflection을 raw 방식으로 활용할 때에는 Exception 처리나 내가 예상하지 못하는 error 들을 발견하거나 방지하기가 어려웠다.. 😢 근데 해당 Lib 내용을 살펴보니 발견하지 못했던 issue들을 처리한 code를 볼 수 있었다! Spring이 Reflection을 활용하다 보니 당연하게도 안정적으로 제공하는 Util이 있을 것인데.. 생각을 못해봤던 것 같다..! 구글링도 좋지만 확실히 source 단에서도 관련 lib을 검색해보는 것도 필요한 것 같다!\npublic static void doWithFields(Class\u0026lt;?\u0026gt; clazz, FieldCallback fc, @Nullable FieldFilter ff) { Class\u0026lt;?\u0026gt; targetClass = clazz; do { Field[] fields = getDeclaredFields(targetClass); Field[] var5 = fields; int var6 = fields.length; for(int var7 = 0; var7 \u0026lt; var6; ++var7) { Field field = var5[var7]; if (ff == null || ff.matches(field)) { try { fc.doWith(field); } catch (IllegalAccessException var10) { throw new IllegalStateException(\u0026#34;Not allowed to access field \u0026#39;\u0026#34; + field.getName() + \u0026#34;\u0026#39;: \u0026#34; + var10); } } } targetClass = targetClass.getSuperclass(); } while(targetClass != null \u0026amp;\u0026amp; targetClass != Object.class); } 특히 fields들을 조회하는 method를 보면 targetClass = targetClass.getSuperclass(); 부분이 있다! extend하는 경우는 생각하지 못했었는데.. 이러한 처리 부분이 있는 걸 보고 좀 쇼킹했다!\n내 생각 장점 정확히 정의된 Class를 입력 받는 것이 아닌, 추상화 상태의 Class를 통해 조작을 하니 넓은 범위를 커버 가능한 method를 작성할 수 있다는 게 큰 장점인 것 같다. 실제로 Spring이 구현될 수 있었던 핵심 spec 아닐까..?\n단점 OOP의 원칙인 캡슐화를 부숴버린다!! 생각보다 심각한 문제라고 생각이 들긴 하는데 만약 해당 method가 정확하게 guide 된 것에 따라가지 않는다면 사용자는 확인하기 어려운 이슈가 발생할 수 있을 것 같다!\n또한 연관 검색어로 항상 성능 이슈가 나온다! 그 원인은 Compiler의 최적화 단계를 거치지 않기 때문이라고 한다. 해서 무거운 logic이나 무분별하게 도입하는 거는 지양해야 할 것 같다.\nhttps://lob-dev.tistory.com/entry/Java의-Reflection-API\n정리 Relection은 내 눈에는 보이지 않지만 수많은 Lib 내에서 나의 개발을 유연하게 돕는 역할로 매우 많이 쓰이는 API 이다. 그 기능을 이용하여 실제로 개발을 해보니 정말로 강력한 기능이라는 느낌이 들었다. 항상 Java 개발을 하면서 “아 이런 부분은 field로 조작해서 할 수 있지 않을까?” 라고 생각해 왔던 것들을 프로젝트 내에서 실제로 구현해보고, 해당 방식을 통하여 기존의 source의 길이가 어마어마하게 줄어들고, 유지보수도 매우 쉬어지는 것을 경험했다.\n단순히 내가 구현을 해보며 느낀 장점 뿐만 아니라 실제로 프로젝트에 사용되는 주요 FrameWork들의 구현 방법에 대하여 알게 되어 조금 더 FrameWork의 구조를 파악하고 또 debugging 할 수 있는 영역이 늘어난 점도 매우 좋은 것 같다. 더욱 넓은 시각을 통해서 단순히 낮은 soruce level이 아닌 구조 전체를 통해서 문제를 파악하는 능력이 큰 것 같다!\n항상 생각하는 거지만, 그냥 편의를 누리는 것은 개발자에게 가장 치명적인 독인 것 같다.. 그냥 납득하지 말자!\n참조:\nhttps://docs.oracle.com/javase/8/docs/technotes/guides/reflection/index.html\nhttps://lob-dev.tistory.com/entry/Java의-Reflection-API\nhttps://gyrfalcon.tistory.com/entry/Java-Reflection\n","permalink":"https://HyoseungJeon.github.io/posts/java/reflection/","summary":"Reflection이란? 정의 Reflection enables Java code to discover information about the fields, methods and constructors of loaded classes, and to use reflected fields, methods, and constructors to operate on their underlying counterparts, within security restrictions. The API accommodates applications that need access to either the public members of a target object (based on its runtime class) or the members declared by a given class. It also allows programs to suppress default reflective access control.","title":"Reflection"},{"content":" Generic이란? Oracle Java Docs에서는 A generic type is a generic class or interface that is parameterized over types. 라고 설명하고 있다.\nType을 매개 변수로 받는 class, interface 라고 해석이 되는 듯하다..? 😂\n즉, class를 정의할 때에 바깥에서 class 내부 field의 type를 정의할 수 있는 방법이다.\n하여 객체를 선언할 때 class는 같지만 field Type이 다른 형태로 만들 수 있다. 우리가 가장 익숙한 곳은 아마 Collection Lib 를 사용할 때 일거다.\n사용법 문법 \u0026lt;WORD\u0026gt; 화살 괄호 쌍 안에 class 내에서 사용할 type의 가상 keyWord를 선언 후 사용하는 방식이다. 일반적인 변수 선언과 크게 다르지 않다. 이를 type 변수라고 부른다.\n/** * Generic version of the Box class. * @param \u0026lt;T\u0026gt; the type of the value being boxed */ public class Box\u0026lt;T\u0026gt; { // T stands for \u0026#34;Type\u0026#34; private T t; public void set(T t) { this.t = t; } public T get() { return t; } } public class Main { public static void main (String[] args) { Box\u0026lt;String\u0026gt; box1 = new Box\u0026lt;\u0026gt;(); Box\u0026lt;Integer\u0026gt; box2 = new Box\u0026lt;\u0026gt;(); box1.set(\u0026#34;box 1\u0026#34;); box2.set(2); System.out.prlntln(box1.get()); System.out.prlntln(box2.get()); } } 명명 규칙 매개변수 이름은 자유롭게 선언할 수 있으나 Java Doc에서 권장하는 일반적 규칙이 존재합니다.\nE - Element K - 키 N - 숫자 T - Type V - Value S, U, V… - 2nd, 3rd, 4th… 다른 Lib source 본다면 대체적으로 해당 규칙을 따르는 것을 알 수 있다. 해당 규칙을 통하여 어떠한 유형 값을 받는지도 자연스럽게 파악할 수 있다!\n주의사항 Generic Type Class 선언 시 해당 type은 원시형은 사용할 수 없다. 실제로 동작 시 참조 형식으로 동작하게 됨으로 자연스럽게 wrapper 형태의 참조형 type을 사용해야 한다.\n복수 type Parameter type 변수는 단일이 아닌 복수로 사용할 수 있다. 문법은 단순히 괄호 안에 , 로 다음 변수를 정의하면 끝이다. 사용법 또한 같다.\npublic interface Pair\u0026lt;K, V\u0026gt; { public K getKey(); public V getValue(); } public class OrderedPair\u0026lt;K, V\u0026gt; implements Pair\u0026lt;K, V\u0026gt; { private K key; private V value; public OrderedPair(K key, V value) { this.key = key; this.value = value; } public K getKey()\t{ return key; } public V getValue() { return value; } } Pair\u0026lt;String, Integer\u0026gt; p1 = new OrderedPair\u0026lt;String, Integer\u0026gt;(\u0026#34;Even\u0026#34;, 8); Pair\u0026lt;String, String\u0026gt; p2 = new OrderedPair\u0026lt;String, String\u0026gt;(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;); Parameterized Types value 변수 정의 시 다른 class를 type으로 정의할 수 있듯이 type 변수로 다른 Generic class를 넣을 수 있다!\nOrderedPair\u0026lt;String, **Box\u0026lt;Integer\u0026gt;**\u0026gt; p = new OrderedPair\u0026lt;\u0026gt;(\u0026#34;primes\u0026#34;, new Box\u0026lt;Integer\u0026gt;(...)); 장점 Compile 단계에서 type 관련한 문제 발생을 미리 방지할 수 있다.\n기존 Generic 기능이 없을 때에는 일반적 최상위 Class인 Object type을 정의하여 필요에 따라 type casting을 하여 기능을 구현하였다. 하지만 이는 자원 소모가 심하고 또 개발자가 예상치 못한 error 발생 시킬 가능성이 높았다.\ntype Casting 자원 소비가 없다.\ncompile 단계에서 선언한 type을 미리 mapping 하여 치환 후 build 함으로 인해 과거 Object 로 구현하던 때의 casting 자원도 아낄 수 있게 되어 성능에도 큰 이점을 가져왔다.\nETC Generic method, type 범위 정의, wild card 문법 등 나머지 Generic 관련한 추가적인 정보는 참조 blog들에 내용 정리가 잘 되어있다..!\n정리 내가 사용하는 method나 class에 가변적인 type이 들어가고, 선언하는 외부에서 그 type을 정할 수 있다는 점은 매우 매력적인 장점으로 보인다. 실제로 lib안의 generic 사용 예제들을 보면 개발자에게 많은 편의를 제공하고, 추가적으로 많은 에러를 자연스럽게 피할 수 있게 도와준다. 해당 기술에 대해 알게 된 점은 이 기술을 활용하는 법 보다는 이를 통해 우리가 Java 언어 환경 속에서 많은 error와 낭비를 피해왔구나 라는 것을 느꼈다. 특히 generic 은 처음 마주했을 때에는 조금 난해했고 실제로 사용할 때에도 불편하다는 생각이 들었다. 하지만 이에 대해 배우고 그 장점을 다시 쳐다보았을 때 실제로 이를 통해 누렸던 장점들이 정말 많이 와닿았다.\n하지만 실제로 이를 개발에서 활용할 방법에 대해서는 아직 해메이고 있다. 실제로 Masking 공통을 구현할 때에 처리할 class를 type 변수로 받아 처리하는 등의 시도를 해보았는데, 결국은 reflection 기술을 활용해 작업을 하여 의미가 없었다. 물론 이는 내 지식의 한계점 때문에 그런 걸 수도 있지만 본 기술의 특성 상 장점도 명확하지만 활용할 수 있는 점도 명확하다고 느꼈다. 자료들을 많이 찾아 보았지만 실제로 효과적인 예는 잘 보지 못했다.. (🤷‍♂️ 검색 실력의 한계일 수도 있다..) 실제 Project에서 활용할 만한 예는 그다지 였다.. 하지만 내가 직접 사용하여 개발을 하지 않아도 언어가 제공하는 기술의 장점에 대한 것을 깨우친 것 만으로도 아주 만족스럽고 또 재밌던 Java spec 였다!\n출처 :\nhttps://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%A0%9C%EB%84%A4%EB%A6%ADGenerics-%EA%B0%9C%EB%85%90-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%B3%B5%ED%95%98%EA%B8%B0\nJAVA] - 제네릭(Generic)의 이해\nGeneric Types (The Java™ Tutorials \u0026gt; Learning the Java Language \u0026gt; Generics (Updated))\n","permalink":"https://HyoseungJeon.github.io/posts/java/generic/","summary":"Generic이란? Oracle Java Docs에서는 A generic type is a generic class or interface that is parameterized over types. 라고 설명하고 있다.\nType을 매개 변수로 받는 class, interface 라고 해석이 되는 듯하다..? 😂\n즉, class를 정의할 때에 바깥에서 class 내부 field의 type를 정의할 수 있는 방법이다.\n하여 객체를 선언할 때 class는 같지만 field Type이 다른 형태로 만들 수 있다. 우리가 가장 익숙한 곳은 아마 Collection Lib 를 사용할 때 일거다.","title":"Generic"},{"content":" 알게된 계기 이전 포스팅에서 Java의 Future 관련한 내용을 작성했었다. 그 내용을 요약하면 메일, 문자 발송 시스템의 처리 시간이 너무 불필요하게 길다는 것 이였다. 그 문제의 원인은 결국 blocking 발생 이였다. 하지만 Future 를 통하여 구현된 부분은 request 송신에 공통으로 사용된 부분 이였고 이와 별개로 내부 process Logic내에서 필요 없는 cost를 통해 지연이 발생하였고 하여 이를 병렬 처리하는 것이 필요했다. 하여 내용을 찾아보던 중 Spring에서 비동기 method 기능을 지원한다는 것을 발견하였다.\n@Async란? Async는 Spring 에서 제공하는 비동기 method 지원 annotation 으로 Java의 Thread pool을 이용하여 해당하는 method 병렬 처리를 가능하게 한다.\n기존의 Java Exceutor를 사용한 병렬 처리 구현 방법보다 간편하고, annotation을 통해서 쉽게 사용할 수 있다는 장점이 있다. 하지만 Spring의 AOP 방식을 이용하여 구현된 기능으로 그 한계가 같다는 점이 있다.\n사용 방법 기본 사용 방법은 Spring Application class에 @EnableAsync를 달아 Async 기능 사용을 열어주고, 비동기로 사용할 method에 @Async annotation을 달아주면 끝이다.\n하지만 이는 SimpleAsyncTaskExecutor를 사용하게 됨으로 Thread를 따로 관리할 수는 없고 단순히 생성만 하여 사용하게 된다.\n@EnableAsync @SpringBootApplication public class DemoApplication {public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } /* ============================================== */ @Service @RequiredArgsConstructor public class TestService { @Async(\u0026#34;sampleExecutor\u0026#34;) public void testAsync(String message){ for(int i = 1; i \u0026lt;= 3; i++){ System.out.println(message + \u0026#34;비동기 : \u0026#34; + i); } } } 때문에 실제로는 Custom Thread Pool을 생성하여 관리를 하게 한다.\n@Configuration @EnableAsync public class AsyncConfig { private int CORE_POOL_SIZE = 3; private int MAX_POOL_SIZE = 10; private int QUEUE_CAPACITY = 100_000; @Bean(name = \u0026#34;sampleExecutor\u0026#34;) public Executor threadPoolTaskExecutor(){ ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); taskExecutor.setCorePoolSize( CORE_POOL_SIZE ); taskExecutor.setMaxPoolSize( MAX_POOL_SIZE ); taskExecutor.setQueueCapacity( QUEUE_CAPACITY ); taskExecutor.setTaskDecorator( new CustomDecorator() ); // 데코레이터 적용 taskExecutor.setThreadNamePrefix( \u0026#34;Executor-\u0026#34; ); taskExecutor.setRejectedExecutionHandler( new ThreadPoolExecutor.CallerRunsPolicy() ); return taskExecutor; } 실제로 Thread Pool 통하여 관리하는 방식으로 사용할 때에는 Application 단의 @EnableAsync annotation을 지우고 Configuration 단에 Spring의 Async을 수행할 Thread Pool 정의 Config Class를 생성한다. 하고 해당 Annotation을 Class에 선언한다.\n후에 실제로 Executor을 생성하여 정의 하게 되는데 그 옵션은 아래와 같다.\nTaskExecutor Options corePoolSize\n기본적으로 활성화 된 thread의 개수 (Defalut : 1)\nmaxPoolSize\nQueue Capacity 이상의 요청이 들어올 경우, Thread Pool에 생성 가능한 최대 Thread 수 (Default : Integer.MAX_VALUE)\nqueueCapacity\nCorePoolSize 이상의 요청이 들어올 경우, Linked Blocking Queue 라는 공간에 task를 대기 시킨다, 해당 Quque 공간의 Capa (Default : MAX_VALUE)\ntaskDecorator\n해당 task를 Thread에 할당하기 전 작업을 Custom 정의할 수 있는 class, decorate method override를 통하여 해당 내용 작성\n→ 위 예제에서는 requestContext 내 정보를 복사\nthreadNamePrefix\n할당된 thread의 Prefix name 정의 (ex : “SAMPLE-SERVICE- “)\nrejectedExecutionHandler\n거부된 작업을 이후 Handling Policy를 정의\nAbortPolicy : 작업이 거부되면 RejectedExecutionException을 던진다. CallerRunsPolicy : Async 메소드를 불렀던 메인 스레드에서 거부된 작업을 실행한다. DiscardOldestPolicy : 큐에서 가장 오래된 task를 제거하고 실행시킨다. DiscardPolicy : Reject된 Task에 대해 어떠한 작업도 진행하지 않는다. 예외처리 thread와 관련하여 capacity 초과로 인한 Error와 같은 Exception 들을 처리 해놓는 부분이 필수적으로 필요하다.\n해당 예외로 인하여 작업이 실행되지 않고, log나 해당 Data 적재도 제대로 되지 않을 경우가 발생할 수 있다.\n@Configuration @EnableAsync public class AsyncConfig implements AsyncConfigurer {// 추가 private int CORE_POOL_SIZE = 3; //~~~~ //override method @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() { return new AsyncExceptionHandler();// 추가 } } @Slf4j public class AsyncExceptionHandler implements AsyncUncaughtExceptionHandler { @Override public void handleUncaughtException(Throwable ex, Method method, Object... params) { log.error( ex.getMessage(), ex ); } } Config class에 AsyncConfigurer class를 impl, getAsyncUncaughtExceptionHandler 를 정의하여 Exception Handler를 작성한다.\n위와 같은 Handler를 따로 정의하여 관리하는 방법이 효과적일 것 같다.\nCheckPoint 접근 제한자는 public만 가능하다.\n본 기능은 Spring AOP에 의해 구현되어 Proxy 객체를 기반으로 수행 됨으로 접근 권한이 public 하여야 한다.\n자가 호출 형태는 적용되지 않는다.\n실제로 error를 터트리진 않지만 할당한 ThreadPool 통해 병렬 처리 되진 않는다.\n이도 역시 AOP 때문이다.\nrequest Context 사용이 불가능 하다.\n새로운 Thread를 생성하기 때문에 기존 request 정보가 포함된 Context는 존재하지 않는다. 때문에 필요하다면 taskDecorator 를 통한 context copy 과정이 필요하다.\nException\n새로운 Thread 임으로 호출한 thread 까지 Exception이 전달되지 않는다. 하지만 return 값이 존재하는 형태라면 별도로 처리가 가능하다.\n느낀점 Java의 병렬 programing 관련하여 여러가지 방식들을 보게 되었는데 확실히 Spring이 상대적으로 복잡했던 Thread Pool 관련한 병렬 프로그래밍 방식들을 쉽게 처리할 수 있게 구현해 놓은 것 같다. 상대적으로 복잡한 설계가 필요 없었고 Config, annotataion 두개의 source로 실제 프로젝트에 굉장히 쉽게 병렬 처리를 적용했다. 실제로 해당 단위의 처리 시간이 16초에서 6초 가량으로 많이 줄었다. 다음 번엔 함께 사용했던 CompletableFuture 관련한 글을 쓰겠다!\n출처:\nAsync (Spring Framework 6.0.11 API)\n[Spring] @Async 비동기 멀티스레드 사용법\n","permalink":"https://HyoseungJeon.github.io/posts/spring/async/","summary":"알게된 계기 이전 포스팅에서 Java의 Future 관련한 내용을 작성했었다. 그 내용을 요약하면 메일, 문자 발송 시스템의 처리 시간이 너무 불필요하게 길다는 것 이였다. 그 문제의 원인은 결국 blocking 발생 이였다. 하지만 Future 를 통하여 구현된 부분은 request 송신에 공통으로 사용된 부분 이였고 이와 별개로 내부 process Logic내에서 필요 없는 cost를 통해 지연이 발생하였고 하여 이를 병렬 처리하는 것이 필요했다. 하여 내용을 찾아보던 중 Spring에서 비동기 method 기능을 지원한다는 것을 발견하였다.","title":"Async"},{"content":" 개발 블로그를 처음으로 개설했다..!\n사실 이전부터 블로그를 만들어 보려고 했지만 그 필요성을 잘 느끼지 못하여.. 만들지 않았다..! 무언가 다른 개발자들에게 정확하지 않은 정보를 전달하게 되거나 혹은 그냥 포트폴리오를 보여주기 위한 도구 같다고만 느꼈다..\n근데 실제 취업 후 여러 프로젝트를 진행해보며 여러 장애들을 겪고 또 야근을 하며 개발을 해보며 지내본 결과.. 내 경험을 모두 머리속에 기억하기는 정말로 어렵다.. 기존에는 노트나 메모지에 적어두고 기록해 왔었는데 실제로 해당 내용을 다시 찾을 때에는 너무 시간이 오래 걸리고 때때로 급한 마음에 마구마구 갈겨 쓴 글씨 때문에 나 조차도 못알아보는 기록들이 너무 많았다 ㅠ\u0026hellip;\n해서!! 이제부터는 내 블로그를 통해 내가 기억해야 할 경험들을 기록해두려고 한다..! 화이팅\u0026hellip;!!!\n","permalink":"https://HyoseungJeon.github.io/posts/%EC%9D%BC%EA%B8%B0%EC%9E%A5/23-07-18/","summary":"개발 블로그를 처음으로 개설했다..!\n사실 이전부터 블로그를 만들어 보려고 했지만 그 필요성을 잘 느끼지 못하여.. 만들지 않았다..! 무언가 다른 개발자들에게 정확하지 않은 정보를 전달하게 되거나 혹은 그냥 포트폴리오를 보여주기 위한 도구 같다고만 느꼈다..\n근데 실제 취업 후 여러 프로젝트를 진행해보며 여러 장애들을 겪고 또 야근을 하며 개발을 해보며 지내본 결과.. 내 경험을 모두 머리속에 기억하기는 정말로 어렵다.. 기존에는 노트나 메모지에 적어두고 기록해 왔었는데 실제로 해당 내용을 다시 찾을 때에는 너무 시간이 오래 걸리고 때때로 급한 마음에 마구마구 갈겨 쓴 글씨 때문에 나 조차도 못알아보는 기록들이 너무 많았다 ㅠ\u0026hellip;","title":"23.07.18"},{"content":" dateObj.setDate(dayValue) var theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(24); // 1962-07-24 theBigDay.setDate(22); // 1962-08-22 해당 Date 객체의 날짜(day)를 설정하는 함수\n입력된 dayValue 값으로 날짜를 변경 한다.\n별로 특이해 보이지 않지만 변경 이라는 부분 때문에 보이지 않는 에러가 발생한 경우가 있다.\n위 기능을 통하여 js 내에서 날짜를 변경 하게 되는데\nvar theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(32); // 1962-08-01 theBigDay.setDate(0); // 1962-07-31 예제와 같이 날짜 범위를 자동으로 계산해 Date를 set 한다.\nvar theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(threeDaysAgo.getDate() + 3); // 1962-07-10 theBigDay.setDate(threeDaysAgo.getDate() - 3); // 1962-07-07 해서 Date를 더하거나 빼는 경우에는 자신의 Date 값을 참조하여 다시 setDate 하는 방식을 사용한다.\n하지만!! 문제는 자신의 값을 참조하는 부분에서 오류가 발생한다.\n/** * 시작날짜, 종료날짜 세팅 * * @param { Number } dayNum 날짜 수 * @returns { Date } { startDate, endDate } */ export function initRangeDate(dayNum) { const baseDate = 2 const startDate = new Date() const endDate = new Date() startDate.setDate(startDate.getDate() + baseDate) /* 날짜 adding 관련 이슈사항 */ // 1. 다른 Date 객체 참조 endDate.setDate(startDate.getDate() + dayNum) // 2. 자신 Date 참조 endDate.setDate(endDate.getDate() + baseDate + dayNum) /* setDate는 param의 숫자 그대로 setting 때문에 다른 객체 참고시 해당 객체의 값 변화에 의하여 의도하지 않은 날짜로 set 가능성 생김 때문에 무조건 자신을 참고하는 방식으로 사용 소스에 기준이 되는 전역값 분리 및 활용 */ return { startDate, endDate } } 위 예제는 현재 날짜 기준, param1 만큼 날짜의 범위를 가진 두 데이터 객체를 반환하는 method 이다.\n위 소스에서 1. 부분을 본다면 나는\n종료 일자를 시작 일자의 param1 값 만큼 더하여 종료 일자를 계산할 수 있다고 생각했다.\n하지만 실제로 소스에서는 문제가 발생한다!\nstartDate.getDate() + baseDate 의 값이 다음달의 날짜로 넘어가지 않는다면 문제가 발생하지 않지만, 넘어 간다면? n달의 오차가 생기게 된다!\n해서 프로젝트 내에서는 실제로 달의 마지막 2일 전, baseDate만큼의 차이가 날 때 문제가 발견되었다.. 테스트 기간에는 다행히..? 중순 쯤이라 문제를 발견하지 못하였다.. 내 잘못이다..\n실제로 new Date().getDate() 의 return 값은 날짜이기 때문에 변하지 않은 자신의 값을 참조하여 setDate를 할 때에는 문제가 발생하지 않는다.\n하지만 이외의 객체를 참고한다면 위와 같이 예상치 못한 값 변화를 초래할 수 있다..!\n결론은 굉장히 단순하지만\n// 1. 다른 Date 객체 참조 endDate.setDate(startDate.getDate() + dayNum) // 2. 자신 Date 참조 endDate.setDate(endDate.getDate() + baseDate + dayNum) js 내에선 Date 값을 조절할 때에는 무조건 자신의 객체를 참고하여 setting 되어야 한다는 사실이다.\n아무래도 java나 C++ 언어에 익숙했던 경험 때문인지 1. 와 같은 소스가 문제가 없을 것이라고 판단했던 것 같다.. 혹은 해당 setDate를 addDate 라고 나도 모르게 인식하고 있었던 것 같다.\n항상 정확한 사용 방법을 따라 개발해야 한다..!\n참조\nDate.prototype.setDate() - JavaScript | MDN\n","permalink":"https://HyoseungJeon.github.io/posts/javascript/date/setdate/","summary":"dateObj.setDate(dayValue) var theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(24); // 1962-07-24 theBigDay.setDate(22); // 1962-08-22 해당 Date 객체의 날짜(day)를 설정하는 함수\n입력된 dayValue 값으로 날짜를 변경 한다.\n별로 특이해 보이지 않지만 변경 이라는 부분 때문에 보이지 않는 에러가 발생한 경우가 있다.\n위 기능을 통하여 js 내에서 날짜를 변경 하게 되는데\nvar theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(32); // 1962-08-01 theBigDay.setDate(0); // 1962-07-31 예제와 같이 날짜 범위를 자동으로 계산해 Date를 set 한다.","title":"setDate"},{"content":" 프로젝트를 옮기고 Spring 프로젝트를 세팅 하는 중 build error가 발생하였다!\n그 중 익숙하지 않은 build error가 있었는데\nThymeleaf 관련 Directory를 추적하지 못하여 file not found Error가 나왔다..!\n알고 보니 따로 Template Engine을 설정하여 Project를 생성한 경우가 아닐 시 자동으로 추적 경로가 등록되지 않는 경우 같더라..\n내용을 추가적으로 찾아보니 Maven의 경우 따로 실행 Configurations 내 Working Directory 잡아주어야 한다는 내용을 찾았다..!\nThymeleaf 프로젝트 build 시 Maven 관리 도구를 사용 중이고 따로 importing 한 프로젝트 라면 /WEB-INF/\nDirectory를 자동으로 추적하지 못하는 경우가 발생할 수 있다!!\n때문에 해당 프로젝트 실행 환경의 Working directory 내에\n$MODULE_WORKING_DIR$\n경로를 추가하여야 한다.\n참조\nhttps://stackoverflow.com/questions/33459740/error-no-url-for-servletcontext-resource-when-running-spring-integrated-test\n","permalink":"https://HyoseungJeon.github.io/posts/intellij/thymeleaf/","summary":"프로젝트를 옮기고 Spring 프로젝트를 세팅 하는 중 build error가 발생하였다!\n그 중 익숙하지 않은 build error가 있었는데\nThymeleaf 관련 Directory를 추적하지 못하여 file not found Error가 나왔다..!\n알고 보니 따로 Template Engine을 설정하여 Project를 생성한 경우가 아닐 시 자동으로 추적 경로가 등록되지 않는 경우 같더라..\n내용을 추가적으로 찾아보니 Maven의 경우 따로 실행 Configurations 내 Working Directory 잡아주어야 한다는 내용을 찾았다..!\nThymeleaf 프로젝트 build 시 Maven 관리 도구를 사용 중이고 따로 importing 한 프로젝트 라면 /WEB-INF/","title":"Thymeleaf"},{"content":" Future란? Java 1.5에 공개된 비동기 process 처리를 지원하는 interface Class 이다.\n비동기 방식을 지원하기 위해 당연하게도 mulitThread 방식을 활용하여 해당 기능을 지원하고 있다. 기존의 Thread 직접 선언 및 관리 방식과 다르게 interface를 활용하여 비동기를 구현할 수 있어 안정적인 비동기 구현 방법이다.\n해당 비동기 process를 호출 thread에서 사용 가능하다.\n단, 해당 값 조회를 시도할 시 blocking 상태로 변화하여 지연이 발생할 수 있다.\nMethods V get(), get(Long time, TimeUnit unit)\n실행 결과 값을 조회하는 method\n호출 시 해당 작업이 완료 될 때 까지 blocking 상태로 전환된다.\n매개변수 2개를 받을 시 해당 값 만큼 TimeOut 시간이 설정된다.\n작업이 지연될 경우, TimeoutException을 발생시킨다.\nboolean isDone()\n현재 작업의 완료 상태를 체크한다.\n어떠한 경우든 작업이 실행 중인 상태가 아니라면 true를 반환한다.\nboolean cancel(boolean mayInterruptIfRunning)\n현재 실행 중인 작업을 중단 시킨다.\nmayInterruptIfRunning 값이 true인 경우 해당 작업의 Thread 중단되어야 하는 경우 중단 시킨다. 그렇지 않은 경우에는 작업을 완료할 수 있다.\nFuture lib:\nif the thread executing this task should be interrupted\notherwise, in-progress tasks are allowed to complete\n정상 취소 성공 시 true return 한다.\nboolean isCancelled()\ncancel method를 통하여 정상 cancel 일 시 true를 return 한다.\n예제 소스 //ExecutorService 초기화 ExecutorService executor = Executors.newSingleThreadExecutor(); //Callable Task 생성 Callable\u0026lt;String\u0026gt; callableTask = () -\u0026gt; { System.out.println(LocalTime.now() + \u0026#34; Task Start\u0026#34;); Thread.sleep(1000L); return \u0026#34;Task Result\u0026#34;; }; //submit() 메서드로 Task 실행 Future\u0026lt;String\u0026gt; future = executor.submit(callableTask); System.out.println(LocalTime.now() + \u0026#34; Waiting the task done\u0026#34;); System.out.println(\u0026#34;isDone 1 = \u0026#34; + future.isDone()); String result = future.get(); //Task 결과 대기 System.out.println(\u0026#34;isDone 2 = \u0026#34; + future.isDone()); System.out.println(LocalTime.now() + \u0026#34; future.get() = \u0026#34; + result); //실행 결과 23:09:32.917 Waiting the task done isDone 1 = false 23:09:32.918 Task Start isDone 2 = true 23:09:33.922 future.get() = Task Result 내 경험 23년 3월 쯔음에 특정 프로세스를 excel file 단위로 처리하는 작업을 진행하였다. 업무 자체로는 문제가 없었는데 해당 프로세스는 완료 후 sms/email을 발송하는 logic이 있었다.\n때문에 bulk 단위 작업 시 해당 api 응답이 1분 가까이 소요되는 상태였다. 해당 부분이 issue로 올라왔다.\n실제 지연이 크게 발생한 이유는 DB Data 조작 시간 소요는 크지 않았는데 sms/email 발송 부분에서 30초 가량의 시간을 잡아먹고 있었다.\n내부 소스는 Future interface를 잉\n참조:\n","permalink":"https://HyoseungJeon.github.io/posts/java/future/","summary":"Future란? Java 1.5에 공개된 비동기 process 처리를 지원하는 interface Class 이다.\n비동기 방식을 지원하기 위해 당연하게도 mulitThread 방식을 활용하여 해당 기능을 지원하고 있다. 기존의 Thread 직접 선언 및 관리 방식과 다르게 interface를 활용하여 비동기를 구현할 수 있어 안정적인 비동기 구현 방법이다.\n해당 비동기 process를 호출 thread에서 사용 가능하다.\n단, 해당 값 조회를 시도할 시 blocking 상태로 변화하여 지연이 발생할 수 있다.\nMethods V get(), get(Long time, TimeUnit unit)\n실행 결과 값을 조회하는 method","title":"Future"},{"content":"","permalink":"https://HyoseungJeon.github.io/spring/","summary":"","title":"Spring"},{"content":"","permalink":"https://HyoseungJeon.github.io/ch/","summary":"","title":"첫 포스트"},{"content":" 설명 Spring 2.0 부터 추가된 기능으로 Request 인입 후 thread 생성 된 시점부터 전 구간에서 HttpServletRequest에 접근을 가능하게 해주는 기능이다.\n기존 Controller 단에 parameter 형식으로 선언 후 참고하던 방식과 다르게 위 객체를 통하여 request에 접근이 가능하다.\n예제 소스 :\n@GetMapping(\u0026#34;hello\u0026#34;) public void before(HttpServletRequest request) { sampleService.hello(request); } @GetMapping(\u0026#34;hello\u0026#34;) public void after() { HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest(); sampleService.hello(request); } 동작 원리 Request 인입 시 Spring 내 ThreadLocal 이라는 공간에 값을 저장하는 방식이다. 이름에서도 유추할 수 있듯이 단일 Thread내에 저장되는 방식으로 이외 Thread에서는 값 참조가 불가능하게 된다. 단, Inheritable = true 옵션값을 통하여 중첩 Thread 내에서 부모 Thread 값 참조가 가능하다. 자세한 내용은 ref site 참고\n장점 1차적인 장점으로는 request 객체를 참조하기 위해 매번 parameter에 선언한 필요가 없다는 것이다. 불필요한 코드 작성을 줄이고 가독성을 높여준다.\n전 구간에서 참조 가능하다. Controller에서 request 정보를 받아 다른 Service 내리거나 하는 작업이 생략된다.\n→ 위 점을 활용하여 request 정보를 활용하는 공통 Util class를 구현한다면 베스트 인 것 같다!!\n내 활용 방식 진행하던 프로젝트 내에서 Exception 발생 시 공통으로 인입 된 값을 logging 하는 방식에 활용했다. 기존 APM을 통하여 body 내 값이나 query 방식의 값들을 최적화된 log 값들과 함께 같이 세팅하여 기록하도록 구현하였다.\nrefs: RequestContextHolder (Spring Framework 6.0.11 API)\nRequestContextHolder\nSpring RequestContextHolder - 어디서든 HttpServletReqeust 사용하기\nSpring RequestContextHolder\n","permalink":"https://HyoseungJeon.github.io/posts/spring/requestcontextholder/","summary":"설명 Spring 2.0 부터 추가된 기능으로 Request 인입 후 thread 생성 된 시점부터 전 구간에서 HttpServletRequest에 접근을 가능하게 해주는 기능이다.\n기존 Controller 단에 parameter 형식으로 선언 후 참고하던 방식과 다르게 위 객체를 통하여 request에 접근이 가능하다.\n예제 소스 :\n@GetMapping(\u0026#34;hello\u0026#34;) public void before(HttpServletRequest request) { sampleService.hello(request); } @GetMapping(\u0026#34;hello\u0026#34;) public void after() { HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest(); sampleService.hello(request); } 동작 원리 Request 인입 시 Spring 내 ThreadLocal 이라는 공간에 값을 저장하는 방식이다.","title":"RequestContextHolder"}]