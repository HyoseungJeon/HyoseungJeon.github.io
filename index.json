[{"content":" 알게된 계기 이전 포스팅에서 Java의 Future 관련한 내용을 작성했었다. 그 내용을 요약하면 메일, 문자 발송 시스템의 처리 시간이 너무 불필요하게 길다는 것 이였다. 그 문제의 원인은 결국 blocking 발생 이였다. 하지만 Future 를 통하여 구현된 부분은 request 송신에 공통으로 사용된 부분 이였고 이와 별개로 내부 process Logic내에서 필요 없는 cost를 통해 지연이 발생하였고 하여 이를 병렬 처리하는 것이 필요했다. 하여 내용을 찾아보던 중 Spring에서 비동기 method 기능을 지원한다는 것을 발견하였다.\n@Async란? Async는 Spring 에서 제공하는 비동기 method 지원 annotation 으로 Java의 Thread pool을 이용하여 해당하는 method 병렬 처리를 가능하게 한다.\n기존의 Java Exceutor를 사용한 병렬 처리 구현 방법보다 간편하고, annotation을 통해서 쉽게 사용할 수 있다는 장점이 있다. 하지만 Spring의 AOP 방식을 이용하여 구현된 기능으로 그 한계가 같다는 점이 있다.\n사용 방법 기본 사용 방법은 Spring Application class에 @EnableAsync를 달아 Async 기능 사용을 열어주고, 비동기로 사용할 method에 @Async annotation을 달아주면 끝이다.\n하지만 이는 SimpleAsyncTaskExecutor를 사용하게 됨으로 Thread를 따로 관리할 수는 없고 단순히 생성만 하여 사용하게 된다.\n@EnableAsync @SpringBootApplication public class DemoApplication {public static void main(String[] args) { SpringApplication.run(DemoApplication.class, args); } /* ============================================== */ @Service @RequiredArgsConstructor public class TestService { @Async(\u0026#34;sampleExecutor\u0026#34;) public void testAsync(String message){ for(int i = 1; i \u0026lt;= 3; i++){ System.out.println(message + \u0026#34;비동기 : \u0026#34; + i); } } } 때문에 실제로는 Custom Thread Pool을 생성하여 관리를 하게 한다.\n@Configuration @EnableAsync public class AsyncConfig { private int CORE_POOL_SIZE = 3; private int MAX_POOL_SIZE = 10; private int QUEUE_CAPACITY = 100_000; @Bean(name = \u0026#34;sampleExecutor\u0026#34;) public Executor threadPoolTaskExecutor(){ ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); taskExecutor.setCorePoolSize( CORE_POOL_SIZE ); taskExecutor.setMaxPoolSize( MAX_POOL_SIZE ); taskExecutor.setQueueCapacity( QUEUE_CAPACITY ); taskExecutor.setTaskDecorator( new CustomDecorator() ); // 데코레이터 적용 taskExecutor.setThreadNamePrefix( \u0026#34;Executor-\u0026#34; ); taskExecutor.setRejectedExecutionHandler( new ThreadPoolExecutor.CallerRunsPolicy() ); return taskExecutor; } 실제로 Thread Pool 통하여 관리하는 방식으로 사용할 때에는 Application 단의 @EnableAsync annotation을 지우고 Configuration 단에 Spring의 Async을 수행할 Thread Pool 정의 Config Class를 생성한다. 하고 해당 Annotation을 Class에 선언한다.\n후에 실제로 Executor을 생성하여 정의 하게 되는데 그 옵션은 아래와 같다.\nTaskExecutor Options corePoolSize\n기본적으로 활성화 된 thread의 개수 (Defalut : 1)\nmaxPoolSize\nQueue Capacity 이상의 요청이 들어올 경우, Thread Pool에 생성 가능한 최대 Thread 수 (Default : Integer.MAX_VALUE)\nqueueCapacity\nCorePoolSize 이상의 요청이 들어올 경우, Linked Blocking Queue 라는 공간에 task를 대기 시킨다, 해당 Quque 공간의 Capa (Default : MAX_VALUE)\ntaskDecorator\n해당 task를 Thread에 할당하기 전 작업을 Custom 정의할 수 있는 class, decorate method override를 통하여 해당 내용 작성\n→ 위 예제에서는 requestContext 내 정보를 복사\nthreadNamePrefix\n할당된 thread의 Prefix name 정의 (ex : “SAMPLE-SERVICE- “)\nrejectedExecutionHandler\n거부된 작업을 이후 Handling Policy를 정의\nAbortPolicy : 작업이 거부되면 RejectedExecutionException을 던진다. CallerRunsPolicy : Async 메소드를 불렀던 메인 스레드에서 거부된 작업을 실행한다. DiscardOldestPolicy : 큐에서 가장 오래된 task를 제거하고 실행시킨다. DiscardPolicy : Reject된 Task에 대해 어떠한 작업도 진행하지 않는다. 예외처리 thread와 관련하여 capacity 초과로 인한 Error와 같은 Exception 들을 처리 해놓는 부분이 필수적으로 필요하다.\n해당 예외로 인하여 작업이 실행되지 않고, log나 해당 Data 적재도 제대로 되지 않을 경우가 발생할 수 있다.\n@Configuration @EnableAsync public class AsyncConfig implements AsyncConfigurer {// 추가 private int CORE_POOL_SIZE = 3; //~~~~ //override method @Override public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() { return new AsyncExceptionHandler();// 추가 } } @Slf4j public class AsyncExceptionHandler implements AsyncUncaughtExceptionHandler { @Override public void handleUncaughtException(Throwable ex, Method method, Object... params) { log.error( ex.getMessage(), ex ); } } Config class에 AsyncConfigurer class를 impl, getAsyncUncaughtExceptionHandler 를 정의하여 Exception Handler를 작성한다.\n위와 같은 Handler를 따로 정의하여 관리하는 방법이 효과적일 것 같다.\nCheckPoint 접근 제한자는 public만 가능하다.\n본 기능은 Spring AOP에 의해 구현되어 Proxy 객체를 기반으로 수행 됨으로 접근 권한이 public 하여야 한다.\n자가 호출 형태는 적용되지 않는다.\n실제로 error를 터트리진 않지만 할당한 ThreadPool 통해 병렬 처리 되진 않는다.\n이도 역시 AOP 때문이다.\nrequest Context 사용이 불가능 하다.\n새로운 Thread를 생성하기 때문에 기존 request 정보가 포함된 Context는 존재하지 않는다. 때문에 필요하다면 taskDecorator 를 통한 context copy 과정이 필요하다.\nException\n새로운 Thread 임으로 호출한 thread 까지 Exception이 전달되지 않는다. 하지만 return 값이 존재하는 형태라면 별도로 처리가 가능하다.\n느낀점 Java의 병렬 programing 관련하여 여러가지 방식들을 보게 되었는데 확실히 Spring이 상대적으로 복잡했던 Thread Pool 관련한 병렬 프로그래밍 방식들을 쉽게 처리할 수 있게 구현해 놓은 것 같다. 상대적으로 복잡한 설계가 필요 없었고 Config, annotataion 두개의 source로 실제 프로젝트에 굉장히 쉽게 병렬 처리를 적용했다. 실제로 해당 단위의 처리 시간이 16초에서 6초 가량으로 많이 줄었다. 다음 번엔 함께 사용했던 CompletableFuture 관련한 글을 쓰겠다!\n출처:\nAsync (Spring Framework 6.0.11 API)\n[Spring] @Async 비동기 멀티스레드 사용법\n","permalink":"https://HyoseungJeon.github.io/posts/spring/async/","summary":"알게된 계기 이전 포스팅에서 Java의 Future 관련한 내용을 작성했었다. 그 내용을 요약하면 메일, 문자 발송 시스템의 처리 시간이 너무 불필요하게 길다는 것 이였다. 그 문제의 원인은 결국 blocking 발생 이였다. 하지만 Future 를 통하여 구현된 부분은 request 송신에 공통으로 사용된 부분 이였고 이와 별개로 내부 process Logic내에서 필요 없는 cost를 통해 지연이 발생하였고 하여 이를 병렬 처리하는 것이 필요했다. 하여 내용을 찾아보던 중 Spring에서 비동기 method 기능을 지원한다는 것을 발견하였다.","title":"Async"},{"content":" 개발 블로그를 처음으로 개설했다..!\n사실 이전부터 블로그를 만들어 보려고 했지만 그 필요성을 잘 느끼지 못하여.. 만들지 않았다..! 무언가 다른 개발자들에게 정확하지 않은 정보를 전달하게 되거나 혹은 그냥 포트폴리오를 보여주기 위한 도구 같다고만 느꼈다..\n근데 실제 취업 후 여러 프로젝트를 진행해보며 여러 장애들을 겪고 또 야근을 하며 개발을 해보며 지내본 결과.. 내 경험을 모두 머리속에 기억하기는 정말로 어렵다.. 기존에는 노트나 메모지에 적어두고 기록해 왔었는데 실제로 해당 내용을 다시 찾을 때에는 너무 시간이 오래 걸리고 때때로 급한 마음에 마구마구 갈겨 쓴 글씨 때문에 나 조차도 못알아보는 기록들이 너무 많았다 ㅠ\u0026hellip;\n해서!! 이제부터는 내 블로그를 통해 내가 기억해야 할 경험들을 기록해두려고 한다..! 화이팅\u0026hellip;!!!\n","permalink":"https://HyoseungJeon.github.io/posts/%EC%9D%BC%EA%B8%B0%EC%9E%A5/23-07-18/","summary":"개발 블로그를 처음으로 개설했다..!\n사실 이전부터 블로그를 만들어 보려고 했지만 그 필요성을 잘 느끼지 못하여.. 만들지 않았다..! 무언가 다른 개발자들에게 정확하지 않은 정보를 전달하게 되거나 혹은 그냥 포트폴리오를 보여주기 위한 도구 같다고만 느꼈다..\n근데 실제 취업 후 여러 프로젝트를 진행해보며 여러 장애들을 겪고 또 야근을 하며 개발을 해보며 지내본 결과.. 내 경험을 모두 머리속에 기억하기는 정말로 어렵다.. 기존에는 노트나 메모지에 적어두고 기록해 왔었는데 실제로 해당 내용을 다시 찾을 때에는 너무 시간이 오래 걸리고 때때로 급한 마음에 마구마구 갈겨 쓴 글씨 때문에 나 조차도 못알아보는 기록들이 너무 많았다 ㅠ\u0026hellip;","title":"23.07.18"},{"content":" dateObj.setDate(dayValue) var theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(24); // 1962-07-24 theBigDay.setDate(22); // 1962-08-22 해당 Date 객체의 날짜(day)를 설정하는 함수\n입력된 dayValue 값으로 날짜를 변경 한다.\n별로 특이해 보이지 않지만 변경 이라는 부분 때문에 보이지 않는 에러가 발생한 경우가 있다.\n위 기능을 통하여 js 내에서 날짜를 변경 하게 되는데\nvar theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(32); // 1962-08-01 theBigDay.setDate(0); // 1962-07-31 예제와 같이 날짜 범위를 자동으로 계산해 Date를 set 한다.\nvar theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(threeDaysAgo.getDate() + 3); // 1962-07-10 theBigDay.setDate(threeDaysAgo.getDate() - 3); // 1962-07-07 해서 Date를 더하거나 빼는 경우에는 자신의 Date 값을 참조하여 다시 setDate 하는 방식을 사용한다.\n하지만!! 문제는 자신의 값을 참조하는 부분에서 오류가 발생한다.\n/** * 시작날짜, 종료날짜 세팅 * * @param { Number } dayNum 날짜 수 * @returns { Date } { startDate, endDate } */ export function initRangeDate(dayNum) { const baseDate = 2 const startDate = new Date() const endDate = new Date() startDate.setDate(startDate.getDate() + baseDate) /* 날짜 adding 관련 이슈사항 */ // 1. 다른 Date 객체 참조 endDate.setDate(startDate.getDate() + dayNum) // 2. 자신 Date 참조 endDate.setDate(endDate.getDate() + baseDate + dayNum) /* setDate는 param의 숫자 그대로 setting 때문에 다른 객체 참고시 해당 객체의 값 변화에 의하여 의도하지 않은 날짜로 set 가능성 생김 때문에 무조건 자신을 참고하는 방식으로 사용 소스에 기준이 되는 전역값 분리 및 활용 */ return { startDate, endDate } } 위 예제는 현재 날짜 기준, param1 만큼 날짜의 범위를 가진 두 데이터 객체를 반환하는 method 이다.\n위 소스에서 1. 부분을 본다면 나는\n종료 일자를 시작 일자의 param1 값 만큼 더하여 종료 일자를 계산할 수 있다고 생각했다.\n하지만 실제로 소스에서는 문제가 발생한다!\nstartDate.getDate() + baseDate 의 값이 다음달의 날짜로 넘어가지 않는다면 문제가 발생하지 않지만, 넘어 간다면? n달의 오차가 생기게 된다!\n해서 프로젝트 내에서는 실제로 달의 마지막 2일 전, baseDate만큼의 차이가 날 때 문제가 발견되었다.. 테스트 기간에는 다행히..? 중순 쯤이라 문제를 발견하지 못하였다.. 내 잘못이다..\n실제로 new Date().getDate() 의 return 값은 날짜이기 때문에 변하지 않은 자신의 값을 참조하여 setDate를 할 때에는 문제가 발생하지 않는다.\n하지만 이외의 객체를 참고한다면 위와 같이 예상치 못한 값 변화를 초래할 수 있다..!\n결론은 굉장히 단순하지만\n// 1. 다른 Date 객체 참조 endDate.setDate(startDate.getDate() + dayNum) // 2. 자신 Date 참조 endDate.setDate(endDate.getDate() + baseDate + dayNum) js 내에선 Date 값을 조절할 때에는 무조건 자신의 객체를 참고하여 setting 되어야 한다는 사실이다.\n아무래도 java나 C++ 언어에 익숙했던 경험 때문인지 1. 와 같은 소스가 문제가 없을 것이라고 판단했던 것 같다.. 혹은 해당 setDate를 addDate 라고 나도 모르게 인식하고 있었던 것 같다.\n항상 정확한 사용 방법을 따라 개발해야 한다..!\n참조\nDate.prototype.setDate() - JavaScript | MDN\n","permalink":"https://HyoseungJeon.github.io/posts/javascript/date/setdate/","summary":"dateObj.setDate(dayValue) var theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(24); // 1962-07-24 theBigDay.setDate(22); // 1962-08-22 해당 Date 객체의 날짜(day)를 설정하는 함수\n입력된 dayValue 값으로 날짜를 변경 한다.\n별로 특이해 보이지 않지만 변경 이라는 부분 때문에 보이지 않는 에러가 발생한 경우가 있다.\n위 기능을 통하여 js 내에서 날짜를 변경 하게 되는데\nvar theBigDay = new Date(1962, 6, 7); // 1962-07-07 theBigDay.setDate(32); // 1962-08-01 theBigDay.setDate(0); // 1962-07-31 예제와 같이 날짜 범위를 자동으로 계산해 Date를 set 한다.","title":"setDate"},{"content":" 프로젝트를 옮기고 Spring 프로젝트를 세팅 하는 중 build error가 발생하였다!\n그 중 익숙하지 않은 build error가 있었는데\nThymeleaf 관련 Directory를 추적하지 못하여 file not found Error가 나왔다..!\n알고 보니 따로 Template Engine을 설정하여 Project를 생성한 경우가 아닐 시 자동으로 추적 경로가 등록되지 않는 경우 같더라..\n내용을 추가적으로 찾아보니 Maven의 경우 따로 실행 Configurations 내 Working Directory 잡아주어야 한다는 내용을 찾았다..!\nThymeleaf 프로젝트 build 시 Maven 관리 도구를 사용 중이고 따로 importing 한 프로젝트 라면 /WEB-INF/\nDirectory를 자동으로 추적하지 못하는 경우가 발생할 수 있다!!\n때문에 해당 프로젝트 실행 환경의 Working directory 내에\n$MODULE_WORKING_DIR$\n경로를 추가하여야 한다.\n참조\nhttps://stackoverflow.com/questions/33459740/error-no-url-for-servletcontext-resource-when-running-spring-integrated-test\n","permalink":"https://HyoseungJeon.github.io/posts/intellij/thymeleaf/","summary":"프로젝트를 옮기고 Spring 프로젝트를 세팅 하는 중 build error가 발생하였다!\n그 중 익숙하지 않은 build error가 있었는데\nThymeleaf 관련 Directory를 추적하지 못하여 file not found Error가 나왔다..!\n알고 보니 따로 Template Engine을 설정하여 Project를 생성한 경우가 아닐 시 자동으로 추적 경로가 등록되지 않는 경우 같더라..\n내용을 추가적으로 찾아보니 Maven의 경우 따로 실행 Configurations 내 Working Directory 잡아주어야 한다는 내용을 찾았다..!\nThymeleaf 프로젝트 build 시 Maven 관리 도구를 사용 중이고 따로 importing 한 프로젝트 라면 /WEB-INF/","title":"Thymeleaf"},{"content":" Future란? Java 1.5에 공개된 비동기 process 처리를 지원하는 interface Class 이다.\n비동기 방식을 지원하기 위해 당연하게도 mulitThread 방식을 활용하여 해당 기능을 지원하고 있다. 기존의 Thread 직접 선언 및 관리 방식과 다르게 interface를 활용하여 비동기를 구현할 수 있어 안정적인 비동기 구현 방법이다.\n해당 비동기 process를 호출 thread에서 사용 가능하다.\n단, 해당 값 조회를 시도할 시 blocking 상태로 변화하여 지연이 발생할 수 있다.\nMethods V get(), get(Long time, TimeUnit unit)\n실행 결과 값을 조회하는 method\n호출 시 해당 작업이 완료 될 때 까지 blocking 상태로 전환된다.\n매개변수 2개를 받을 시 해당 값 만큼 TimeOut 시간이 설정된다.\n작업이 지연될 경우, TimeoutException을 발생시킨다.\nboolean isDone()\n현재 작업의 완료 상태를 체크한다.\n어떠한 경우든 작업이 실행 중인 상태가 아니라면 true를 반환한다.\nboolean cancel(boolean mayInterruptIfRunning)\n현재 실행 중인 작업을 중단 시킨다.\nmayInterruptIfRunning 값이 true인 경우 해당 작업의 Thread 중단되어야 하는 경우 중단 시킨다. 그렇지 않은 경우에는 작업을 완료할 수 있다.\nFuture lib:\nif the thread executing this task should be interrupted\notherwise, in-progress tasks are allowed to complete\n정상 취소 성공 시 true return 한다.\nboolean isCancelled()\ncancel method를 통하여 정상 cancel 일 시 true를 return 한다.\n예제 소스 //ExecutorService 초기화 ExecutorService executor = Executors.newSingleThreadExecutor(); //Callable Task 생성 Callable\u0026lt;String\u0026gt; callableTask = () -\u0026gt; { System.out.println(LocalTime.now() + \u0026#34; Task Start\u0026#34;); Thread.sleep(1000L); return \u0026#34;Task Result\u0026#34;; }; //submit() 메서드로 Task 실행 Future\u0026lt;String\u0026gt; future = executor.submit(callableTask); System.out.println(LocalTime.now() + \u0026#34; Waiting the task done\u0026#34;); System.out.println(\u0026#34;isDone 1 = \u0026#34; + future.isDone()); String result = future.get(); //Task 결과 대기 System.out.println(\u0026#34;isDone 2 = \u0026#34; + future.isDone()); System.out.println(LocalTime.now() + \u0026#34; future.get() = \u0026#34; + result); //실행 결과 23:09:32.917 Waiting the task done isDone 1 = false 23:09:32.918 Task Start isDone 2 = true 23:09:33.922 future.get() = Task Result 내 경험 23년 3월 쯔음에 특정 프로세스를 excel file 단위로 처리하는 작업을 진행하였다. 업무 자체로는 문제가 없었는데 해당 프로세스는 완료 후 sms/email을 발송하는 logic이 있었다.\n때문에 bulk 단위 작업 시 해당 api 응답이 1분 가까이 소요되는 상태였다. 해당 부분이 issue로 올라왔다.\n실제 지연이 크게 발생한 이유는 DB Data 조작 시간 소요는 크지 않았는데 sms/email 발송 부분에서 30초 가량의 시간을 잡아먹고 있었다.\n내부 소스는 Future interface를 잉\n참조:\n","permalink":"https://HyoseungJeon.github.io/posts/java/future/","summary":"Future란? Java 1.5에 공개된 비동기 process 처리를 지원하는 interface Class 이다.\n비동기 방식을 지원하기 위해 당연하게도 mulitThread 방식을 활용하여 해당 기능을 지원하고 있다. 기존의 Thread 직접 선언 및 관리 방식과 다르게 interface를 활용하여 비동기를 구현할 수 있어 안정적인 비동기 구현 방법이다.\n해당 비동기 process를 호출 thread에서 사용 가능하다.\n단, 해당 값 조회를 시도할 시 blocking 상태로 변화하여 지연이 발생할 수 있다.\nMethods V get(), get(Long time, TimeUnit unit)\n실행 결과 값을 조회하는 method","title":"Future"},{"content":"","permalink":"https://HyoseungJeon.github.io/spring/","summary":"","title":"Spring"},{"content":"","permalink":"https://HyoseungJeon.github.io/ch/","summary":"","title":"첫 포스트"},{"content":" 설명 Spring 2.0 부터 추가된 기능으로 Request 인입 후 thread 생성 된 시점부터 전 구간에서 HttpServletRequest에 접근을 가능하게 해주는 기능이다.\n기존 Controller 단에 parameter 형식으로 선언 후 참고하던 방식과 다르게 위 객체를 통하여 request에 접근이 가능하다.\n예제 소스 :\n@GetMapping(\u0026#34;hello\u0026#34;) public void before(HttpServletRequest request) { sampleService.hello(request); } @GetMapping(\u0026#34;hello\u0026#34;) public void after() { HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest(); sampleService.hello(request); } 동작 원리 Request 인입 시 Spring 내 ThreadLocal 이라는 공간에 값을 저장하는 방식이다. 이름에서도 유추할 수 있듯이 단일 Thread내에 저장되는 방식으로 이외 Thread에서는 값 참조가 불가능하게 된다. 단, Inheritable = true 옵션값을 통하여 중첩 Thread 내에서 부모 Thread 값 참조가 가능하다. 자세한 내용은 ref site 참고\n장점 1차적인 장점으로는 request 객체를 참조하기 위해 매번 parameter에 선언한 필요가 없다는 것이다. 불필요한 코드 작성을 줄이고 가독성을 높여준다.\n전 구간에서 참조 가능하다. Controller에서 request 정보를 받아 다른 Service 내리거나 하는 작업이 생략된다.\n→ 위 점을 활용하여 request 정보를 활용하는 공통 Util class를 구현한다면 베스트 인 것 같다!!\n내 활용 방식 진행하던 프로젝트 내에서 Exception 발생 시 공통으로 인입 된 값을 logging 하는 방식에 활용했다. 기존 APM을 통하여 body 내 값이나 query 방식의 값들을 최적화된 log 값들과 함께 같이 세팅하여 기록하도록 구현하였다.\nrefs: RequestContextHolder (Spring Framework 6.0.11 API)\nRequestContextHolder\nSpring RequestContextHolder - 어디서든 HttpServletReqeust 사용하기\nSpring RequestContextHolder\n","permalink":"https://HyoseungJeon.github.io/posts/spring/requestcontextholder/","summary":"설명 Spring 2.0 부터 추가된 기능으로 Request 인입 후 thread 생성 된 시점부터 전 구간에서 HttpServletRequest에 접근을 가능하게 해주는 기능이다.\n기존 Controller 단에 parameter 형식으로 선언 후 참고하던 방식과 다르게 위 객체를 통하여 request에 접근이 가능하다.\n예제 소스 :\n@GetMapping(\u0026#34;hello\u0026#34;) public void before(HttpServletRequest request) { sampleService.hello(request); } @GetMapping(\u0026#34;hello\u0026#34;) public void after() { HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest(); sampleService.hello(request); } 동작 원리 Request 인입 시 Spring 내 ThreadLocal 이라는 공간에 값을 저장하는 방식이다.","title":"RequestContextHolder"}]