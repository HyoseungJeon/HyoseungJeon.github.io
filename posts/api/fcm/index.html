<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>FCM | HyoSeung IT blog</title><meta name=keywords content="Java,Spring,Firebase"><meta name=description content="FCM이란? 정의 Firebase Cloud Messaging(FCM)은 메시지를 안정적으로 무료 전송할 수 있는 크로스 플랫폼 메시징 솔루션입니다. 출처 - https://firebase.google.com/docs/cloud-messaging?hl=ko
기능 알림 메시지 또는 데이터 메시지 전송 사용자에게 표시되는 알림 메시지를 전송합니다. 또는 데이터 메시지를 전송하고 애플리케이션 코드에서 임의로 처리합니다. 자세한 내용은 https://firebase.google.com/docs/cloud-messaging/concept-options?hl=ko#notifications_and_data_messages을 참조하세요. 다양한 메시지 타겟팅 단일 기기, 기기 그룹, 주제를 구독한 기기 등 3가지 방식으로 클라이언트 앱에 메시지를 배포할 수 있습니다. 클라이언트 앱에서 메시지 전송 FCM의 신뢰성 높고 배터리 효율적인 연결 채널을 통해 기기에서 다시 서버로 확인, 채팅, 기타 메시지를 보낼 수 있습니다."><meta name=author content="HyoSeung Jeon"><link rel=canonical href=https://HyoseungJeon.github.io/posts/api/fcm/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://HyoseungJeon.github.io/profile.png><link rel=icon type=image/png sizes=16x16 href=https://HyoseungJeon.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://HyoseungJeon.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://HyoseungJeon.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://HyoseungJeon.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="FCM"><meta property="og:description" content="FCM이란? 정의 Firebase Cloud Messaging(FCM)은 메시지를 안정적으로 무료 전송할 수 있는 크로스 플랫폼 메시징 솔루션입니다. 출처 - https://firebase.google.com/docs/cloud-messaging?hl=ko
기능 알림 메시지 또는 데이터 메시지 전송 사용자에게 표시되는 알림 메시지를 전송합니다. 또는 데이터 메시지를 전송하고 애플리케이션 코드에서 임의로 처리합니다. 자세한 내용은 https://firebase.google.com/docs/cloud-messaging/concept-options?hl=ko#notifications_and_data_messages을 참조하세요. 다양한 메시지 타겟팅 단일 기기, 기기 그룹, 주제를 구독한 기기 등 3가지 방식으로 클라이언트 앱에 메시지를 배포할 수 있습니다. 클라이언트 앱에서 메시지 전송 FCM의 신뢰성 높고 배터리 효율적인 연결 채널을 통해 기기에서 다시 서버로 확인, 채팅, 기타 메시지를 보낼 수 있습니다."><meta property="og:type" content="article"><meta property="og:url" content="https://HyoseungJeon.github.io/posts/api/fcm/"><meta property="og:image" content="https://HyoseungJeon.github.io/profile.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-10T09:45:10+09:00"><meta property="article:modified_time" content="2023-08-10T09:45:10+09:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://HyoseungJeon.github.io/profile.png"><meta name=twitter:title content="FCM"><meta name=twitter:description content="FCM이란? 정의 Firebase Cloud Messaging(FCM)은 메시지를 안정적으로 무료 전송할 수 있는 크로스 플랫폼 메시징 솔루션입니다. 출처 - https://firebase.google.com/docs/cloud-messaging?hl=ko
기능 알림 메시지 또는 데이터 메시지 전송 사용자에게 표시되는 알림 메시지를 전송합니다. 또는 데이터 메시지를 전송하고 애플리케이션 코드에서 임의로 처리합니다. 자세한 내용은 https://firebase.google.com/docs/cloud-messaging/concept-options?hl=ko#notifications_and_data_messages을 참조하세요. 다양한 메시지 타겟팅 단일 기기, 기기 그룹, 주제를 구독한 기기 등 3가지 방식으로 클라이언트 앱에 메시지를 배포할 수 있습니다. 클라이언트 앱에서 메시지 전송 FCM의 신뢰성 높고 배터리 효율적인 연결 채널을 통해 기기에서 다시 서버로 확인, 채팅, 기타 메시지를 보낼 수 있습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://HyoseungJeon.github.io/posts/"},{"@type":"ListItem","position":2,"name":"API","item":"https://HyoseungJeon.github.io/posts/api/"},{"@type":"ListItem","position":3,"name":"FCM","item":"https://HyoseungJeon.github.io/posts/api/fcm/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"FCM","name":"FCM","description":"FCM이란? 정의 Firebase Cloud Messaging(FCM)은 메시지를 안정적으로 무료 전송할 수 있는 크로스 플랫폼 메시징 솔루션입니다. 출처 - https://firebase.google.com/docs/cloud-messaging?hl=ko\n기능 알림 메시지 또는 데이터 메시지 전송 사용자에게 표시되는 알림 메시지를 전송합니다. 또는 데이터 메시지를 전송하고 애플리케이션 코드에서 임의로 처리합니다. 자세한 내용은 https://firebase.google.com/docs/cloud-messaging/concept-options?hl=ko#notifications_and_data_messages을 참조하세요. 다양한 메시지 타겟팅 단일 기기, 기기 그룹, 주제를 구독한 기기 등 3가지 방식으로 클라이언트 앱에 메시지를 배포할 수 있습니다. 클라이언트 앱에서 메시지 전송 FCM의 신뢰성 높고 배터리 효율적인 연결 채널을 통해 기기에서 다시 서버로 확인, 채팅, 기타 메시지를 보낼 수 있습니다.","keywords":["Java","Spring","Firebase"],"articleBody":" FCM이란? 정의 Firebase Cloud Messaging(FCM)은 메시지를 안정적으로 무료 전송할 수 있는 크로스 플랫폼 메시징 솔루션입니다. 출처 - https://firebase.google.com/docs/cloud-messaging?hl=ko\n기능 알림 메시지 또는 데이터 메시지 전송 사용자에게 표시되는 알림 메시지를 전송합니다. 또는 데이터 메시지를 전송하고 애플리케이션 코드에서 임의로 처리합니다. 자세한 내용은 https://firebase.google.com/docs/cloud-messaging/concept-options?hl=ko#notifications_and_data_messages을 참조하세요. 다양한 메시지 타겟팅 단일 기기, 기기 그룹, 주제를 구독한 기기 등 3가지 방식으로 클라이언트 앱에 메시지를 배포할 수 있습니다. 클라이언트 앱에서 메시지 전송 FCM의 신뢰성 높고 배터리 효율적인 연결 채널을 통해 기기에서 다시 서버로 확인, 채팅, 기타 메시지를 보낼 수 있습니다. 기본 원리 FCM 구현에는 송수신을 위한 두 가지 주요 구성요소가 포함됩니다.\nFirebase용 Cloud Functions 또는 앱 서버와 같이 메시지를 작성, 타겟팅, 전송할 수 있는 신뢰할 수 있는 환경 해당 플랫폼별 전송 서비스를 통해 메시지를 수신하는 Apple, Android 또는 웹(자바스크립트) 클라이언트 앱 Firebase Admin SDK 또는 FCM 서버 프로토콜을 통해 메시지를 보낼 수 있습니다. 알림 작성기를 사용하면 기본 제공되는 강력한 타겟팅 및 분석 기능이나 커스텀 가져온 세그먼트를 사용하여 마케팅 또는 참여 메시지를 테스트하고 전송할 수 있습니다.\nFCM의 구성요소에 대한 자세한 내용과 중요한 정보는 아키텍처 개요를 참조하세요.\n즉, 무료로 Server 단에서 FCM Server를 통해여 정해진 규약에 따라 사용자 클라이언트에게 메세지를 보내는 서비스이다!\n사용법 FirebaseApp firebaseApp; ClassPathResource filePath = new ClassPathResource(pushFirebaseProperties.getFileName()); FirebaseOptions options = FirebaseOptions.builder() .setCredentials(GoogleCredentials.fromStream(filePath.getInputStream())) .build(); firebaseApp = FirebaseApp.initializeApp(options); FirebaseMessaging FirebaseMessagingInstance = FirebaseMessaging.getInstance(firebaseApp); // 메시지 설정 Notification notification = Notification.builder() .build(); MulticastMessage message = MulticastMessage .builder() .setNotification(notification) .build(); // 메시지 전송 BatchResponse response = FirebaseMessagingInstance.sendMulticast(message); 사용법은 간단하다. 발급 받은 Firebase 인증 정보 File을 읽고 App 객체를 생성, FirebaseMessaging\nInstance를 생성하여 메시지를 설정 후에 send 하면 끝이다!\n단, 내부 source를 공개하기는 어렵지만 구조는 이러하다.\nSpring Daemon Server로 구성 알림 등록 시, 알림 대기 목록 table insert Daemon server는 5초 간격으로 table read 조회 된 row 있을 시 병렬 처리 Thread에 작업 할당 알림 발송 병렬 처리 (FCM 발송) 성공/실패 Log table insert 처음 인수인계를 받고 Daemon server로 구현된 방식이 신기했다! Spring batch가 아닌 오랜만에 보는 Daemon server.. 좀 두려웠다;;\n알림은 크게 단 건, 다 건 두 종류로 처리하고 있었다! 그래서 당연히 단 건은 Controller API로 받아서 즉시 처리할 줄 알았는데 두 종류 모두 Daemon Server가 각 case의 Table을 읽고 처리하고 있었다..! (무슨 의미일까..?) 어차피 5초마다 돌기 때문에 거의 실시간이라고 봐도 무방하지만.. 굳이 Thread를 하나 더 생성하여 할당 시키는 이유는 아직 납득하지 못했다.. 😒😒\nSpring Daemon Server Run 방식 자체도 조금 신기했는데, Scheduling File을 통해.. 단순히 Thread 2개를 run 시키고 해당 Thread Daemon이 계속 도는? 방식 이였다!! 처음에 위 File이 있어서 Batch로 구현 되어있나..? 라는 생각을 하였는데 Job도 없고.. 하여 엄청 헷갈렸는데 Daemon이란 걸 이해하고 바로 납득이 갔다!\n하여 Size가 10개 씩 잡힌 Thread 돌며 작업을 처리하고, 알림을 보낸다!! Runnable Class 를 상속 받은 Sender, Worker, Manager Context 들이 작업을 할당 받아 처리하고 있다.\n내 생각 생각보다 FCM이 제공하는 Service가 좋아서 쉽게 사용자에게 알림을 보낼 수가 있었다! 하지만 역시 그 환경을 구성하는 일이 더 중요하다고 봤다..\nPush 알림의 종류는 단 건, 다 건 두 종류였다! 내 생각에는 단 건은 문자 Service 와 같이 MQ를 이용하여 구성을 하고, 다 건은 Batch로 예약된 시간에 Server가 할당된 Thread를 통해서 처리를 하면 깔끔할 것이라고 생각했다! 하지만 둘 다 Daemon 방식으로 처리 되고 있는 것이 조금 놀라웠다..; 아니 사실 좀 이상하다고 생각했다! 하지만 기존의 Project 소스를 Reference로 삼아 작업을 한 것이라 어쩔 수 없었다는 말을 듣고 어느 정도 납득을 하긴 했다.. 하지만 이러한 상황들 때문에 오래된 것이든 경험을 해보고 또 배우고! 또 새로운 것의 장점을 제대로 느낄 수 있는 거 아닐까?\n언제나 그렇듯 제공되는 API는 기능일 뿐 결국 구성하는 방식이 중요했다! 특히 Spring 인데도 불구하고 FCM Instant 주입 방식이 static Syn~~ 방식으로 되어 있었다..! 그리고 Manager Context에 해당 FCM을 할당, 다른 Context에게 계속 param으로 넘기면서 사용하고 있었다;; 매번 param에 선언, static으로 선언한 이유도.. 이해가 가지 않았다. 해서 Config 단으로 FCM 초기화 Source을 이관하고, 해당 FCM 객체를 @Bean으로 선언하여 Single Tone으로 어디서나 주입 받아 사용할 수 있도록 수정 하였다! 기존 Service는 이미 제공되고 있어서 건드릴 수 없었지만 적어도 주입 방법이라도 바꾸고 싶었다.. 😂 (너무 신경 쓰여서 도저히 둘 수가 없었다..)\nCtrl C + V 는 좋다.. 하지만 아무런 사고 없이, 생각 없이 붙이는 작업은 최악이라고 생각한다..! 이런 기회를 통해서 마음을 한번 다시 다잡게 되었다!\n출처:\nhttps://firebase.google.com/docs/cloud-messaging?hl=ko\n","wordCount":"659","inLanguage":"en","datePublished":"2023-08-10T09:45:10+09:00","dateModified":"2023-08-10T09:45:10+09:00","author":{"@type":"Person","name":"HyoSeung Jeon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://HyoseungJeon.github.io/posts/api/fcm/"},"publisher":{"@type":"Organization","name":"HyoSeung IT blog","logo":{"@type":"ImageObject","url":"https://HyoseungJeon.github.io/profile.png"}}}</script><link rel=stylesheet href=https://HyoseungJeon.github.io/scss/main.css></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://HyoseungJeon.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://HyoseungJeon.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://HyoseungJeon.github.io/posts/ title=posts><span style=font-family:SUITE-Regular;font-size:19px>posts</span></a></li><li><a href=https://HyoseungJeon.github.io/tags/ title=tags><span style=font-family:SUITE-Regular;font-size:19px>tags</span></a></li><li><a href=https://HyoseungJeon.github.io/archives/ title=archives><span style=font-family:SUITE-Regular;font-size:19px>archives</span></a></li><li><a href=https://HyoseungJeon.github.io/search/ title="search (Alt + /)" accesskey=/><span style=font-family:SUITE-Regular;font-size:19px><i class='fa-brands fa-github'></i>search</span></a></li></ul></nav></header><main class="main page"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://HyoseungJeon.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://HyoseungJeon.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://HyoseungJeon.github.io/posts/api/>API</a></div><h1 class=post-title>FCM</h1><div class=post-meta><span title='2023-08-10 09:45:10 +0900 +0900'>August 10, 2023</span>&nbsp;·&nbsp;659 words&nbsp;·&nbsp;HyoSeung Jeon</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner style=padding-top:10px><ul><li><a href=#fcm%ec%9d%b4%eb%9e%80 aria-label=FCM이란?>FCM이란?</a><ul><li><a href=#%ec%a0%95%ec%9d%98 aria-label=정의>정의</a></li><li><a href=#%ea%b8%b0%eb%8a%a5 aria-label=기능>기능</a></li><li><a href=#%ea%b8%b0%eb%b3%b8-%ec%9b%90%eb%a6%ac aria-label="기본 원리">기본 원리</a></li></ul></li><li><a href=#%ec%82%ac%ec%9a%a9%eb%b2%95 aria-label=사용법>사용법</a></li><li><a href=#%eb%82%b4-%ec%83%9d%ea%b0%81 aria-label="내 생각">내 생각</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><hr><h2 id=fcm이란>FCM이란?<a hidden class=anchor aria-hidden=true href=#fcm이란>#</a></h2><h3 id=정의>정의<a hidden class=anchor aria-hidden=true href=#정의>#</a></h3><blockquote><p>Firebase Cloud Messaging(FCM)은 메시지를 안정적으로 무료 전송할 수 있는 크로스 플랫폼 메시징 솔루션입니다.
출처 - <a href="https://firebase.google.com/docs/cloud-messaging?hl=ko">https://firebase.google.com/docs/cloud-messaging?hl=ko</a></p></blockquote><h3 id=기능>기능<a hidden class=anchor aria-hidden=true href=#기능>#</a></h3><table><thead><tr><th>알림 메시지 또는 데이터 메시지 전송</th><th>사용자에게 표시되는 알림 메시지를 전송합니다. 또는 데이터 메시지를 전송하고 애플리케이션 코드에서 임의로 처리합니다. 자세한 내용은 https://firebase.google.com/docs/cloud-messaging/concept-options?hl=ko#notifications_and_data_messages을 참조하세요.</th></tr></thead><tbody><tr><td>다양한 메시지 타겟팅</td><td>단일 기기, 기기 그룹, 주제를 구독한 기기 등 3가지 방식으로 클라이언트 앱에 메시지를 배포할 수 있습니다.</td></tr><tr><td>클라이언트 앱에서 메시지 전송</td><td>FCM의 신뢰성 높고 배터리 효율적인 연결 채널을 통해 기기에서 다시 서버로 확인, 채팅, 기타 메시지를 보낼 수 있습니다.</td></tr></tbody></table><h3 id=기본-원리>기본 원리<a hidden class=anchor aria-hidden=true href=#기본-원리>#</a></h3><p>FCM 구현에는 송수신을 위한 두 가지 주요 구성요소가 포함됩니다.</p><ol><li>Firebase용 Cloud Functions 또는 앱 서버와 같이 메시지를 작성, 타겟팅, 전송할 수 있는 신뢰할 수 있는 환경</li><li>해당 플랫폼별 전송 서비스를 통해 메시지를 수신하는 Apple, Android 또는 웹(자바스크립트) 클라이언트 앱</li></ol><p><a href="https://firebase.google.com/docs/cloud-messaging/server?hl=ko#firebase-admin-sdk-for-fcm">Firebase Admin SDK</a> 또는 <a href="https://firebase.google.com/docs/cloud-messaging/server?hl=ko#choose">FCM 서버 프로토콜</a>을 통해 메시지를 보낼 수 있습니다. <a href="https://console.firebase.google.com/project/_/notification?hl=ko">알림 작성기</a>를 사용하면 기본 제공되는 강력한 타겟팅 및 분석 기능이나 커스텀 <a href="https://firebase.google.com/docs/projects/import-segments?hl=ko">가져온 세그먼트</a>를 사용하여 마케팅 또는 참여 메시지를 테스트하고 전송할 수 있습니다.</p><p>FCM의 구성요소에 대한 자세한 내용과 중요한 정보는 <a href="https://firebase.google.com/docs/cloud-messaging/fcm-architecture?hl=ko">아키텍처 개요</a>를 참조하세요.</p><p>즉, <strong>무료로</strong> Server 단에서 FCM Server를 통해여 정해진 규약에 따라 사용자 <strong>클라이언트에게 메세지</strong>를 보내는 서비스이다!</p><h2 id=사용법>사용법<a hidden class=anchor aria-hidden=true href=#사용법>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>FirebaseApp</span> <span class=n>firebaseApp</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=n>ClassPathResource</span> <span class=n>filePath</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ClassPathResource</span><span class=o>(</span><span class=n>pushFirebaseProperties</span><span class=o>.</span><span class=na>getFileName</span><span class=o>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>FirebaseOptions</span> <span class=n>options</span> <span class=o>=</span> <span class=n>FirebaseOptions</span><span class=o>.</span><span class=na>builder</span><span class=o>()</span>
</span></span><span class=line><span class=cl>	<span class=o>.</span><span class=na>setCredentials</span><span class=o>(</span><span class=n>GoogleCredentials</span><span class=o>.</span><span class=na>fromStream</span><span class=o>(</span><span class=n>filePath</span><span class=o>.</span><span class=na>getInputStream</span><span class=o>()))</span>
</span></span><span class=line><span class=cl>	<span class=o>.</span><span class=na>build</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>firebaseApp</span> <span class=o>=</span> <span class=n>FirebaseApp</span><span class=o>.</span><span class=na>initializeApp</span><span class=o>(</span><span class=n>options</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>FirebaseMessaging</span> <span class=n>FirebaseMessagingInstance</span> <span class=o>=</span> <span class=n>FirebaseMessaging</span><span class=o>.</span><span class=na>getInstance</span><span class=o>(</span><span class=n>firebaseApp</span><span class=o>);</span>
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl><span class=c1>// 메시지 설정
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Notification</span> <span class=n>notification</span> <span class=o>=</span> <span class=n>Notification</span><span class=o>.</span><span class=na>builder</span><span class=o>()</span>
</span></span><span class=line><span class=cl>				<span class=o>.</span><span class=na>build</span><span class=o>();</span>
</span></span><span class=line><span class=cl>				
</span></span><span class=line><span class=cl><span class=n>MulticastMessage</span>  <span class=n>message</span> <span class=o>=</span> <span class=n>MulticastMessage</span> <span class=o>.</span><span class=na>builder</span><span class=o>()</span>
</span></span><span class=line><span class=cl>				<span class=o>.</span><span class=na>setNotification</span><span class=o>(</span><span class=n>notification</span><span class=o>)</span>
</span></span><span class=line><span class=cl>			  <span class=o>.</span><span class=na>build</span><span class=o>();</span>
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl><span class=c1>// 메시지 전송
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>BatchResponse</span> <span class=n>response</span> <span class=o>=</span> <span class=n>FirebaseMessagingInstance</span><span class=o>.</span><span class=na>sendMulticast</span><span class=o>(</span><span class=n>message</span><span class=o>);</span>
</span></span></code></pre></div><p>사용법은 간단하다. 발급 받은 Firebase 인증 정보 File을 읽고 App 객체를 생성, <code>FirebaseMessaging</code></p><p>Instance를 생성하여 메시지를 설정 후에 send 하면 끝이다!</p><p>단, 내부 source를 공개하기는 어렵지만 구조는 이러하다.</p><ol><li>Spring Daemon Server로 구성</li><li>알림 등록 시, 알림 대기 목록 table insert</li><li>Daemon server는 5초 간격으로 table read</li><li>조회 된 row 있을 시 병렬 처리 Thread에 작업 할당</li><li>알림 발송 병렬 처리 (FCM 발송)</li><li>성공/실패 Log table insert</li></ol><p>처음 인수인계를 받고 Daemon server로 구현된 방식이 신기했다! Spring batch가 아닌 오랜만에 보는 Daemon server.. 좀 두려웠다;;</p><p>알림은 크게 단 건, 다 건 두 종류로 처리하고 있었다! 그래서 당연히 단 건은 Controller API로 받아서 즉시 처리할 줄 알았는데 두 종류 모두 Daemon Server가 각 case의 Table을 읽고 처리하고 있었다..! (무슨 의미일까..?) 어차피 5초마다 돌기 때문에 거의 실시간이라고 봐도 무방하지만.. 굳이 Thread를 하나 더 생성하여 할당 시키는 이유는 아직 납득하지 못했다.. 😒😒</p><p>Spring Daemon Server Run 방식 자체도 조금 신기했는데, Scheduling File을 통해.. 단순히 Thread 2개를 run 시키고 해당 Thread Daemon이 계속 도는? 방식 이였다!! 처음에 위 File이 있어서 Batch로 구현 되어있나..? 라는 생각을 하였는데 Job도 없고.. 하여 엄청 헷갈렸는데 Daemon이란 걸 이해하고 바로 납득이 갔다!</p><p>하여 Size가 10개 씩 잡힌 Thread 돌며 작업을 처리하고, 알림을 보낸다!! <code>Runnable Class</code> 를 상속 받은 <strong>Sender, Worker, Manage</strong>r Context 들이 작업을 할당 받아 처리하고 있다.</p><h2 id=내-생각>내 생각<a hidden class=anchor aria-hidden=true href=#내-생각>#</a></h2><p>생각보다 FCM이 제공하는 Service가 좋아서 쉽게 사용자에게 알림을 보낼 수가 있었다! 하지만 역시 그 환경을 구성하는 일이 더 중요하다고 봤다..</p><p>Push 알림의 종류는 단 건, 다 건 두 종류였다! 내 생각에는 단 건은 문자 Service 와 같이 MQ를 이용하여 구성을 하고, 다 건은 Batch로 예약된 시간에 Server가 할당된 Thread를 통해서 처리를 하면 깔끔할 것이라고 생각했다! 하지만 둘 다 Daemon 방식으로 처리 되고 있는 것이 조금 놀라웠다..; 아니 사실 좀 이상하다고 생각했다! 하지만 기존의 Project 소스를 Reference로 삼아 작업을 한 것이라 어쩔 수 없었다는 말을 듣고 어느 정도 납득을 하긴 했다.. 하지만 이러한 상황들 때문에 오래된 것이든 경험을 해보고 또 배우고! 또 새로운 것의 장점을 제대로 느낄 수 있는 거 아닐까?</p><p>언제나 그렇듯 제공되는 API는 기능일 뿐 결국 구성하는 방식이 중요했다! 특히 Spring 인데도 불구하고 FCM Instant 주입 방식이 static Syn~~ 방식으로 되어 있었다..! 그리고 Manager Context에 해당 FCM을 할당, 다른 Context에게 계속 param으로 넘기면서 사용하고 있었다;; 매번 param에 선언, static으로 선언한 이유도.. 이해가 가지 않았다. 해서 Config 단으로 FCM 초기화 Source을 이관하고, 해당 FCM 객체를 @Bean으로 선언하여 Single Tone으로 어디서나 주입 받아 사용할 수 있도록 수정 하였다! 기존 Service는 이미 제공되고 있어서 건드릴 수 없었지만 적어도 주입 방법이라도 바꾸고 싶었다.. 😂 (너무 신경 쓰여서 도저히 둘 수가 없었다..)</p><p>Ctrl C + V 는 좋다.. 하지만 아무런 사고 없이, 생각 없이 붙이는 작업은 최악이라고 생각한다..! 이런 기회를 통해서 마음을 한번 다시 다잡게 되었다!</p><p>출처:</p><p><a href="https://firebase.google.com/docs/cloud-messaging?hl=ko">https://firebase.google.com/docs/cloud-messaging?hl=ko</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://HyoseungJeon.github.io/tags/java/>Java</a></li><li><a href=https://HyoseungJeon.github.io/tags/spring/>Spring</a></li><li><a href=https://HyoseungJeon.github.io/tags/firebase/>Firebase</a></li></ul><nav class=paginav><a class=prev href=https://HyoseungJeon.github.io/posts/jquery/validate/><span class=title>« Prev</span><br><span>Validate</span></a>
<a class=next href=https://HyoseungJeon.github.io/posts/java/file/><span class=title>Next »</span><br><span>File</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://HyoseungJeon.github.io/>HyoSeung IT blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>