<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Future | HyoSeung IT blog</title><meta name=keywords content="Java,Asynchronous"><meta name=description content="Future란? Java 1.5에 공개된 비동기 process 처리를 지원하는 interface Class 이다.
비동기 방식을 지원하기 위해 당연하게도 mulitThread 방식을 활용하여 해당 기능을 지원하고 있다. 기존의 Thread 직접 선언 및 관리 방식과 다르게 interface를 활용하여 비동기를 구현할 수 있어 안정적인 비동기 구현 방법이다.
해당 비동기 process를 호출 thread에서 사용 가능하다.
단, 해당 값 조회를 시도할 시 blocking 상태로 변화하여 지연이 발생할 수 있다.
Methods V get(), get(Long time, TimeUnit unit)
실행 결과 값을 조회하는 method"><meta name=author content="HyoSeung Jeon"><link rel=canonical href=https://HyoseungJeon.github.io/posts/java/future/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://HyoseungJeon.github.io/profile.png><link rel=icon type=image/png sizes=16x16 href=https://HyoseungJeon.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://HyoseungJeon.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://HyoseungJeon.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://HyoseungJeon.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Future"><meta property="og:description" content="Future란? Java 1.5에 공개된 비동기 process 처리를 지원하는 interface Class 이다.
비동기 방식을 지원하기 위해 당연하게도 mulitThread 방식을 활용하여 해당 기능을 지원하고 있다. 기존의 Thread 직접 선언 및 관리 방식과 다르게 interface를 활용하여 비동기를 구현할 수 있어 안정적인 비동기 구현 방법이다.
해당 비동기 process를 호출 thread에서 사용 가능하다.
단, 해당 값 조회를 시도할 시 blocking 상태로 변화하여 지연이 발생할 수 있다.
Methods V get(), get(Long time, TimeUnit unit)
실행 결과 값을 조회하는 method"><meta property="og:type" content="article"><meta property="og:url" content="https://HyoseungJeon.github.io/posts/java/future/"><meta property="og:image" content="https://HyoseungJeon.github.io/profile.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-17T13:03:35+09:00"><meta property="article:modified_time" content="2023-07-17T13:03:35+09:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://HyoseungJeon.github.io/profile.png"><meta name=twitter:title content="Future"><meta name=twitter:description content="Future란? Java 1.5에 공개된 비동기 process 처리를 지원하는 interface Class 이다.
비동기 방식을 지원하기 위해 당연하게도 mulitThread 방식을 활용하여 해당 기능을 지원하고 있다. 기존의 Thread 직접 선언 및 관리 방식과 다르게 interface를 활용하여 비동기를 구현할 수 있어 안정적인 비동기 구현 방법이다.
해당 비동기 process를 호출 thread에서 사용 가능하다.
단, 해당 값 조회를 시도할 시 blocking 상태로 변화하여 지연이 발생할 수 있다.
Methods V get(), get(Long time, TimeUnit unit)
실행 결과 값을 조회하는 method"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://HyoseungJeon.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Java","item":"https://HyoseungJeon.github.io/posts/java/"},{"@type":"ListItem","position":3,"name":"Future","item":"https://HyoseungJeon.github.io/posts/java/future/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Future","name":"Future","description":"Future란? Java 1.5에 공개된 비동기 process 처리를 지원하는 interface Class 이다.\n비동기 방식을 지원하기 위해 당연하게도 mulitThread 방식을 활용하여 해당 기능을 지원하고 있다. 기존의 Thread 직접 선언 및 관리 방식과 다르게 interface를 활용하여 비동기를 구현할 수 있어 안정적인 비동기 구현 방법이다.\n해당 비동기 process를 호출 thread에서 사용 가능하다.\n단, 해당 값 조회를 시도할 시 blocking 상태로 변화하여 지연이 발생할 수 있다.\nMethods V get(), get(Long time, TimeUnit unit)\n실행 결과 값을 조회하는 method","keywords":["Java","Asynchronous"],"articleBody":" Future란? Java 1.5에 공개된 비동기 process 처리를 지원하는 interface Class 이다.\n비동기 방식을 지원하기 위해 당연하게도 mulitThread 방식을 활용하여 해당 기능을 지원하고 있다. 기존의 Thread 직접 선언 및 관리 방식과 다르게 interface를 활용하여 비동기를 구현할 수 있어 안정적인 비동기 구현 방법이다.\n해당 비동기 process를 호출 thread에서 사용 가능하다.\n단, 해당 값 조회를 시도할 시 blocking 상태로 변화하여 지연이 발생할 수 있다.\nMethods V get(), get(Long time, TimeUnit unit)\n실행 결과 값을 조회하는 method\n호출 시 해당 작업이 완료 될 때 까지 blocking 상태로 전환된다.\n매개변수 2개를 받을 시 해당 값 만큼 TimeOut 시간이 설정된다.\n작업이 지연될 경우, TimeoutException을 발생시킨다.\nboolean isDone()\n현재 작업의 완료 상태를 체크한다.\n어떠한 경우든 작업이 실행 중인 상태가 아니라면 true를 반환한다.\nboolean cancel(boolean mayInterruptIfRunning)\n현재 실행 중인 작업을 중단 시킨다.\nmayInterruptIfRunning 값이 true인 경우 해당 작업의 Thread 중단되어야 하는 경우 중단 시킨다. 그렇지 않은 경우에는 작업을 완료할 수 있다.\nFuture lib:\nif the thread executing this task should be interrupted\notherwise, in-progress tasks are allowed to complete\n정상 취소 성공 시 true return 한다.\nboolean isCancelled()\ncancel method를 통하여 정상 cancel 일 시 true를 return 한다.\n예제 소스 //ExecutorService 초기화 ExecutorService executor = Executors.newSingleThreadExecutor(); //Callable Task 생성 Callable\u003cString\u003e callableTask = () -\u003e { System.out.println(LocalTime.now() + \" Task Start\"); Thread.sleep(1000L); return \"Task Result\"; }; //submit() 메서드로 Task 실행 Future\u003cString\u003e future = executor.submit(callableTask); System.out.println(LocalTime.now() + \" Waiting the task done\"); System.out.println(\"isDone 1 = \" + future.isDone()); String result = future.get(); //Task 결과 대기 System.out.println(\"isDone 2 = \" + future.isDone()); System.out.println(LocalTime.now() + \" future.get() = \" + result); //실행 결과 23:09:32.917 Waiting the task done isDone 1 = false 23:09:32.918 Task Start isDone 2 = true 23:09:33.922 future.get() = Task Result 내 경험 23년 3월 쯔음에 특정 프로세스를 excel file 단위로 처리하는 작업을 진행하였다. 업무 자체로는 문제가 없었는데 해당 프로세스는 완료 후 sms/email을 발송하는 logic이 있었다.\n때문에 bulk 단위 작업 시 해당 api 응답이 1분 가까이 소요되는 상태였다. 해당 부분이 issue로 올라왔다.\n실제 지연이 크게 발생한 이유는 DB Data 조작 시간 소요는 크지 않았는데 sms/email 발송 부분에서 30초 가량의 시간을 잡아먹고 있었다.\n내부 소스는 Future interface를 잉\n참조:\n","wordCount":"339","inLanguage":"en","datePublished":"2023-07-17T13:03:35+09:00","dateModified":"2023-07-17T13:03:35+09:00","author":{"@type":"Person","name":"HyoSeung Jeon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://HyoseungJeon.github.io/posts/java/future/"},"publisher":{"@type":"Organization","name":"HyoSeung IT blog","logo":{"@type":"ImageObject","url":"https://HyoseungJeon.github.io/profile.png"}}}</script><link rel=stylesheet href=https://HyoseungJeon.github.io/scss/main.css></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://HyoseungJeon.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://HyoseungJeon.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://HyoseungJeon.github.io/posts/ title=posts class=btn-12><span style=font-family:SUITE-Regular;font-size:19px>posts</span></a></li><li><a href=https://HyoseungJeon.github.io/tags/ title=tags class=btn-12><span style=font-family:SUITE-Regular;font-size:19px>tags</span></a></li><li><a href=https://HyoseungJeon.github.io/archives/ title=archives class=btn-12><span style=font-family:SUITE-Regular;font-size:19px>archives</span></a></li><li><a href=https://HyoseungJeon.github.io/search/ title="search (Alt + /)" class=btn-12 accesskey=/><span style=font-family:SUITE-Regular;font-size:19px>search</span></a></li></ul></nav></header><main class="main page"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://HyoseungJeon.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://HyoseungJeon.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://HyoseungJeon.github.io/posts/java/>Java</a></div><h1 class=post-title>Future</h1><div class=post-meta><span title='2023-07-17 13:03:35 +0900 +0900'>July 17, 2023</span>&nbsp;·&nbsp;339 words&nbsp;·&nbsp;HyoSeung Jeon</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner style=padding-top:10px><ul><li><a href=#future%eb%9e%80 aria-label=Future란?>Future란?</a></li><li><a href=#methods aria-label=Methods>Methods</a></li><li><a href=#%ec%98%88%ec%a0%9c-%ec%86%8c%ec%8a%a4 aria-label="예제 소스">예제 소스</a></li><li><a href=#%eb%82%b4-%ea%b2%bd%ed%97%98 aria-label="내 경험">내 경험</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><hr><h3 id=future란>Future란?<a hidden class=anchor aria-hidden=true href=#future란>#</a></h3><p>Java 1.5에 공개된 비동기 process 처리를 지원하는 interface Class 이다.</p><p>비동기 방식을 지원하기 위해 당연하게도 mulitThread 방식을 활용하여 해당 기능을 지원하고 있다. 기존의 Thread 직접 선언 및 관리 방식과 다르게 interface를 활용하여 비동기를 구현할 수 있어 안정적인 비동기 구현 방법이다.</p><p>해당 비동기 process를 호출 thread에서 사용 가능하다.</p><p>단, 해당 값 조회를 시도할 시 blocking 상태로 변화하여 지연이 발생할 수 있다.</p><h3 id=methods>Methods<a hidden class=anchor aria-hidden=true href=#methods>#</a></h3><ul><li><p>V get(), get(Long time, TimeUnit unit)</p><p>실행 결과 값을 조회하는 method</p><p>호출 시 해당 작업이 완료 될 때 까지 blocking 상태로 전환된다.</p><p>매개변수 2개를 받을 시 해당 값 만큼 TimeOut 시간이 설정된다.</p><p>작업이 지연될 경우, TimeoutException을 발생시킨다.</p></li><li><p>boolean isDone()</p><p>현재 작업의 완료 상태를 체크한다.</p><p>어떠한 경우든 작업이 실행 중인 상태가 아니라면 true를 반환한다.</p></li><li><p>boolean cancel(boolean mayInterruptIfRunning)</p><p>현재 실행 중인 작업을 중단 시킨다.</p><p>mayInterruptIfRunning 값이 true인 경우 해당 작업의 Thread 중단되어야 하는 경우 중단 시킨다. 그렇지 않은 경우에는 작업을 완료할 수 있다.</p><blockquote><p>Future lib:</p><p>if the thread executing this task should be interrupted</p><p>otherwise, in-progress tasks are allowed to complete</p></blockquote><p>정상 취소 성공 시 true return 한다.</p></li><li><p>boolean isCancelled()</p><p>cancel method를 통하여 정상 cancel 일 시 true를 return 한다.</p></li></ul><h3 id=예제-소스>예제 소스<a hidden class=anchor aria-hidden=true href=#예제-소스>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=c1>//ExecutorService 초기화
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ExecutorService</span> <span class=n>executor</span> <span class=o>=</span> <span class=n>Executors</span><span class=o>.</span><span class=na>newSingleThreadExecutor</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>//Callable Task 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Callable</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>callableTask</span> <span class=o>=</span> <span class=o>()</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>LocalTime</span><span class=o>.</span><span class=na>now</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; Task Start&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>Thread</span><span class=o>.</span><span class=na>sleep</span><span class=o>(</span><span class=mi>1000L</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=s>&#34;Task Result&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>//submit() 메서드로 Task 실행
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Future</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=n>future</span> <span class=o>=</span> <span class=n>executor</span><span class=o>.</span><span class=na>submit</span><span class=o>(</span><span class=n>callableTask</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>LocalTime</span><span class=o>.</span><span class=na>now</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; Waiting the task done&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;isDone 1 = &#34;</span> <span class=o>+</span> <span class=n>future</span><span class=o>.</span><span class=na>isDone</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>String</span> <span class=n>result</span> <span class=o>=</span> <span class=n>future</span><span class=o>.</span><span class=na>get</span><span class=o>();</span>  <span class=c1>//Task 결과 대기
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;isDone 2 = &#34;</span> <span class=o>+</span> <span class=n>future</span><span class=o>.</span><span class=na>isDone</span><span class=o>());</span>
</span></span><span class=line><span class=cl>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>LocalTime</span><span class=o>.</span><span class=na>now</span><span class=o>()</span> <span class=o>+</span> <span class=s>&#34; future.get() = &#34;</span> <span class=o>+</span> <span class=n>result</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//실행 결과
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>23</span><span class=o>:</span><span class=mi>09</span><span class=o>:</span><span class=mf>32.917</span> <span class=n>Waiting</span> <span class=n>the</span> <span class=n>task</span> <span class=n>done</span>
</span></span><span class=line><span class=cl><span class=n>isDone</span> <span class=mi>1</span> <span class=o>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl><span class=mi>23</span><span class=o>:</span><span class=mi>09</span><span class=o>:</span><span class=mf>32.918</span> <span class=n>Task</span> <span class=n>Start</span>
</span></span><span class=line><span class=cl><span class=n>isDone</span> <span class=mi>2</span> <span class=o>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl><span class=mi>23</span><span class=o>:</span><span class=mi>09</span><span class=o>:</span><span class=mf>33.922</span> <span class=n>future</span><span class=o>.</span><span class=na>get</span><span class=o>()</span> <span class=o>=</span> <span class=n>Task</span> <span class=n>Result</span>
</span></span></code></pre></div><h3 id=내-경험>내 경험<a hidden class=anchor aria-hidden=true href=#내-경험>#</a></h3><p>23년 3월 쯔음에 특정 프로세스를 excel file 단위로 처리하는 작업을 진행하였다. 업무 자체로는 문제가 없었는데 해당 프로세스는 완료 후 sms/email을 발송하는 logic이 있었다.</p><p>때문에 bulk 단위 작업 시 해당 api 응답이 1분 가까이 소요되는 상태였다. 해당 부분이 issue로 올라왔다.</p><p>실제 지연이 크게 발생한 이유는 DB Data 조작 시간 소요는 크지 않았는데 sms/email 발송 부분에서 30초 가량의 시간을 잡아먹고 있었다.</p><p>내부 소스는 Future interface를 잉</p><p>참조:</p><p><a href=https://wildeveloperetrain.tistory.com/141></a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://HyoseungJeon.github.io/tags/java/>Java</a></li><li><a href=https://HyoseungJeon.github.io/tags/asynchronous/>Asynchronous</a></li></ul><nav class=paginav><a class=prev href=https://HyoseungJeon.github.io/posts/intellij/thymeleaf/><span class=title>« Prev</span><br><span>Thymeleaf</span></a>
<a class=next href=https://HyoseungJeon.github.io/posts/spring/requestcontextholder/><span class=title>Next »</span><br><span>RequestContextHolder</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://HyoseungJeon.github.io/>HyoSeung IT blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>