<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>RequestContextHolder | HyoSeung IT blog</title><meta name=keywords content><meta name=description content="설명 Spring 2.0 부터 추가된 기능으로 Request 인입 후 thread 생성 된 시점부터 전 구간에서 HttpServletRequest에 접근을 가능하게 해주는 기능이다.
기존 Controller 단에 parameter 형식으로 선언 후 참고하던 방식과 다르게 위 객체를 통하여 request에 접근이 가능하다.
예제 소스 :
@GetMapping(&#34;hello&#34;) public void before(HttpServletRequest request) { sampleService.hello(request); } @GetMapping(&#34;hello&#34;) public void after() { HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest(); sampleService.hello(request); } 동작 원리 Request 인입 시 Spring 내 ThreadLocal 이라는 공간에 값을 저장하는 방식이다."><meta name=author content="HyoSeung Jeon"><link rel=canonical href=https://HyoseungJeon.github.io/posts/spring/requestcontextholder/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.css rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href="https://avatars.githubusercontent.com/u/39950673?s=400&amp;u=729b17ca9c5632e754da66f17f45eb61aeea271e&amp;v=4"><link rel=icon type=image/png sizes=16x16 href=https://HyoseungJeon.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://HyoseungJeon.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://HyoseungJeon.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://HyoseungJeon.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="RequestContextHolder"><meta property="og:description" content="설명 Spring 2.0 부터 추가된 기능으로 Request 인입 후 thread 생성 된 시점부터 전 구간에서 HttpServletRequest에 접근을 가능하게 해주는 기능이다.
기존 Controller 단에 parameter 형식으로 선언 후 참고하던 방식과 다르게 위 객체를 통하여 request에 접근이 가능하다.
예제 소스 :
@GetMapping(&#34;hello&#34;) public void before(HttpServletRequest request) { sampleService.hello(request); } @GetMapping(&#34;hello&#34;) public void after() { HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest(); sampleService.hello(request); } 동작 원리 Request 인입 시 Spring 내 ThreadLocal 이라는 공간에 값을 저장하는 방식이다."><meta property="og:type" content="article"><meta property="og:url" content="https://HyoseungJeon.github.io/posts/spring/requestcontextholder/"><meta property="og:image" content="https://avatars.githubusercontent.com/u/39950673?s=400&u=729b17ca9c5632e754da66f17f45eb61aeea271e&v=4"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-07T10:47:43+09:00"><meta property="article:modified_time" content="2023-07-07T10:47:43+09:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://avatars.githubusercontent.com/u/39950673?s=400&u=729b17ca9c5632e754da66f17f45eb61aeea271e&v=4"><meta name=twitter:title content="RequestContextHolder"><meta name=twitter:description content="설명 Spring 2.0 부터 추가된 기능으로 Request 인입 후 thread 생성 된 시점부터 전 구간에서 HttpServletRequest에 접근을 가능하게 해주는 기능이다.
기존 Controller 단에 parameter 형식으로 선언 후 참고하던 방식과 다르게 위 객체를 통하여 request에 접근이 가능하다.
예제 소스 :
@GetMapping(&#34;hello&#34;) public void before(HttpServletRequest request) { sampleService.hello(request); } @GetMapping(&#34;hello&#34;) public void after() { HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest(); sampleService.hello(request); } 동작 원리 Request 인입 시 Spring 내 ThreadLocal 이라는 공간에 값을 저장하는 방식이다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://HyoseungJeon.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Spring","item":"https://HyoseungJeon.github.io/posts/spring/"},{"@type":"ListItem","position":3,"name":"RequestContextHolder","item":"https://HyoseungJeon.github.io/posts/spring/requestcontextholder/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"RequestContextHolder","name":"RequestContextHolder","description":"설명 Spring 2.0 부터 추가된 기능으로 Request 인입 후 thread 생성 된 시점부터 전 구간에서 HttpServletRequest에 접근을 가능하게 해주는 기능이다.\n기존 Controller 단에 parameter 형식으로 선언 후 참고하던 방식과 다르게 위 객체를 통하여 request에 접근이 가능하다.\n예제 소스 :\n@GetMapping(\u0026#34;hello\u0026#34;) public void before(HttpServletRequest request) { sampleService.hello(request); } @GetMapping(\u0026#34;hello\u0026#34;) public void after() { HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest(); sampleService.hello(request); } 동작 원리 Request 인입 시 Spring 내 ThreadLocal 이라는 공간에 값을 저장하는 방식이다.","keywords":[],"articleBody":" 설명 Spring 2.0 부터 추가된 기능으로 Request 인입 후 thread 생성 된 시점부터 전 구간에서 HttpServletRequest에 접근을 가능하게 해주는 기능이다.\n기존 Controller 단에 parameter 형식으로 선언 후 참고하던 방식과 다르게 위 객체를 통하여 request에 접근이 가능하다.\n예제 소스 :\n@GetMapping(\"hello\") public void before(HttpServletRequest request) { sampleService.hello(request); } @GetMapping(\"hello\") public void after() { HttpServletRequest request = ((ServletRequestAttributes)RequestContextHolder.currentRequestAttributes()).getRequest(); sampleService.hello(request); } 동작 원리 Request 인입 시 Spring 내 ThreadLocal 이라는 공간에 값을 저장하는 방식이다. 이름에서도 유추할 수 있듯이 단일 Thread내에 저장되는 방식으로 이외 Thread에서는 값 참조가 불가능하게 된다. 단, Inheritable = true 옵션값을 통하여 중첩 Thread 내에서 부모 Thread 값 참조가 가능하다. 자세한 내용은 ref site 참고\n장점 1차적인 장점으로는 request 객체를 참조하기 위해 매번 parameter에 선언한 필요가 없다는 것이다. 불필요한 코드 작성을 줄이고 가독성을 높여준다.\n전 구간에서 참조 가능하다. Controller에서 request 정보를 받아 다른 Service 내리거나 하는 작업이 생략된다.\n→ 위 점을 활용하여 request 정보를 활용하는 공통 Util class를 구현한다면 베스트 인 것 같다!!\n내 활용 방식 진행하던 프로젝트 내에서 Exception 발생 시 공통으로 인입 된 값을 logging 하는 방식에 활용했다. 기존 APM을 통하여 body 내 값이나 query 방식의 값들을 최적화된 log 값들과 함께 같이 세팅하여 기록하도록 구현하였다.\nrefs: RequestContextHolder (Spring Framework 6.0.11 API)\nRequestContextHolder\nSpring RequestContextHolder - 어디서든 HttpServletReqeust 사용하기\nSpring RequestContextHolder\n","wordCount":"201","inLanguage":"en","datePublished":"2023-07-07T10:47:43+09:00","dateModified":"2023-07-07T10:47:43+09:00","author":{"@type":"Person","name":"HyoSeung Jeon"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://HyoseungJeon.github.io/posts/spring/requestcontextholder/"},"publisher":{"@type":"Organization","name":"HyoSeung IT blog","logo":{"@type":"ImageObject","url":"https://avatars.githubusercontent.com/u/39950673?s=400\u0026u=729b17ca9c5632e754da66f17f45eb61aeea271e\u0026v=4"}}}</script><link rel=stylesheet href=https://HyoseungJeon.github.io/scss/main.css></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://HyoseungJeon.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://HyoseungJeon.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://HyoseungJeon.github.io/posts/ title=posts><span style=font-family:SUITE-Regular;font-size:19px>posts</span></a></li><li><a href=https://HyoseungJeon.github.io/tags/ title=tags><span style=font-family:SUITE-Regular;font-size:19px>tags</span></a></li><li><a href=https://HyoseungJeon.github.io/archives/ title=archives><span style=font-family:SUITE-Regular;font-size:19px>archives</span></a></li><li><a href=https://HyoseungJeon.github.io/search/ title="search (Alt + /)" accesskey=/><span style=font-family:SUITE-Regular;font-size:19px><i class='fa-brands fa-github'></i>search</span></a></li></ul></nav></header><main class="main page"><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://HyoseungJeon.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://HyoseungJeon.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://HyoseungJeon.github.io/posts/spring/>Spring</a></div><h1 class=post-title>RequestContextHolder</h1><div class=post-meta><span title='2023-07-07 10:47:43 +0900 +0900'>July 7, 2023</span>&nbsp;·&nbsp;201 words&nbsp;·&nbsp;HyoSeung Jeon</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner style=padding-top:10px><ul><li><a href=#%ec%84%a4%eb%aa%85 aria-label=설명>설명</a></li><li><a href=#%eb%8f%99%ec%9e%91-%ec%9b%90%eb%a6%ac aria-label="동작 원리">동작 원리</a></li><li><a href=#%ec%9e%a5%ec%a0%90 aria-label=장점>장점</a></li><li><a href=#%eb%82%b4-%ed%99%9c%ec%9a%a9-%eb%b0%a9%ec%8b%9d aria-label="내 활용 방식">내 활용 방식</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><hr><h3 id=설명>설명<a hidden class=anchor aria-hidden=true href=#설명>#</a></h3><p>Spring 2.0 부터 추가된 기능으로 Request 인입 후 thread 생성 된 시점부터 전 구간에서 HttpServletRequest에 접근을 가능하게 해주는 기능이다.</p><p>기존 Controller 단에 parameter 형식으로 선언 후 참고하던 방식과 다르게 위 객체를 통하여 request에 접근이 가능하다.</p><p>예제 소스 :</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@GetMapping</span><span class=o>(</span><span class=s>&#34;hello&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>before</span><span class=o>(</span><span class=n>HttpServletRequest</span> <span class=n>request</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sampleService</span><span class=o>.</span><span class=na>hello</span><span class=o>(</span><span class=n>request</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@GetMapping</span><span class=o>(</span><span class=s>&#34;hello&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>after</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>HttpServletRequest</span> <span class=n>request</span> <span class=o>=</span> <span class=o>((</span><span class=n>ServletRequestAttributes</span><span class=o>)</span><span class=n>RequestContextHolder</span><span class=o>.</span><span class=na>currentRequestAttributes</span><span class=o>()).</span><span class=na>getRequest</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=n>sampleService</span><span class=o>.</span><span class=na>hello</span><span class=o>(</span><span class=n>request</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span></code></pre></div><hr><h3 id=동작-원리>동작 원리<a hidden class=anchor aria-hidden=true href=#동작-원리>#</a></h3><p>Request 인입 시 Spring 내 ThreadLocal 이라는 공간에 값을 저장하는 방식이다. 이름에서도 유추할 수 있듯이 단일 Thread내에 저장되는 방식으로 이외 Thread에서는 값 참조가 불가능하게 된다. 단, Inheritable = true 옵션값을 통하여 중첩 Thread 내에서 부모 Thread 값 참조가 가능하다. 자세한 내용은 ref site 참고</p><hr><h3 id=장점>장점<a hidden class=anchor aria-hidden=true href=#장점>#</a></h3><p>1차적인 장점으로는 request 객체를 참조하기 위해 매번 parameter에 선언한 필요가 없다는 것이다. 불필요한 코드 작성을 줄이고 가독성을 높여준다.</p><p>전 구간에서 참조 가능하다. Controller에서 request 정보를 받아 다른 Service 내리거나 하는 작업이 생략된다.</p><p>→ 위 점을 활용하여 request 정보를 활용하는 공통 Util class를 구현한다면 베스트 인 것 같다!!</p><hr><h3 id=내-활용-방식>내 활용 방식<a hidden class=anchor aria-hidden=true href=#내-활용-방식>#</a></h3><p>진행하던 프로젝트 내에서 Exception 발생 시 공통으로 인입 된 값을 logging 하는 방식에 활용했다. 기존 APM을 통하여 body 내 값이나 query 방식의 값들을 최적화된 log 값들과 함께 같이 세팅하여 기록하도록 구현하였다.</p><hr><ul><li>refs:</li></ul><p><a href=https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/context/request/RequestContextHolder.html>RequestContextHolder (Spring Framework 6.0.11 API)</a></p><p><a href=https://findmypiece.tistory.com/125>RequestContextHolder</a></p><p><a href=http://dveamer.github.io/backend/SpringRequestContextHolder.html>Spring RequestContextHolder - 어디서든 HttpServletReqeust 사용하기</a></p><p><a href=https://gompangs.tistory.com/entry/Spring-RequestContextHolder>Spring RequestContextHolder</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://HyoseungJeon.github.io/posts/java/future/><span class=title>« Prev</span><br><span>Future</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://HyoseungJeon.github.io/>HyoSeung IT blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>